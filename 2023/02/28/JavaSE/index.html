<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JavaSE  Java 概述Java发展历程 Java发展的重大事件  1990年，在 Sun 计算机公司中，由 atrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 Oak，后期命名为 Java。 1995年， Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。 19">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE">
<meta property="og:url" content="http://example.com/2023/02/28/JavaSE/index.html">
<meta property="og:site_name" content="MineTing">
<meta property="og:description" content="JavaSE  Java 概述Java发展历程 Java发展的重大事件  1990年，在 Sun 计算机公司中，由 atrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 Oak，后期命名为 Java。 1995年， Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。 19">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/02/28/JavaSE/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0%E7%AE%80%E5%8D%95%E7%89%88.png">
<meta property="article:published_time" content="2023-02-27T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-06T18:12:07.632Z">
<meta property="article:author" content="Fei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/02/28/JavaSE/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0%E7%AE%80%E5%8D%95%E7%89%88.png">

<link rel="canonical" href="http://example.com/2023/02/28/JavaSE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>JavaSE | MineTing</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MineTing</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/28/JavaSE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MineTing">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaSE
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2023-02-28T00:00:00+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-07 02:12:07" itemprop="dateModified" datetime="2023-03-07T02:12:07+08:00">2023-03-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <div align="center"><font size="70"><b>JavaSE</b></font></div>

<h1 id="Java-概述"><a href="#Java-概述" class="headerlink" title="Java 概述"></a>Java 概述</h1><h2 id="Java发展历程"><a href="#Java发展历程" class="headerlink" title="Java发展历程"></a>Java发展历程</h2><blockquote>
<p><strong>Java发展的重大事件</strong></p>
<ul>
<li>1990年，在 Sun 计算机公司中，由 atrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 Oak，后期命名为 Java。</li>
<li>1995年， Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。</li>
<li>1996年1月23日 Sun Microsystems 发布了 JDK 1.0。</li>
<li>1998年，JDK 1.2版本发布。同时，Sun 发布了 JSP&#x2F;Servlet、EJB 规范，以及将 Java 分成了 J2EE、J2SE 和 J2ME。这表明了 Java 开始向企业、桌面应用和移动设备应用3大领域挺进。</li>
<li>2000年，JDK 1.3 发布，Java HotSpot Virtual Machine正式发布，成为 Java 的默认虛拟机。</li>
<li>2002年，JDK 1.4 发布，古老的 Classic 虚拟机退出历史舞台。</li>
<li>2003年年底，Java 平台的 Scala 正式发布，同年 Groovy 也加入了 Java 阵营。</li>
<li>2004年，JDK 1.5 发布。同时 JDK 1.5 改名为 JavaSE 5.0。</li>
<li>2006年，JDK 6 发布。同年，Java 开源并建立了 OpenJDK。顺理成章，Hotspot 虚拟机也成为了 OpenJDK 中的默认虛拟机。</li>
<li>2007年，Java 平台迎来了新伙伴 Clojure。</li>
<li>2008年，Oracle 收购了BEA， 得到了 JRockit 虚拟机。</li>
<li>2009年，Twitter 宣布把后台大部分程序从 Ruby 迁移到 scala，这是 Java 平台的又一次大规模应用。</li>
<li>2010年，Oracle 收购了 Sun，获得 Java 商标和最具价值的 HotSpot 虚拟机。此时，Oracle 拥有市场占用率最高的两款虚拟机 HotSpot 和 JRockit，并计划在未来对它们进行整合： HotRockit. JCP组织管理： Java 语言</li>
<li>2011年，JDK7 发布。在JDK 1. 7u4中，正式启用了新的垃圾回收器G1。</li>
<li>2017年，JDK9 发布。将G1设置为默认GC，替代CMS，同年，IBM的J9开源，形成了现在的Open J9社区。</li>
<li>2018年，Android 的 Java 侵权案判决，Google 赔偿 Oracle 计88亿美元，同年，Oracle 宣告 JavaEE成为历史名词，JDBC、 JMS、Servlet 赠予 Eclipse 基金会，同年，JDK11 发布，LTS 版本的 JDK，发布革命性的 ZGC，调整 JDK 授权许可。</li>
<li>2019年，JDK12 发布，加入 RedHat 领导开发的 Shenandoah GC。</li>
</ul>
</blockquote>
<h2 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h2><blockquote>
<ul>
<li><p><strong>一次编译，到处运行（基于栈的指令设计）</strong></p>
</li>
<li><p><strong>自动内存管理</strong></p>
</li>
<li><p><strong>自动垃圾回收机制</strong></p>
</li>
</ul>
</blockquote>
<h2 id="Java两种核心机制"><a href="#Java两种核心机制" class="headerlink" title="Java两种核心机制"></a>Java两种核心机制</h2><blockquote>
<ul>
<li><strong>Java虚拟机 (Java Virtal Machine)</strong></li>
<li><strong>垃圾收集机制 (Garbage Collection)</strong></li>
</ul>
</blockquote>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><h1 id="Java-基本语法"><a href="#Java-基本语法" class="headerlink" title="Java 基本语法"></a>Java 基本语法</h1><h2 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h2><h2 id="数据类型及强制类型转换"><a href="#数据类型及强制类型转换" class="headerlink" title="数据类型及强制类型转换"></a>数据类型及强制类型转换</h2><h3 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h3><p><strong>1. 变量分类：按数据类型分类</strong> </p>
<ul>
<li><p>基本数据类型</p>
<ul>
<li>数值型：byte	short	long	double	float	int</li>
<li>字符型：char</li>
<li>布尔型：boolean</li>
</ul>
</li>
<li><p>引用数据类型</p>
<ul>
<li>类</li>
<li>接口</li>
<li>数组</li>
</ul>
</li>
</ul>
<p><strong>2. 变量分类：按声明类型分类</strong></p>
<ul>
<li><p>成员变量</p>
<ul>
<li>实例变量</li>
<li>类变量</li>
</ul>
</li>
<li><p>局部变量</p>
<ul>
<li>形参</li>
<li>方法局部变量</li>
<li>代码块局部变量</li>
</ul>
</li>
</ul>
<h3 id="数据类型说明"><a href="#数据类型说明" class="headerlink" title="数据类型说明"></a>数据类型说明</h3><p>字节分配大小：</p>
<table>
<thead>
<tr>
<th>byte</th>
<th>short</th>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>char</th>
<th>boolean</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>4</td>
<td>8</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>整数默认为 int 类型，小数默认 double 类型；</strong>因此，定义 long 类型时，要加 l 或 L ，定义 float 类型时要加 f 或 F。</p>
<p><strong>char类型</strong></p>
<blockquote>
<p><strong>注意事项</strong></p>
<ol>
<li><p>Java中的所有字符都使用 Unicode 字符集编码，用以存储一个字母，汉字等。</p>
</li>
<li><p>字符常量是用单引号 (‘ ‘) 括起来的单个字符。例如：char c1 &#x3D; ‘a’; char c2&#x3D; ‘中’; char c3 &#x3D; ‘9’;</p>
</li>
<li><p>Java中允许使用转义字符 ‘\‘ 来将其后的字符转变为特殊字符型常量。例如：char c3 &#x3D; ‘\n’;</p>
</li>
<li><p>直接使用 Unicode 值来表示字符型常量：‘\uXXXX’。其中，XXXX代表一个十六进制整数。如：\u000a 表示 \n。char 类型的范围为：\u0000到\uffff。</p>
</li>
<li><p>char 类型是可以进行运算的，因为它都对应有 Unicode 码。</p>
</li>
</ol>
</blockquote>
<p><strong>boolean类型</strong></p>
<blockquote>
<p><strong>注意事项</strong></p>
<ol>
<li><p>boolean 类型数据只允许取值 true 和 false，无null。</p>
</li>
<li><p>不可以使用 0 或非 0 的整数替代 false 和 true（boolean 类型不能与其它数据类型运算&#x2F;转换）。</p>
</li>
<li><p>Java 虚拟机中没有任何供 boolean 值专用的字节码指令，Java语言表达所操作的。</p>
</li>
<li><p>boolean 值，在编译之后都使用 java 虚拟机中的 int 数据类型来代替：true 用 1 表示，false 用 0 表示。——《java虚拟机规范 8版》</p>
</li>
</ol>
</blockquote>
<p><strong>数组元素（引用）的默认初始化值：</strong></p>
<table>
<thead>
<tr>
<th>数组元素类型</th>
<th>元素默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0F</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
</tbody></table>
<h3 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><blockquote>
<p>注意事项</p>
<ol>
<li><p>long 取值范围是小于 float 的</p>
</li>
<li><p>范围小的类型自动转换为范围大的数据类型</p>
</li>
<li><p>byte, short, char 之间不会相互转换，它们在计算时首先会转换为 int 类型</p>
</li>
<li><p>boolean 类型不能与其它数据类型运算</p>
</li>
<li><p>基本数据类型和 String 做加法运算时，会自动转换为 String 类型</p>
</li>
</ol>
</blockquote>
<h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><blockquote>
<p>注意事项</p>
<ol>
<li><p>将大范围数据类型转换为小范围的数据类型，但可能造成数据溢出，精度降低。</p>
</li>
<li><p>基本数据类型可以通过包装类转换为引用类型。</p>
</li>
</ol>
</blockquote>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><strong>+	-	*	&#x2F; 	%	++ 	–</strong> </p>
<h3 id="赋值运算符的一个问题"><a href="#赋值运算符的一个问题" class="headerlink" title="赋值运算符的一个问题"></a>赋值运算符的一个问题</h3><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><h1 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h1><h2 id="类与对象概述"><a href="#类与对象概述" class="headerlink" title="类与对象概述"></a>类与对象概述</h2><p><strong>面向过程（POP）与 面向对象（OOP）</strong></p>
<blockquote>
<p>二者都是一种思想，面向对象是相对于面向过程而言的。</p>
<p>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</p>
<p>面向对象：将功能封装进对象，强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。</p>
</blockquote>
<p><strong>对象的创建和使用</strong></p>
<p>创建对象语法： 类名 对象名称 &#x3D; new 类名( );</p>
<p>使用 “对象名.对象成员” 的方式访问对象成员（包括属性和方法）</p>
<p><strong>匿名对象</strong>：方法只调用一次 new Object( ).method( )</p>
<h2 id="内存分配概述"><a href="#内存分配概述" class="headerlink" title="内存分配概述"></a>内存分配概述</h2><p><strong>堆（Heap）</strong></p>
<p>​		此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</p>
<p><strong>栈（Stack）</strong></p>
<p>​		通常所说的栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char 、 short 、 int 、 float 、 long 、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。</p>
<p><strong>方法区（Method Area）</strong></p>
<p>​		用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p><img src="/2023/02/28/JavaSE/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0%E7%AE%80%E5%8D%95%E7%89%88.png" alt="内存结构概述简单版"></p>
<h2 id="局部变量没有初始值的原因"><a href="#局部变量没有初始值的原因" class="headerlink" title="局部变量没有初始值的原因"></a>局部变量没有初始值的原因</h2><blockquote>
<p>为什么类的成员变量有默认初始值而方法内的局部变量却没有初始值？</p>
<p>JVM 将字节码加载到内存中，涉及加载、验证、准备、解析、初始化等过程，对于静态成员变量，会有两次赋值，分别在准备阶段（赋值为默认值）和初始化阶段（赋值为具体的阶段）。对于非静态成员变量，只会在初始化阶段进行赋值。</p>
<p>局部变量属于方法，方法在被调用时，存储在栈帧的局部变量期间未经过初始化，因此需要先赋值才能使用。</p>
<p>对于基本数据类型而言，默认初始化值各有不同。</p>
<p>对于引用数据类型而言，默认初始化值为 null（注意与0不同）</p>
</blockquote>
<h2 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h2><h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><p>成员变量与局部变量的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>声明位置</td>
<td>直接在类中，方法体外</td>
<td>方法形参或内部、代码块、构造器等</td>
</tr>
<tr>
<td>修饰符</td>
<td>private、public、static、final</td>
<td>不能使用权限修饰符，但可以使用 final</td>
</tr>
<tr>
<td>初始化值</td>
<td>由默认初始化值</td>
<td>没有默认初始化值，必须显式赋值后，方可使用</td>
</tr>
<tr>
<td>内存加载位置</td>
<td>堆位置或静态域内</td>
<td>栈空间</td>
</tr>
</tbody></table>
<p>对象属性默认初始化值：基本类型：0 或 false 或、\u0000(char)，引用类型：null。</p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p><strong>方法的声明格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 形参<span class="number">1</span>, 参数类型 形参<span class="number">2</span>, ….）｛</span><br><span class="line"></span><br><span class="line">   方法体程序代码</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> 返回值;</span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p><strong>方法的返回值为void时，可以使用return；但没意义</strong></p>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><blockquote>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>在同一个类中，允许存在一个以上的同名方法，要求它们的参数个数或者参数类型或参数顺序不同即可。</li>
<li>与参数名称、返回值类型无关，只与参数列表，且<strong>参数列表</strong>必须不同。(参数个数、参数类型、参数顺序)。</li>
<li>调用时JVM进行区分，根据方法参数列表的不同来区别。</li>
</ul>
</blockquote>
<p>代码示例：（重载）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法的重载：</span></span><br><span class="line"><span class="comment"> * 与参数名称、返回值类型无关，只与参数列表，且参数列表必须不同。(参数个数、参数类型、参数顺序)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverLoadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&quot;原始方法&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printContent</span><span class="params">(String cent, <span class="type">int</span> point, <span class="type">boolean</span> append)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Original Method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重载：与参数名称无关</span></span><br><span class="line">    <span class="comment">/*public void printContent(String arg1, int arg2, boolean arg3) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Not OverLoad!&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重载：与返回值无关</span></span><br><span class="line">    <span class="comment">/*public int printContent(String cent, int point, boolean append) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Not OverLoad!&quot;);</span></span><br><span class="line"><span class="comment">        return 0;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载：与参数个数相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printContent</span><span class="params">(String cent, <span class="type">int</span> point)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverLoad!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载：与参数顺序相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printContent</span><span class="params">(<span class="type">int</span> point, String cent, <span class="type">boolean</span> append)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverLoad!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载：与参数类型相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printContent</span><span class="params">(String cent, String point, <span class="type">int</span> append)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverLoad!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h3><p><strong>Java 里方法的参数传递方式只有一种：值传递。</strong> </p>
<p>即将实际参数值的副本（复制）传入方法内，而参数本身不受影响。</p>
<p>形参是基本数据类型：将实参基本数据类型变量的 “数据值” 传递给形参。</p>
<p>形参是引用数据类型：将实参引用数据类型变量的 “地址值” 传递给形参。</p>
<p>代码示例：（值传递）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试值传递：</span></span><br><span class="line"><span class="comment"> * Java里方法的参数传递方式只有一种：值传递。</span></span><br><span class="line"><span class="comment"> * 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参。</span></span><br><span class="line"><span class="comment"> * 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParametersPassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changePrimaryType</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        num = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeReferenceType</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        changePrimaryType(num);</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + num); <span class="comment">// num = 0</span></span><br><span class="line">        changeReferenceType(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr)); <span class="comment">// arr = [-1, 2, 3]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可变参数的方法"><a href="#可变参数的方法" class="headerlink" title="可变参数的方法"></a>可变参数的方法</h3><blockquote>
<p>JavaSE 5.0 中提供了Varargs（variable number of arguments）机制，允许直接定义能和多个实参相匹配的形参。从而传递个数可变的实参。</p>
<ul>
<li><p>JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</p>
<p><strong>public static void method(int a ,String[] values);</strong></p>
</li>
<li><p>JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量</p>
<p><strong>public static void method(int a , String…args);</strong></p>
</li>
</ul>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>声明格式：方法名(参数的类型名 **…**参数名)。</p>
</li>
<li><p>方法的参数部分有可变形参，需要放在形参声明的最后。</p>
</li>
<li><p>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个。</p>
</li>
<li><p>可变个数形参的方法与同名的方法之间，彼此构成重载。</p>
</li>
<li><p>可变参数方法的使用与方法参数部分使用数组是一致的。</p>
</li>
<li><p>在一个方法的形参位置，最多只能声明一个可变个数形参。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（可变参数）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可变参数测试</span></span><br><span class="line"><span class="comment"> * 注意事项：</span></span><br><span class="line"><span class="comment"> * 1.声明格式：方法名(参数的类型名 ...参数名)。</span></span><br><span class="line"><span class="comment"> * 2.方法的参数部分有可变形参，需要放在形参声明的最后。</span></span><br><span class="line"><span class="comment"> * 3.可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个。</span></span><br><span class="line"><span class="comment"> * 4.可变个数形参的方法与同名的方法之间，彼此构成重载。</span></span><br><span class="line"><span class="comment"> * 5.可变参数方法的使用与方法参数部分使用数组是一致的。</span></span><br><span class="line"><span class="comment"> * 6.在一个方法的形参位置，最多只能声明一个可变个数形参。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarArgsTest</span> &#123;</span><br><span class="line">    <span class="comment">// 可变参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">(String title, String content, String... other)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;title: &quot;</span> + title + <span class="string">&quot;, content: &quot;</span> + content + <span class="string">&quot;, other: &quot;</span> + Arrays.asList(other));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可变个数形参的方法与同名的方法之间，彼此构成重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法及注意事项"><a href="#构造方法及注意事项" class="headerlink" title="构造方法及注意事项"></a>构造方法及注意事项</h3><p>构造方法的作用：创建对象并初始化</p>
<p><strong>语法格式：</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 类名 (参数列表) &#123;</span><br><span class="line">    初始化语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>构造方法与类同名，一个类可以创建多个重载的构造器（使对象的创建更加灵活）</p>
</li>
<li><p>父类的构造器不可被子类继承（语法规范）</p>
</li>
<li><p>默认构造器的权限修饰符与所属类的权限修饰符一致（可以使用其他修饰符 private，默认的，protected，public）</p>
</li>
<li><p>构造方法没有返回值，不能被 static、final、synchronized、abstract、native 修饰，不能有 return 语句返回值，否则就是普通方法</p>
</li>
<li><p>每个类都至少有一个构造器，一旦显式定义了构造器，则系统不再提供默认构造器</p>
</li>
</ol>
</blockquote>
<h3 id="关键字-this"><a href="#关键字-this" class="headerlink" title="关键字 this"></a>关键字 this</h3><p><strong>this的含义</strong>：当前对象的引用，可以调用当前类的属性、方法和构造器。</p>
<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>使用 this 调用本类的构造器，通过 this(形参列表) 调用本类中重载的其他构造器，但不能调用自身</p>
</li>
<li><p>在类的构造器中，最多只能声明一个 this(形参列表)。且this(形参列表) 必须放在构造器的首行</p>
</li>
<li><p>this 可以调用当前对象的其他属性&#x2F;方法。也可以用 this 来区分属性和局部变量。如 this.name &#x3D; name;</p>
</li>
</ol>
</blockquote>
<p>代码示例：（this）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.构造方法与类同名，一个类可以创建多个重载的构造器（使对象的创建更加灵活）。</span></span><br><span class="line"><span class="comment"> * 2.父类的构造器不可被子类继承（语法规范）</span></span><br><span class="line"><span class="comment"> * 3.默认构造器的修饰符与所属类的修饰符一致（可以使用其他权限修饰符private，默认的，protected，public）</span></span><br><span class="line"><span class="comment"> * 4.构造方法没有返回值，不能被static、final、synchronized、abstract、native等关键字修饰，不能有return语句返回值。</span></span><br><span class="line"><span class="comment"> * 5.每个类都至少有一个构造器，一旦显式定义了构造器，则系统不再提供默认构造器。</span></span><br><span class="line"><span class="comment"> * 6.在类的构造器中，最多只能声明一个this(形参列表)。且this(形参列表) 必须放在构造器的首行。</span></span><br><span class="line"><span class="comment"> * 7.this可以调用当前对象的其他属性/方法。也可以用this来区分属性和局部变量。如：this.name = name;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorThisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ConstructorThisTest</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//    static ConstructorThisTest()&#123;</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;non-block&quot;</span>);</span><br><span class="line"><span class="comment">//        return null;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个类可以创建多个重载的构造器（使对象的创建更加灵活）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorThisTest</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封装性与权限修饰符"><a href="#封装性与权限修饰符" class="headerlink" title="封装性与权限修饰符"></a>封装性与权限修饰符</h2><h3 id="封装性概述"><a href="#封装性概述" class="headerlink" title="封装性概述"></a>封装性概述</h3><blockquote>
<p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉。</p>
<p>低耦合：仅对外暴露少量的方法用于使用。</p>
<p><strong>封装的思想</strong>：隐藏对象内部的复杂性，只对外公开简单的接口，便于外界调用，从而提高系统的可扩展性、可维护性。</p>
<p>Java 中通过将数据声明为私有的（private），再提供公共的 public 方法： getXxx()  和 setXxx() 实现对该属性的操作，以实现下述目的：</p>
<ol>
<li><p>隐藏一个类中不需要对外提供的实现细节。</p>
</li>
<li><p>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑。</p>
</li>
<li><p><strong>限制对属性的不合理操作。</strong></p>
</li>
<li><p>便于修改，增强代码的可维护性。</p>
</li>
</ol>
<p>即：<strong>使用者对类内部定义的属性（对象的成员变量）的直接操作会导致数据的错误、混乱或安全性问题。</strong></p>
</blockquote>
<h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>package 语句作为 Java 源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。它的格式为：package 域名反写..子包名 ;</p>
<p>包的作用：</p>
<ol>
<li><p>包帮助管理大型软件系统：将功能相近的类划分到同一个包中。</p>
</li>
<li><p>包可以包含类和子包，划分项目层次，便于管理。</p>
</li>
<li><p>解决类命名冲突的问题。</p>
</li>
<li><p>控制访问权限。</p>
</li>
</ol>
<blockquote>
<p><strong>注意事项：</strong></p>
<p>使用 javac 编译单个 java 文件没有问题，但对于带有 package 的 Java 源文件进行编译时，可以使用 **javac -d文件目录 Test.java **进行编译，之后切换至 class 文件所在目录通过 java 命令运行程序。</p>
</blockquote>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>为使用定义在不同包中的 Java 类，需用 import 语句来引入指定包层次下所需要的类或全部类(.*)。</p>
<p>语法格式：import 包名. 类名;</p>
<blockquote>
<p>注意事项：</p>
<ol>
<li><p>在源文件中使用 import 显式的导入指定包下的类或接口。</p>
</li>
<li><p>声明在包的声明和类的声明之间。</p>
</li>
<li><p>如果需要导入多个类或接口，那么就并列显式多个 import 语句即可。也可以使用 java.util.* 的方式，一次性导入 util包下所有的类或接口。</p>
</li>
<li><p>如果导入的类或接口是 java.lang 包下的，或者是当前包下的，则可以省略此 import 语句。</p>
</li>
<li><p><strong>如果在代码中使用不同包下的同名的类。</strong>那么就需要使用类的全类名的方式指明调用的是哪个类。</p>
</li>
<li><p>如果已经导入 java.a 包下的类。那么如果需要使用 a 包的子包下的类的话，仍然需要导入。</p>
</li>
<li><p><strong>import static 组合的使用：</strong>调用指定类或接口下的静态的属性或方法。</p>
</li>
</ol>
</blockquote>
<h3 id="四种访问权限修饰符"><a href="#四种访问权限修饰符" class="headerlink" title="四种访问权限修饰符"></a>四种访问权限修饰符</h3><p>Java 权限修饰符 public、protected、 (缺省)、 private 置于类的成员定义前，用来限定对象对该类成员的访问权限。</p>
<blockquote>
<p><strong>注意事项</strong></p>
<ol>
<li><p><strong>对于 外部类的权限修饰只可以用 public 和 default （缺省）</strong></p>
</li>
<li><p>一个 Java 文件只能有一个 public 类（如果有多个，则不知道调用那个类的 main 方法，且文件名必须与 public 修饰的类一致），如果一个文件有多个类，类名和文件名一样，该类必须使用 public 修饰，其他类不能使用 public 修饰。若没用 public 修饰，类名与文件名可以不一样</p>
</li>
<li><p>四种访问权限修饰符的对比</p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>(default)</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>同一个包</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>不同包子类</td>
<td>是</td>
<td><strong>是</strong></td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>不同包非子类</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
</li>
<li><p>protected 当前类，相同包下的类，不同包的子类（给子类使用）可以访问</p>
<p><strong>补充：</strong>若子类与父类不在同一包中，那么在子类中，可以通过子类实例访问从父类继承而来的protected方法，而不能直接访问父类实例的protected方法</p>
</li>
<li><p><strong>默认修饰符：只能在同包中访问，子包也不可以</strong></p>
</li>
</ol>
</blockquote>
<p>代码示例：（protected ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.oop.permit.pa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.oop.permit.pb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.oop.permit.pa.Super;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodA()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Super</span> <span class="variable">aSuper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Super</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            若子类与父类不在同一包中，那么在子类中，</span></span><br><span class="line"><span class="comment">            可以通过子类实例访问从父类继承而来的protected方法，</span></span><br><span class="line"><span class="comment">            而不能直接访问父类实例的protected方法，</span></span><br><span class="line"><span class="comment">            否则提示没有权限</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// aSuper.methodA();</span></span><br><span class="line">        <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        sub.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（default）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.oop.permit.pc.pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FuClass</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FuClass methodA()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FuClass methodB()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.oop.permit.pc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.oop.permit.pc.pd.FuClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiffPackageClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FuClass</span> <span class="variable">fuClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FuClass</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            默认权限修饰符：只能在同包中访问，子包也不可以</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//fuClass.methodA();</span></span><br><span class="line">        fuClass.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承概述"><a href="#继承概述" class="headerlink" title="继承概述"></a>继承概述</h3><p>将多个类中相同的属性和方法，抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承单独的类即可。多个类称为子类(派生类)，单独的这个类称为父类(基类或超类)。</p>
<p>可以理解为：“子类 is a 父类”。</p>
<blockquote>
<p><strong>继承的作用</strong></p>
<ol>
<li><p>减少了代码冗余，提高了代码的复用性，更有利于功能的扩展。</p>
</li>
<li><p>使类与类之间产生了耦合，同时也提供了多态的前提。</p>
</li>
</ol>
<p><strong>继承的注意事项</strong></p>
<ol>
<li><p>子类不能直接访问父类中私有的（private）的成员变量和方法。</p>
</li>
<li><p>子类只能获取父类非私有成员，若子类和父类都有相同成员变量，则采用【就近原则】。</p>
</li>
<li><p>Java 只支持单继承和多层继承，不允许多重继承。</p>
</li>
<li><p>super 可以获取父类的成员变量和方法，super.name，super.method。</p>
</li>
<li><p>如果访问父类方法不加 super，则会调用当前类方法，出现栈溢出。</p>
</li>
</ol>
<p><strong>继承的优点：</strong></p>
<p>​		代码重用，提高代码的可扩展性。</p>
<p><strong>继承的缺点：</strong></p>
<ol>
<li><p><strong>继承是侵入性的，只要继承就必须拥有父类的所有属性和方法。</strong></p>
</li>
<li><p>可能造成子类代码冗余、灵活性降低，因为子类必须拥有父类的属性和方法。</p>
</li>
<li><p>增强了耦合性。当父类的常量、变量和方法被修改时，必须考虑子类的修改，而且在缺乏规范的环境下，可能带来大量的代码重构。</p>
</li>
</ol>
</blockquote>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><strong>作用</strong></p>
<p>​		super可用于访问父类中定义的属性、成员方法、构造方法。</p>
<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p><strong>当子父类出现同名成员时，可以用 super 表明调用的是父类中的成员。</strong></p>
</li>
<li><p><strong>子类中所有的构造器默认都会访问父类中的空参构造器。</strong></p>
</li>
<li><p><strong>当父类中没有空参数的构造器时，子类的构造器必须通过 this(参数列表) 或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，this 与 super 只能 “二选一”，且必须放在构造器的首行。</strong></p>
</li>
<li><p><strong>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错。因此父类强烈建议：有空参构造,且不是private修饰</strong></p>
</li>
<li><p><strong>可以在子类的构造方法中使用 super( ) ，可以含参数调用父类的构造方法，子类的构造方法可以使用 this( ) 可以含参，调用当前类的其他构造方法。</strong></p>
</li>
</ol>
</blockquote>
<p>代码示例：（super 的使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试super的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类强烈建议有空参构造,且不是 private 修饰：</span></span><br><span class="line"><span class="comment"> * 1. 子类继承</span></span><br><span class="line"><span class="comment"> * 2. 反射创建对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person Constructor!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person Constructor With Arguments!&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person Common Methods!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当父类中没有空参数的构造器时，子类的构造器必须通过 this(参数列表) 或者super(参数列表)语句</span></span><br><span class="line"><span class="comment"> * 指定调用本类或者父类中相应的构造器。同时，只能&quot;二选一&quot;，且必须放在构造器的首行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Worker&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类中所有的构造器默认都会访问父类中的空参构造器</span></span><br><span class="line"><span class="comment">        且 this 和 super 只能&quot;二选一&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        <span class="comment">//super(name);</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        super调用父类属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printSuper</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + <span class="built_in">super</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        super和this访问属性/方法和构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.method();</span><br><span class="line">        System.out.println(<span class="string">&quot;Worker Common Methods!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;Worker&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + worker.name);<span class="comment">//name = Worker</span></span><br><span class="line">        worker.printSuper(); <span class="comment">//name = Person</span></span><br><span class="line">        worker.method();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            this和super都不能在静态方法中使用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;name = &quot; + super.name);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            不能访问父类的私有属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*Person person = new Person();</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;age = &quot; + person.age);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;age = &quot; + worker.age);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p><strong>方法的重写&#x2F;覆盖 (override&#x2F;overwrite)</strong></p>
<p>定义：在子类中根据需要对父类中继承来的方法进行改造。</p>
<p>在子类方法上面加 @override，表明该方法为重写，若方法声明不同，则会在编译期报错，重写发生在运行期。</p>
<blockquote>
<p><strong>重写的规则：</strong> </p>
<ol>
<li><strong>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表（顺序、类型、个数）。</strong></li>
<li><strong>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型。返回值类型为 void 和基本类型时，子类方法也为 void 和基本类型，如果是引用类型，重写的方法返回值必须相同或是其子类。</strong></li>
<li><strong>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限，子类不能重写父类中声明为 private 权限的方法。</strong></li>
<li><strong>子类方法抛出的异常不能大于父类被重写方法的异常或不抛异常。</strong></li>
<li><strong>private 修饰不能重写，final 修饰不能重写。（不能被继承，没有多态，自然不能被重写）</strong></li>
<li><strong>静态方法不能重写，子类和父类的静态方法可以相同，但不是重写（重写发生在运行期）, static 方法是属于类的，子类无法覆盖父类的方法。</strong></li>
<li><strong>构造方法不能被重写。（反例：方法名必须和类名相同）</strong></li>
<li><strong>static 和 abstract 不能同时修饰方法（抽象方法要被重写）。</strong></li>
<li><strong>父类的静态方法不能被子类覆盖为非静态方法，父类的非静态方法不能被子类覆盖为静态方法。</strong></li>
<li><strong>父类的抽象方法可以被子类通过两种途径覆盖（即实现和覆盖）。父类的非抽象方法可以被覆盖为抽象方法，此时子类必须为抽象类。</strong></li>
</ol>
</blockquote>
<p>代码示例：（重写规则）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverWriteTest</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodA()...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodB()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodC()...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">methodD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodD()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">methodE</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodE()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodF</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodF()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        static修饰的方法不能被重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodG</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodG()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        final修饰的方法不能被重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">methodH</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodH()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private Super()&#123;&#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Super</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        构造方法不能重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Super</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodG()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类抛出异常必须小于等于父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodI</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodI()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodJ</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodJ()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodK</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodK()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        抽象方法要么实现，要么覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodL</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        static 和 abstract 不能同时使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// public static abstract void methodM();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对于引用类型，方法的返回值必须父类相同或是父类的子类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodA()...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对于void和基本数据类型，方法的返回值必须父类相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodB()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// public long methodC() &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodC()...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        private修饰的方法不能被重写，如果 @Override 修饰会报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    private void methodD()&#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Sub methodD()...&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">methodE</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// void methodE() &#123;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodE()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类方法抛出的异常不能大于父类被重写方法的异常或不抛异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// public void methodF() throws Exception &#123;//报错</span></span><br><span class="line">    <span class="comment">// public void methodF() &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodF</span><span class="params">()</span> <span class="keyword">throws</span> DownloadException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodF()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        静态方法不不能重写，是属于类的，不会报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodG</span><span class="params">()</span> <span class="keyword">throws</span> DownloadException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodF()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父类的静态方法不能被子类覆盖为非静态方法，父类的非静态方法不能被子类覆盖为静态方法。</span></span><br><span class="line">    <span class="comment">/*public void methodI() throws DownloadException &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Sub methodF()...&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static void methodJ() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Sub methodB()...&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        父类的非抽象方法可以被覆盖为抽象方法，子类必须为抽象类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodK</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        父类的抽象方法可以被子类通过两种途径覆盖（即实现和覆盖）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodL</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重写与重载的比较（略）"><a href="#重写与重载的比较（略）" class="headerlink" title="重写与重载的比较（略）"></a>重写与重载的比较（略）</h3><h3 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h3><p>使用 abstract 修饰的类和方法分别为抽象类和抽象方法。</p>
<p>对于抽象方法，只有方法的声明，没有方法的实现，以分号结束。</p>
<p><strong>解决的问题</strong></p>
<p>​		将类中不确定的功能提取出来，由不同的子类去实现，抽象类作为多个子类的模板。抽象类体现的就是一种<strong>模板模式</strong>的设计。</p>
<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>含有抽象方法的类必须被声明为抽象类。</p>
</li>
<li><p>抽象类不能被实例化，但可以有构造方法（给成员变量初始化）。</p>
</li>
<li><p>不能用 abstract 修饰变量、代码块、构造器。</p>
</li>
<li><p>不能用 abstract 修饰私有方法、静态方法、final 的方法、final 的类。</p>
</li>
<li><p>抽象类中可以有非抽象的方法、成员变量以及 final 常量。</p>
</li>
<li><p>抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体或 @Override 重写。若子类没有重写全部的抽象方法，仍为抽象类。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（抽象类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.含有抽象方法的类必须被声明为抽象类。</span></span><br><span class="line"><span class="comment"> * 2.抽象类不能被实例化，但可以有构造方法（给成员变量初始化）。</span></span><br><span class="line"><span class="comment"> * 3.不能用abstract修饰变量、代码块、构造器。</span></span><br><span class="line"><span class="comment"> * 4.不能用abstract修饰私有方法、静态方法、final的方法、final的类。</span></span><br><span class="line"><span class="comment"> * 5.抽象类中可以有非抽象的方法、成员变量以及final常量。</span></span><br><span class="line"><span class="comment"> * 6.抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体或<span class="doctag">@Override</span>重写。若子类没有重写全部的抽象方法，仍为抽象类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClassTest</span> &#123;</span><br><span class="line"><span class="comment">//public abstract final class AbstractClassTest &#123;</span></span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClassTest</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;abstract&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AbstractClassTest methodA()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private abstract void methodB()&#123;&#125;</span></span><br><span class="line"><span class="comment">//    public abstract final void methodB()&#123;&#125;</span></span><br><span class="line"><span class="comment">//    private abstract static void methodB()&#123;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbstractClassTest</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;AbstractClassTest methodC()...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口（interface）是抽象方法和常量值的集合。</p>
<p>接口一方面提供多继承的效果，另一方面抽取相同的行为特征（不是is a的关系）。</p>
<p>接口就是规范，定义的是一组规则，体现了现实世界中 “如果你是&#x2F;要…则必须能…” 的思想。</p>
<p>继承是一个”是不是”的关系，而接口实现则是 “能不能” 的关系。</p>
<blockquote>
<p><strong>接口注意事项：</strong></p>
<ol>
<li><p>接口中的成员变量默认由 public static final 修饰，抽象方法默认由 public abstract 修饰。</p>
</li>
<li><p>定义Java类的语法格式：先写 extends，后写 implements。</p>
</li>
<li><p>接口中没有构造器，接口采用多继承机制。一个类可以实现多个接口，接口也可以继承其它接口。</p>
</li>
<li><p>实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化，否则仍为抽象类。</p>
</li>
<li><p>与继承关系类似，接口与实现类之间存在多态性。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（interface）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.接口中的成员变量默认由public static final修饰，抽象方法默认由public abstract修饰。</span></span><br><span class="line"><span class="comment"> * 2.定义Java类的语法格式：先写extends，后写implements。</span></span><br><span class="line"><span class="comment"> * 3.接口中没有构造器，接口采用多继承机制。一个类可以实现多个接口，接口也可以继承其它接口。</span></span><br><span class="line"><span class="comment"> * 4.实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化，否则仍为抽象类。</span></span><br><span class="line"><span class="comment"> * 5.与继承关系类似，接口与实现类之间存在多态性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceTest</span> <span class="keyword">extends</span> <span class="title class_">ClassA</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">S</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//    JDK8：默认方法、静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ((InterfaceA) () -&gt; System.out.println(<span class="string">&quot;interface main()...&quot;</span> + S)).method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassA</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK版本中接口的改动"><a href="#JDK版本中接口的改动" class="headerlink" title="JDK版本中接口的改动"></a>JDK版本中接口的改动</h3><h4 id="JDK7：常量、抽象方法"><a href="#JDK7：常量、抽象方法" class="headerlink" title="JDK7：常量、抽象方法"></a>JDK7：常量、抽象方法</h4><h4 id="JDK8：默认方法、静态方法"><a href="#JDK8：默认方法、静态方法" class="headerlink" title="JDK8：默认方法、静态方法"></a>JDK8：默认方法、静态方法</h4><p>Java 8中，可以为接口添加静态方法和默认方法。</p>
<p><strong>添加静态方法</strong>：使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。如 Collection&#x2F;Collections 或</p>
<p>者Path&#x2F;Paths这样成对的接口和类。</p>
<p><strong>添加默认方法</strong>：默认方法使用 default 关键字修饰。可以通过实现类对象来调用。默认方法主要用于接口升级，在已有的</p>
<p>接口中提供新方法的同时，保持与旧版本代码的兼容性。如 java 8 API中对Collection、List、Comparator等接口提供了</p>
<p>大量的默认方法。</p>
<blockquote>
<p><strong>默认方法的注意事项</strong></p>
<ol>
<li><p>若一个接口中定义了一个默认方法，而另一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：<strong>接口冲突</strong>。</p>
<p><strong>解决办法</strong>：实现类必须覆盖接口中同名同参数的方法，来解决冲突。</p>
</li>
<li><p>若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。此时遵守：<strong>类优先原则</strong>。接口中具有相同名称和参数的默认方法会被忽略。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（默认方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口中的默认方法:</span></span><br><span class="line"><span class="comment"> * 1.若一个接口中定义了一个默认方法，而另一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），</span></span><br><span class="line"><span class="comment"> * 在实现类同时实现了这两个接口时，会出现：接口冲突。</span></span><br><span class="line"><span class="comment"> * 解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。</span></span><br><span class="line"><span class="comment"> * 2.若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，</span></span><br><span class="line"><span class="comment"> * 则不会出现冲突问题。此时遵守：类优先原则。接口中具有相同名称和参数的默认方法会被忽略。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceTest2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        接口冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>, Pet &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            必须实现相同的默认方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cat eat()...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        类优先原则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Taxi</span> <span class="keyword">extends</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Traffic</span> &#123;</span><br><span class="line">        <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">        public void run() &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Taxi run()...&quot;);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InterfaceTest2</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceTest2</span>();</span><br><span class="line">        test.<span class="keyword">new</span> <span class="title class_">Cat</span>().eat(); <span class="comment">// Cat eat()...</span></span><br><span class="line">        test.<span class="keyword">new</span> <span class="title class_">Taxi</span>().run(); <span class="comment">// Car run()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal eat()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pet eat()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Traffic</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Traffic run()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car run()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="JDK9：私有方法"><a href="#JDK9：私有方法" class="headerlink" title="JDK9：私有方法"></a>JDK9：私有方法</h4><p>解决问题：多个默认方法共有的重复代码提取出来，不给实现类使用。</p>
<h3 id="接口与抽象类的对比"><a href="#接口与抽象类的对比" class="headerlink" title="接口与抽象类的对比"></a>接口与抽象类的对比</h3><table>
<thead>
<tr>
<th>区别点</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>组成</td>
<td>构造方法、抽象方法、普通方法、常量、变量</td>
<td>常量、抽象方法、（JDK8默认方法、静态方法）</td>
</tr>
<tr>
<td>使用</td>
<td>子类继承</td>
<td>子类实现</td>
</tr>
<tr>
<td>关系</td>
<td>抽象类可实现多个接口</td>
<td>接口不能继承抽象类，但允许继承多个接口</td>
</tr>
<tr>
<td>常见的设计模式</td>
<td>模板方法</td>
<td>简单工厂、抽象工厂、代理模式</td>
</tr>
<tr>
<td>实际</td>
<td>作为一个模板</td>
<td>作为一个标准（规范）</td>
</tr>
</tbody></table>
<p><strong>优先使用接口，避免单继承</strong>  </p>
<p>代码示例：（接口练习一）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PracticeA</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//int x = 2;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// The field x is ambiguous(二义性，编译不通过)</span></span><br><span class="line">        <span class="comment">//System.out.println(x);</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.x);</span><br><span class="line">        System.out.println(A.x);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">D</span>().x);</span><br><span class="line">        <span class="comment">//System.out.println(x);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//默认常量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（接口练习二）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PracticeB</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Playable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bounceable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 接口中的变量默认为public static final，在Ball类的Play()方法中，&quot;ball = new Ball(&quot;Football&quot;);&quot;</span></span><br><span class="line"><span class="comment"> 改变了ball的reference，final的object是不能被改变reference的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Rollable</span> <span class="keyword">extends</span> <span class="title class_">Playable</span>, Bounceable &#123;</span><br><span class="line">    <span class="type">Ball</span> <span class="variable">ball</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ball</span>(<span class="string">&quot;PingPang&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ball</span> <span class="keyword">implements</span> <span class="title class_">Rollable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ball</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 报错：接口中的变量默认为public static final，不能被修改</span></span><br><span class="line">        <span class="comment">// ball = new Ball(&quot;Football&quot;);</span></span><br><span class="line">        System.out.println(ball.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键字-static-和-final"><a href="#关键字-static-和-final" class="headerlink" title="关键字 static 和 final"></a>关键字 static 和 final</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>类属性</strong>：作为该类各个对象之间共享的变量，不因对象的不同而改变。</p>
<p><strong>类方法</strong>：如果方法与调用者无关，则这样的方法通常被声明为类方法，直接由类名调用。</p>
<p>堆：new出来的结构：对象、数组</p>
<p>方法区：类的结构信息、静态变量、常量</p>
<p><strong>static优点：</strong></p>
<ol>
<li><p>对对象的共享数据提供单独的存储，节省空间。</p>
</li>
<li><p>可以直接被类名调用，不用在堆内存创建对象。</p>
</li>
</ol>
<p><strong>static缺点</strong>：访问出现局限性</p>
<h3 id="使用范围及注意事项"><a href="#使用范围及注意事项" class="headerlink" title="使用范围及注意事项"></a>使用范围及注意事项</h3><blockquote>
<p>在Java类中，可用static修饰属性、方法、代码块、<strong>内部类</strong></p>
<p>被修饰后的成员具备以下特点：</p>
<ol>
<li><p><strong>随着类的加载而加载，优先于对象存在，修饰的成员，被所有对象所共享。</strong></p>
</li>
<li><p><strong>访问权限允许时，可不创建对象，直接被类调用。</strong></p>
</li>
<li><p><strong>private 和 static 可以一起用，两者没有联系 private 只是权限修饰符。</strong></p>
</li>
<li><p><strong>静态方法只能访问静态成员（成员变量、成员方法），两者都最先加载。</strong></p>
</li>
<li><p><strong>静态方法中不可以使用 this super关键字（类名访问，不需要实例）。</strong></p>
</li>
<li><p><strong>非静态方法既可以访问静态也可以访问非静态，但不可以定义静态变量。</strong></p>
</li>
<li><p><strong>static 不能修饰局部变量，由于局部变量属于方法，static 优先于对象加载。</strong> </p>
</li>
<li><p><strong>static 不能修饰类，但可以修饰内部类。</strong></p>
</li>
<li><p><strong>static 不能和 abstract 一起使用。</strong></p>
</li>
<li><p><strong>static 修饰的方法不能被重写，子类和父类可以有相同方法且使用 static 修饰，但不是重写。（静态方法在编译期确定，重写方法在运行期）</strong></p>
</li>
<li><p><strong>多个静态代码块可以自上而下为定义的变量赋值。（类的加载先会加载类的结构，如变量的声明，方法的声明，之后再进行变量的赋值，赋值由上而下顺序执行(声明和赋值不会同时进行，<clinit>类构造方法由类变量和静态代码块中的语句按照顺序合并产生））</clinit></strong></p>
</li>
<li><p><strong>静态代码块可以为之后的变量赋值，但不能操作变量的原因（非法的前向引用）：类的加载先会加载类的结构，如变量的声明，方法的声明，之后再进行变量的赋值，赋值由上而下顺序执行（声明和赋值不会同时进行）。</strong></p>
</li>
</ol>
</blockquote>
<h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p>类变量：由该类的所有实例共享</p>
<p>堆：new 出来的结构：对象、数组</p>
<p>方法区：类的加载信息、静态变量、常量</p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><ol>
<li><p>没有对象的实例时，可以用类名.方法名( ) 的形式访问由 static 修饰的类方法。</p>
</li>
<li><p>在 static 方法内部只能访问类的 static 修饰的属性或方法，不能访问类的非 static 的结构。</p>
</li>
<li><p>因为不需要实例就可以访问 static 方法，因此 static 方法内部不能有 this，也不能有 super。不能使用 super 父类的静态方法。this 和 super 都不能在静态方法中使用。</p>
</li>
<li><p>static 修饰的方法不能被重写。（静态方法在编译期确定，重写方法在运行期）</p>
</li>
</ol>
<p>代码示例：（static）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于static的几点说明：</span></span><br><span class="line"><span class="comment"> * 1.静态方法不能调用非静态属性：</span></span><br><span class="line"><span class="comment"> *        非静态方法可以调用的原因:默认使用this.属性名调用</span></span><br><span class="line"><span class="comment"> * 2.static不能修饰局部变量的原因：</span></span><br><span class="line"><span class="comment"> *        局部变量属于方法，static优先于对象加载</span></span><br><span class="line"><span class="comment"> * 3.静态代码块中可以对自上而下靠后定义的变量赋值，但不能操作变量的原因：</span></span><br><span class="line"><span class="comment"> *        类的加载先会加载类的结构，如变量的声明，方法的声明，之后再进行变量的赋值，赋值由上而下顺序执行(声明和赋值不会同时进行)。</span></span><br><span class="line"><span class="comment"> 初始化：c 的值由&lt;clinit&gt;方法决定，&lt;clinit&gt;类构造方法由类变量和静态代码块中的语句按照顺序合并产生。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        b = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        c = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//可以给c赋值，但不能操作</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;c = &quot;+c);//Illegal forward reference</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多个静态代码块会依次由上而下执行</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//static可以修饰内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private仅仅是权限修饰符，局部变量只可以使用final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// static int b = 2;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//static修饰的方法不能重写，但子类可以有相同的方法（不是重写）</span></span><br><span class="line">    <span class="comment">//静态方法在编译期确定，重写发生在运行期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的static方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//静态方法不能使用非静态变量</span></span><br><span class="line">        <span class="comment">// System.out.println(a);</span></span><br><span class="line">        <span class="comment">// output：</span></span><br><span class="line">        <span class="comment">// b = 2</span></span><br><span class="line">        <span class="comment">// b = 3</span></span><br><span class="line">        <span class="comment">// c = 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTestSub</span> <span class="keyword">extends</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的static方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        methodB(); <span class="comment">// 子类的static方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="main方法说明"><a href="#main方法说明" class="headerlink" title="main方法说明"></a>main方法说明</h3><ol>
<li><p>Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public。</p>
</li>
<li><p>Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的。</p>
</li>
<li><p>main()方法接收String数组，该数组中保存执行Java命令时传递给所运行的类的参数。</p>
</li>
<li><p>由于main() 方法是静态的，必须创建该类的一个实例对象后，才能访问该对象中的非静态成员。</p>
</li>
</ol>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p><strong>在 Java 中声明类、变量和方法时，可使用关键字final来修饰表示 “最终的”。</strong></p>
</li>
<li><p><strong>final 标记的类不能被继承。提高安全性，提高程序的可读性。如 String、System、StringBuffer。</strong></p>
</li>
<li><p><strong>final 标记的方法不能被子类重写。如：Object 类中的 public final native Class&lt;?&gt; getClass();。</strong></p>
</li>
<li><p><strong>final 标记的变量（成员变量）即称为常量。名称建议大写，且只能被赋值一次。对于非静态属性：必须在构造方法执行之前赋值如：直接赋值、构造方法赋值、实例块赋值。</strong></p>
</li>
</ol>
<p> <strong>5.   final 修饰的引用类型，只是地址不可变，而非内容不可变。</strong></p>
<p> <strong>6.   final 标记局部变量或形参时，仅在使用时不能改变，在使用前需要完成初始化。</strong></p>
<ol start="7">
<li><p><strong>由于成员变量具有默认值null或者其他，所以使用 final 修饰后必须赋值。</strong></p>
</li>
<li><p><strong>final 标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。</strong></p>
</li>
<li><p><strong>static final：全局常量，对于 static 静态属性，必须在类加载时赋值，如:直接赋值、静态块中赋值。</strong></p>
</li>
</ol>
</blockquote>
<p>代码示例：（final 属性）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：final修饰成员变量</span></span><br><span class="line"><span class="comment"> * final修饰成员属性：</span></span><br><span class="line"><span class="comment"> *        1.必须赋初值：由于成员变量具有默认值null或者其他，所以使用final修饰后必须赋值。</span></span><br><span class="line"><span class="comment"> *           对于非静态属性：必须在构造方法执行之前赋值</span></span><br><span class="line"><span class="comment"> *              如：直接赋值、构造方法赋值、实例块赋值</span></span><br><span class="line"><span class="comment"> *           对于static静态属性：必须在类加载时赋值（static final全局常量）</span></span><br><span class="line"><span class="comment"> *              如:直接赋值、静态块中赋值</span></span><br><span class="line"><span class="comment"> *        2.不能被改变，且只能被赋值一次</span></span><br><span class="line"><span class="comment"> *     final修饰局部变量：</span></span><br><span class="line"><span class="comment"> *        作为参数：仅在使用时不能改变</span></span><br><span class="line"><span class="comment"> *        定义变量时不能改变，在使用前完成初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalTest</span> &#123;</span><br><span class="line">    <span class="comment">//直接赋值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例块赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        B = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> C;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法赋值，每个构造方法都要赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalTest</span><span class="params">()</span> &#123;</span><br><span class="line">        C = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//final修饰变量只能赋值一次</span></span><br><span class="line">        <span class="comment">//A = 4;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalTest</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        C = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态属性直接赋值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">D</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态块赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        E = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//final修饰局部变量不能修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> f, <span class="keyword">final</span> <span class="type">int</span> g)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        f = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//局部变量不能修改</span></span><br><span class="line">        <span class="comment">// g = 7;</span></span><br><span class="line">        <span class="comment">// g = g++；</span></span><br><span class="line">        System.out.println(<span class="string">&quot;g = &quot;</span> + g);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FinalTest</span> <span class="variable">finalTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalTest</span>();</span><br><span class="line">        System.out.println(finalTest.A); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(finalTest.B); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(finalTest.C); <span class="comment">// 3</span></span><br><span class="line">        System.out.println(FinalTest.D); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(FinalTest.E); <span class="comment">// 5</span></span><br><span class="line">        finalTest.method(<span class="number">10</span>, <span class="number">12</span>); <span class="comment">//g = 12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（final 类、方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> * 测试：<span class="keyword">final</span>修饰类不能被继承，修饰方法不能被重写</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalTest2</span> &#123;</span><br><span class="line"><span class="comment">//public final class FinalTest2 &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FinalTest2 methodA()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FinalTest2 methodA()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final修饰类不能被继承</span></span><br><span class="line"><span class="comment">/*class FinalTestSub extends FinalTest2&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// final修饰方法不能被重写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FinalTestSub</span> <span class="keyword">extends</span> <span class="title class_">FinalTest2</span> &#123;</span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void methodB() &#123;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（对象生成唯一标识）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给一个类的对象生成唯一标识</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalTest3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalTest3</span><span class="params">()</span> &#123;</span><br><span class="line">        ID = ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FinalTest3</span> <span class="variable">finalTest3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalTest3</span>();</span><br><span class="line">        <span class="type">FinalTest3</span> <span class="variable">finalTest4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalTest3</span>();</span><br><span class="line">        System.out.println(finalTest3.ID); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(finalTest4.ID); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ol>
<li><p>代码块(或初始化块)的作用：对Java类属性或成员变量进行初始化</p>
</li>
<li><p>代码块可以分为静态代码块（static{ }）和实例块（{ }）。</p>
</li>
<li><p>一个类中代码块若有修饰符，则只能被 static 修饰，称为静态代码块。</p>
</li>
</ol>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><ol>
<li><p>static 代码块通常用于初始化 static 的属性或其他事情。</p>
</li>
<li><p>static 代码块中不可以对非静态的属性初始化。</p>
</li>
<li><p>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</p>
</li>
<li><p>静态代码块的执行要先于非静态代码块。</p>
</li>
<li><p>静态代码块随着类的加载而加载，且只执行一次。</p>
</li>
</ol>
<h3 id="非静态代码块"><a href="#非静态代码块" class="headerlink" title="非静态代码块"></a>非静态代码块</h3><ol>
<li><p>可以对类的属性、类的声明进行初始化操作。</p>
</li>
<li><p>除了调用非静态的结构外，还可以调用静态的变量或方法。</p>
</li>
<li><p>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</p>
</li>
<li><p>每次创建对象的时候，都会执行一次且先于构造器执行。</p>
</li>
</ol>
<h3 id="成员变量的赋值顺序"><a href="#成员变量的赋值顺序" class="headerlink" title="成员变量的赋值顺序"></a>成员变量的赋值顺序</h3><p><strong>成员变量的默认初始化 –&gt; 显式初始化、代码块初始化 –&gt; 构造器初始化 –&gt; 赋值操作</strong></p>
<p>代码示例：（代码块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//不能对非静态变量进行初始化</span></span><br><span class="line">        <span class="comment">// a = 0;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span>+b);</span><br><span class="line">        b = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span>+b);</span><br><span class="line">        c = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// System.out.println(c);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;实例块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeBlockTest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法执行&quot;</span>);</span><br><span class="line">        a = <span class="number">6</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        c = <span class="number">7</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;c = &quot;</span>+c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeBlockTest</span>();</span><br><span class="line">        <span class="comment">// b = 2</span></span><br><span class="line">        <span class="comment">// b = 3</span></span><br><span class="line">        <span class="comment">// 静态块执行</span></span><br><span class="line">        <span class="comment">// c = 7</span></span><br><span class="line">        <span class="comment">// a = 5</span></span><br><span class="line">        <span class="comment">// 实例块执行</span></span><br><span class="line">        <span class="comment">// 构造方法执行</span></span><br><span class="line">        <span class="comment">// a = 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态概述"><a href="#多态概述" class="headerlink" title="多态概述"></a>多态概述</h3><p>Java 引用变量有两个类型：<strong>编译时类型和运行时类型</strong>。</p>
<p>编译时类型由<strong>声明该变量时</strong>使用的类型决定，运行时类型由<strong>实际赋给该变量的对象</strong>决定。</p>
<p>若编译时类型和运行时类型不一致，就出现了对象的多态性（Polymorphism）。</p>
<p><strong>对象的多态性</strong>：父类或接口的引用指向子类的对象。</p>
<p>动态绑定：运行期间的方法（是方法，不是变量）根据子类类型绑定，编译期间根据父类类型绑定。</p>
<h3 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h3><p><strong>多态的格式</strong>：<strong>父类&#x2F;接口  引用 &#x3D; new  子类&#x2F;实现类 ( );</strong></p>
<p>多态发生的前提：子父类的继承关系、方法重写、父类引用指向子类对象。</p>
<p>示例：Animal a &#x3D; new Cat( );</p>
<h3 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h3><ol>
<li><p>多态的作用：<strong>提高了代码的通用性</strong>，常称作接口重用。</p>
</li>
<li><p><strong>多态的前提</strong>：需要存在继承或者实现关系，有方法的重写。</p>
</li>
<li><p><strong>多态优缺点</strong></p>
<ul>
<li><p>无法直接访问子类特有成员（向下造型解决，需要 instanceof 判断）</p>
</li>
<li><p>可以提高可维护性，提高代码的可扩展性【可扩展性：将父类型作为方法参数，定义接口，子类实现】</p>
</li>
</ul>
</li>
</ol>
<p><strong>4.</strong>   <strong>多态的特点和注意事项</strong></p>
<blockquote>
<p>1） 对于多态，程序在编译时没有对象，父类不能调用子类的成员变量，运行时才有对象。</p>
<p>2） 成员变量：编译时根据父类判断，是否有相应的变量，<strong>不具备多态性，只看引用变量所声明的类。</strong></p>
<p>3） 成员方法：编译时要看引用变量所声明的类中是否有所调用的方法。运行时调用实际 new 的对象所属的类中的重写方法。</p>
<p>4） 静态方法：父类子类中含有静态方法，调用父类方法，变量 value 是用变量的类型的类去调用（编译和运行时相同）</p>
<p>5） 多态是对象之间的规则，和类无关，即和 static 无关。覆盖依赖于类的实例，静态方法和类实例没有关系。而且静态方法在编译时就已经确定，而方法覆盖是在运行时确定的（动态绑定）</p>
</blockquote>
<h3 id="向上造型和向下造型"><a href="#向上造型和向下造型" class="headerlink" title="向上造型和向下造型"></a>向上造型和向下造型</h3><p><strong>向上造型（upcasting）：只能调用父类的方法，执行的则是子类的方法</strong></p>
<blockquote>
<p>Java中，子类的对象可以替代父类的对象使用，一个变量只能有一种确定的数据类型，一个引用类型变量可能指向（引用）多种不同类型的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// Object 类型的变量 o，指向 Person 类型的对象</span></span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> <span class="title class_">Student</span>();  <span class="comment">// Object 类型的变量 o，指向 Student 类型的对象</span></span><br></pre></td></tr></table></figure>

<p>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型（upcasting）。</p>
</blockquote>
<p><strong>向下造型</strong>：<strong>可以调用子类特有的方法</strong></p>
<blockquote>
<p><strong>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法，属性是在编译时确定的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">m.school = <span class="string">&quot;pku&quot;</span>; 	<span class="comment">// 合法，Student类有school成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">e.school = <span class="string">&quot;pku&quot;</span>; 	<span class="comment">//非法，Person类没有school成员变量</span></span><br></pre></td></tr></table></figure>

<p><strong>属性是在编译时确定的，编译时 e 为 Person 类型，没有 school 成员变量，因而编译错误。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上造型</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="comment">// 向下造型</span></span><br><span class="line"><span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat) a;</span><br></pre></td></tr></table></figure>

<p><strong>先向上造型，再向下造型</strong>，如果类型不匹配，可能造成类造型异常，需要通过 instanceOf 先判断是否是原本的对象。</p>
<h3 id="instance-of"><a href="#instance-of" class="headerlink" title="instance of"></a>instance of</h3><p>X instanceof A：检验 X 是否为类 A 的子类会实现类，返回值为 boolean 型</p>
<p>代码示例：（多态）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试多态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphismTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            向上造型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.method(); <span class="comment">// Cat method()...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            对于成员变量不存在多态，输出父类的属性，属性是在编译时确定的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(dog.name); <span class="comment">//Animal</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            静态方法（编译器确定）不是重写（运行期确定）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        animal.staticMethod();<span class="comment">//Animal staticMethod()...</span></span><br><span class="line">        Animal.staticMethod();<span class="comment">//Animal staticMethod()...</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            父类无法的访问子类特有成员(属性/方法)，需要向下转型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// dog.voice();</span></span><br><span class="line">        <span class="comment">// dog.barking();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// java.lang.ClassCastException,使用instanceof判断</span></span><br><span class="line">        <span class="comment">// Dog dog2 = (Dog) cat;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            instanceof 向下造型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (dog <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> (Dog) dog;</span><br><span class="line">            System.out.println(dog2.voice); <span class="comment">// WangWang</span></span><br><span class="line">            dog2.barking(); <span class="comment">// the dog is barking! WangWang</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Animal&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal method()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal staticMethod()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat method()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">voice</span> <span class="operator">=</span> <span class="string">&quot;WangWang&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog method()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barking</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;the dog is barking! &quot;</span> + voice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚拟方法调用"><a href="#虚拟方法调用" class="headerlink" title="虚拟方法调用"></a>虚拟方法调用</h3><p><strong>Virtual Method Invocation</strong></p>
<p>​		虚拟方法调用产生于多态条件，子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为<strong>虚拟方法</strong>，父类根据赋给它的不同子类对象，动态调用属于子类的方法，这样的方法调用在编译期是无法确定的。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类概述"><a href="#内部类概述" class="headerlink" title="内部类概述"></a>内部类概述</h3><p>内部类：当一个类的内部需要一个完整的结构为该类提供服务时，可以使用内部类。</p>
<p>Inner class 的名字不能与包含它的外部类类名相同。</p>
<p>内部类的分类：</p>
<ol>
<li>成员内部类（static成员内部类和非static成员内部类）</li>
<li>部内部类（没有修饰符）、匿名内部类</li>
</ol>
<h3 id="成员内部类（静态-x2F-非静态）"><a href="#成员内部类（静态-x2F-非静态）" class="headerlink" title="成员内部类（静态&#x2F;非静态）"></a>成员内部类（静态&#x2F;非静态）</h3><blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p><strong>一般在外部类中 new 内部类的对象，调用其方法。若不先创建外部类而要使用内部类对象，可以导包或者使用outer.inner x &#x3D; new Outer().new inner() 【非静态内部类】或者 OuterClass.InnerClass3 innerClass3 &#x3D; new OuterClass.InnerClass3()【静态内部类】会调用构造方法。</strong></p>
</li>
<li><p><strong>外部类访问成员内部类的成员，需要 “内部类.成员” 或 “内部类对象.成员” 方式。</strong> </p>
</li>
<li><p><strong>编译以后生成 OuterClass$InnerClass.class 字节码文件（也适用于局部内部类）。</strong></p>
</li>
<li><p><strong>可以在内部类中定义属性、方法、构造器等结构，成员内部类可以直接使用外部类的所有成员，包括私有的数据&#x2F;方法。</strong></p>
</li>
<li><p><strong>成员内部类作为类的成员： 可以声明为 private 或 protected。外部类只能使用 public 修饰或不修饰。</strong></p>
</li>
<li><p><strong>private 修饰内部类，单独为内部类提供服务，可以在外部创建对象，但在其他类不能使用。</strong></p>
</li>
<li><p><strong>可以声明为 abstract 和 final。（被其他内部类继承或不能被实现）</strong></p>
</li>
<li><p><strong>当外部类的静态成员部分需要使用内部类时，可以考虑内部类声明为静态的。</strong></p>
</li>
<li><p><strong>若内部类用 static 修饰，外部类可以通过 Outer.Inner i &#x3D; new Outer.Inner();</strong></p>
</li>
<li><p><strong>内部类可以声明为 static 的，可以定义非 static 成员，但不能访问外部类的非 static 的成员变量。</strong></p>
</li>
<li><p><strong>只有在外部类或 static 的成员内部类中才可声明 static 成员，非 static 的内部类的成员不能声明为 static，也不可以使用 static 块，但可以使用外部类 static 成员，但可以在非 static 内部类中声明 static final 常量。</strong></p>
</li>
<li><p><strong>如果内部类和外部类有同名&#x2F;非同名的变量，可以使用 this.value，OuterClass.this.value 区分变量（需要添加this，如果直接 OuterClass.value 则是把 value 当做静态变量了）。</strong></p>
</li>
</ol>
</blockquote>
<p>代码示例：（成员内部类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试成员内部类相关注意事项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberInnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            外部类使用非静态的内部类,new OuterClass()会调用OuterClass构造方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>().<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            外部类使用静态内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        OuterClass.<span class="type">InnerClass3</span> <span class="variable">innerClass3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>.InnerClass3();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            其他类不能使用私有的内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// new OuterClass().InnerClass2();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OuterClass</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="comment">// this可以省略</span></span><br><span class="line">        <span class="comment">// InnerClass innerClass = this.new InnerClass();</span></span><br><span class="line">        System.out.println(innerClass.l); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(InnerClass.n); <span class="comment">// 常量 n = 3</span></span><br><span class="line">        innerClass.printStaticField(); <span class="comment">// 4</span></span><br><span class="line">        innerClass.printSameField(); <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInnerClassField</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(inner.m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//非static内部类中不能定义static变量/代码块</span></span><br><span class="line">        <span class="comment">/*static int n = 3;</span></span><br><span class="line"><span class="comment">        static &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">//内部类可以定义常量</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//非static内部类可以使用OutClass的static成员</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStaticField</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(OuterClass.p); <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printSameField</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">            System.out.println(l); <span class="comment">// 2</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.l); <span class="comment">// 1</span></span><br><span class="line">            <span class="comment">//需要添加this，如果直接OuterClass.l则是把 l当做静态变量了</span></span><br><span class="line">            System.out.println(OuterClass.<span class="built_in">this</span>.l); <span class="comment">// 0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        内部类可以使用private/protected/public/默认修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InnerClass2</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        内部类可以使用static以及final修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InnerClass3</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        内部类可以使用abstract修饰，可以不被实现/继承</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InnerClassSuper</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodAbstract</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassSub</span> <span class="keyword">extends</span> <span class="title class_">InnerClassSuper</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodAbstract</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类InnerClassSub继承内部类InnerClassSuper&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        静态内部类可以定义非静态成员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p><strong>定义一个类的时候，权限修饰符规则：</strong></p>
<ol>
<li><p><strong>外部类：public &#x2F; (default) &#x2F; abstract &#x2F; final</strong></p>
</li>
<li><p><strong>成员内部类：public &#x2F; protected &#x2F; (default) &#x2F; private &#x2F; static &#x2F; abstract &#x2F; final</strong></p>
</li>
<li><p><strong>局部内部类：什么都不能写</strong></p>
</li>
</ol>
<p>在类中的<strong>方法内部</strong>定义类，但必须先创建内部类才能使用其方法，离开该方法，类及变量就消失了。</p>
<p>​		<strong>局部内部类只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类，但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型，返回的对象只能以多态的形式访问（必须具有相同的方法，无意义）。</strong></p>
<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。</p>
</li>
<li><p>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的 .class 文件，但前面会加上外部类的类名和$符号，以及数字编号。</p>
</li>
<li><p>局部内部类可以使用外部类的成员，包括私有的。</p>
</li>
<li><p>局部内部类和局部变量地位类似，不能使用 public, protected, 缺省，private。</p>
</li>
<li><p>局部内部类不能使用 static 修饰，因此也不能包含静态成员。</p>
</li>
<li><p>局部内部类可以使用外部方法的局部变量，但是必须是有效 final 的。从 Java8 开始，只要局部变量事实不变，那么final可以省略。原因：由局部内部类和局部变量的声明周期不同所致。new 出来的对象在堆内存中，局部变量在栈内存中，方法运行结束后，局部变量消失，但 new 出来的对象会持续存在，直到垃圾回收。</p>
</li>
<li><p>对于同名的变量，由于优先级的原因，无法访问同名的方法中的变量。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（局部内部类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试局部内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalInnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInner</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">                <span class="comment">//如果a未重新定义，则为this.a</span></span><br><span class="line">                System.out.println(a); <span class="comment">// 4</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.a); <span class="comment">// 3</span></span><br><span class="line">                <span class="comment">// 作用域越小优先级越高,访问不到同名的方法内的局部变量 a</span></span><br><span class="line">                System.out.println(b); <span class="comment">// 5</span></span><br><span class="line">                System.out.println(LocalInnerClassTest.<span class="built_in">this</span>.a); <span class="comment">// 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalInner</span> <span class="variable">localInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInner</span>();</span><br><span class="line">        localInner.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LocalInnerSuperClass <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInnerClassSub</span> <span class="keyword">extends</span> <span class="title class_">LocalInnerSuperClass</span> &#123;</span><br><span class="line">            <span class="comment">//局部内部类不能被static修饰，因此不能使用static</span></span><br><span class="line">            <span class="comment">//static int m = 1;</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;LocalInnerClassSub print()...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//局部内部类可以通过方法返回，但返回的类型必须是局部内部类的超类或接口</span></span><br><span class="line">        <span class="comment">//且返回的对象只能以多态的形式访问（必须具有相同的方法，无意义）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalInnerClassSub</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LocalInnerSuperClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;LocalInnerSuperClass print()...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalInnerClassTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInnerClassTest</span>();</span><br><span class="line">        test.methodA();</span><br><span class="line">        <span class="type">LocalInnerSuperClass</span> <span class="variable">localInnerSuperClass</span> <span class="operator">=</span> test.methodB();</span><br><span class="line">        localInnerSuperClass.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p><strong>匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。</strong></p>
</li>
<li><p><strong>一个匿名内部类一定是在 new 的后面，隐含实现一个接口或继承一个类。</strong></p>
</li>
<li><p><strong>匿名内部类必须继承父类或实现接口。</strong></p>
</li>
<li><p><strong>匿名内部类只能有一个对象且只能使用多态形式引用。</strong></p>
</li>
</ol>
</blockquote>
<p>代码示例：（匿名内部类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试匿名内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnonymousSuper</span> <span class="variable">anonymousSuper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousSuper</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;AnonymousSuper AnonymousImpl...&quot;</span>);</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnonymousSuper2</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;AnonymousSuper2 AnonymousImpl...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.methodC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        anonymousSuper.methodB();</span><br><span class="line">        <span class="comment">// AnonymousSuper AnonymousImpl...</span></span><br><span class="line">        <span class="comment">// AnonymousSuper2 AnonymousImpl...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnonymousSuper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AnonymousSuper2</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>Object 类是所有 Java 类的父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            timeout++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><h3 id="重写equals-的原则"><a href="#重写equals-的原则" class="headerlink" title="重写equals()的原则"></a>重写equals()的原则</h3><blockquote>
<ol>
<li><p>对称性：如果x.equals(y) 返回是 “true”，那么 y.equals(x) 也应该返回是 “true”。</p>
</li>
<li><p>自反性：x.equals(x) 必须返回是 “true”。</p>
</li>
<li><p>传递性： 如果 x.equals(y) 返回是 “true”，而且 y.equals(z) 返回是 “true”，那么 z.equals(x) 也应该返回是 “true”。</p>
</li>
<li><p>一致性：如果 x.equals(y) 返回是 “true”，只要 x 和 y 内容一直不变，不管你重复 x.equals(y) 多少次，返回都是 “true”。</p>
</li>
<li><p>任何情况下，x.equals(null)，永远返回是 “false”。</p>
</li>
<li><p>x.equals（和 x 不同类型的对象）永远返回是 “false”。</p>
</li>
<li><p>通常情况下，重写 equals 方法，会比较类中的相应属性是否都相等</p>
</li>
</ol>
</blockquote>
<h3 id="x3D-x3D-与equals"><a href="#x3D-x3D-与equals" class="headerlink" title="&#x3D;&#x3D;与equals"></a>&#x3D;&#x3D;与equals</h3><p>**&#x3D;&#x3D;**：既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址。</p>
<p>用 “&#x3D;&#x3D;” 进行比较时，符号两边的数据类型必须兼容（可自动转换的基本数据类型除外），否则编译出错。</p>
<p>**equals()**：默认比较地址，同&#x3D;&#x3D;，java.lang.Object 的方法，可以重写。</p>
<p>注意：当用 equals( ) 方法进行比较时，对类File、String、Date及包装类等来说，<strong>这些类中重写了 Object 类的 equals() 方法，</strong>是比较类型及内容而不考虑引用的是否是同一个对象。</p>
<p>代码示例：（&#x3D;&#x3D;与equals）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 == 和 equals</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">fl</span> <span class="operator">=</span> <span class="number">65.0f</span>;</span><br><span class="line">        <span class="comment">// 自动类型转换</span></span><br><span class="line">        System.out.println(<span class="string">&quot;65 == 65.0f ：&quot;</span> + (it == fl)); <span class="comment">//true</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch2</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch3</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;65 == &#x27;A&#x27; ：&quot;</span> + (it == ch1));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;12== ch2 ：&quot;</span> + (<span class="number">12</span> == ch2));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;65== ch3 ：&quot;</span> + (it == ch3));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(ch3); <span class="comment">//A</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;str1 == str2 ：&quot;</span> + (str1 == str2));<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str1.equals(str2) ：&quot;</span> + (str1.equals(str2)));<span class="comment">//true</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;hello&quot; == new java.util.Date()); //编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 与其它类型数据进行拼接时，会自动调用对象的 toString() 方法。对于基本数据类型会调用包装类的toString()方法。</p>
<p>代码示例：（toString）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试System.out.println的细节问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line">        System.out.println(arr);  <span class="comment">// abc</span></span><br><span class="line">        System.out.println(arr.toString());  <span class="comment">// [C@2401f4c3</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        System.out.println(arr1);  <span class="comment">// [I@2401f4c3</span></span><br><span class="line">        <span class="type">double</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">double</span>[] &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span> &#125;;</span><br><span class="line">        System.out.println(arr2);  <span class="comment">// [D@7637f22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载方法 System.out.println( )</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印字符数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span> x[])</span> &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">           print(x);</span><br><span class="line">           newLine();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印字符数组：对于char数组，会将每一个字符遍历打印在控制台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span> buf[])</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">               ensureOpen();</span><br><span class="line">               textOut.write(buf);</span><br><span class="line">               textOut.flushBuffer();</span><br><span class="line">               charOut.flushBuffer();</span><br><span class="line">               <span class="keyword">if</span> (autoFlush) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buf.length; i++)</span><br><span class="line">                       <span class="keyword">if</span> (buf[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                           out.flush();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">           Thread.currentThread().interrupt();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">           trouble = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印对象：对于其他类型，会刷出到输出流里面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(x);</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">           print(s);</span><br><span class="line">           newLine();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">               ensureOpen();</span><br><span class="line">               textOut.write(s);</span><br><span class="line">               textOut.flushBuffer();</span><br><span class="line">               charOut.flushBuffer();</span><br><span class="line">               <span class="keyword">if</span> (autoFlush &amp;&amp; (s.indexOf(<span class="string">&#x27;\n&#x27;</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                   out.flush();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">           Thread.currentThread().interrupt();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">           trouble = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h1><h2 id="JDK主要包介绍"><a href="#JDK主要包介绍" class="headerlink" title="JDK主要包介绍"></a>JDK主要包介绍</h2><blockquote>
<ol>
<li>java.lang	包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能，不需要导包。</li>
<li>java.net		含执行与网络相关的操作的类和接口。</li>
<li>java.io		包含能提供多种输入&#x2F;输出功能的类。</li>
<li>java.util	包含一些实用工具类，如系统特性、接口的集合框架类、使用与日期日历相关的函数。</li>
<li>java.text	包含了一些java格式化相关的类</li>
<li>java.sql 	包含了java进行JDBC数据库编程的相关类&#x2F;接口</li>
<li>java.awt 	包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。</li>
</ol>
</blockquote>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​		针对八种基本数据类型定义相应的引用类型—包装类（封装类）有了类的特点，就可以调用类中的方法，Java才是真正的面向对象。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
</tbody></table>
<p>注意：除了 Boolean  和  Character  没有继承 Number 类，其他六种基本数据类型都继承了 Number 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;Character&gt; &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Boolean</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,                           Comparable&lt;Boolean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Integer&gt; &#123;</span><br></pre></td></tr></table></figure>

<h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h3><ul>
<li><p>装箱：将基本数据类型包装成包装类的实例。</p>
<p><strong>方式：通过包装类构造方法实现，方法参数可以为字符串。</strong></p>
</li>
<li><p>拆箱：将包装类对象中转为基本数据类型。</p>
<p><strong>方式：调用包装类的 XXX .xxxValue() 方法。</strong></p>
</li>
</ul>
<p>代码示例：（基本数据类型与包装类拆装箱）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    装箱</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="comment">//Integer j = new Integer(&quot;abc&quot;); // NumberFormatException</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    拆箱</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> i2.intValue();</span><br></pre></td></tr></table></figure>

<p>代码示例：（字符串转换成基本数据类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符串转换成基本数据类型</span></span><br><span class="line"><span class="comment">    方式：</span></span><br><span class="line"><span class="comment">    构造方法</span></span><br><span class="line"><span class="comment">    XXX.parseXXX()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;12&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;12&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    基本数据类型转换成字符串</span></span><br><span class="line"><span class="comment">    方式：</span></span><br><span class="line"><span class="comment">     String.valueOf()</span></span><br><span class="line"><span class="comment">     + 拼接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(<span class="number">12.0</span>);</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="number">12.0</span> + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="包装类的缓存问题"><a href="#包装类的缓存问题" class="headerlink" title="包装类的缓存问题"></a>包装类的缓存问题</h3><p>代码示例：（包装类的缓存）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Integer、new Integer() 和 int 的比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerWrapperTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 两个new Integer() 比较：false ，new 产生的是两个对象，内存地址不同</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">        System.out.println(i == j); <span class="comment">// false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Integer变量 和 new Integer() 变量比较 ，为 false。</span></span><br><span class="line">        <span class="comment">//因为 Integer变量 指向的是 java 常量池 中的对象，</span></span><br><span class="line">        <span class="comment">// 而 new Integer() 的变量指向堆中新建的对象，两者在内存中的地址不同。</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两个Integer 变量比较，如果两个变量的值在区间-128到127 之间，</span></span><br><span class="line">        <span class="comment">// 则比较结果为true，如果两个变量的值不在此区间，则比较结果为 false 。</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Integer内部维护了缓存池</span></span><br><span class="line"><span class="comment">         * private static class IntegerCache &#123;</span></span><br><span class="line"><span class="comment">         *         static final int low = -128;</span></span><br><span class="line"><span class="comment">         *         static final int high;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(m == n); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.println(x == y); <span class="comment">// false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//包装类Integer和基本数据类型int比较时，会自动拆包装为int ，然后进行比较</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(c == d); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项</p>
<ol>
<li><p>String类： Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</p>
</li>
<li><p>String 是一个 final 类，代表不可变的字符序列。【不可变性带来效率问题】</p>
</li>
<li><p>String 对象的字符内容是存储在一个字符数组 value[ ]中的，因此可以 string.toCharArray( ) 方法对字串进行操作。</p>
</li>
<li><p>String字面量存放在方法区的字符串常量池中。</p>
</li>
</ol>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/28/Linux/" rel="prev" title="Linux">
      <i class="fa fa-chevron-left"></i> Linux
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/28/JavaBasic/" rel="next" title="JavaBasic">
      JavaBasic <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">Java 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">Java发展历程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">Java语言特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%A4%E7%A7%8D%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">Java两种核心机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="nav-number">1.4.</span> <span class="nav-text">字符编码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">Java 基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.1.</span> <span class="nav-text">标识符与关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.</span> <span class="nav-text">数据类型及强制类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.2.1.</span> <span class="nav-text">变量的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">2.2.2.</span> <span class="nav-text">数据类型说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.3.</span> <span class="nav-text">基本数据类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">隐式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">强制转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.3.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.3.1.</span> <span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.2.</span> <span class="nav-text">赋值运算符的一个问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.3.3.</span> <span class="nav-text">逻辑运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">Java 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">类与对象概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A6%82%E8%BF%B0"><span class="nav-number">3.2.</span> <span class="nav-text">内存分配概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%B2%A1%E6%9C%89%E5%88%9D%E5%A7%8B%E5%80%BC%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.3.</span> <span class="nav-text">局部变量没有初始值的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">变量与方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">3.4.1.</span> <span class="nav-text">成员变量与局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.2.</span> <span class="nav-text">成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">3.4.3.</span> <span class="nav-text">方法的重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.4.</span> <span class="nav-text">方法参数的值传递机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.5.</span> <span class="nav-text">可变参数的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.4.6.</span> <span class="nav-text">构造方法及注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-this"><span class="nav-number">3.4.7.</span> <span class="nav-text">关键字 this</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%80%A7%E4%B8%8E%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">3.5.</span> <span class="nav-text">封装性与权限修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%80%A7%E6%A6%82%E8%BF%B0"><span class="nav-number">3.5.1.</span> <span class="nav-text">封装性概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#package"><span class="nav-number">3.5.2.</span> <span class="nav-text">package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import"><span class="nav-number">3.5.3.</span> <span class="nav-text">import</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">3.5.4.</span> <span class="nav-text">四种访问权限修饰符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">3.6.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%A6%82%E8%BF%B0"><span class="nav-number">3.6.1.</span> <span class="nav-text">继承概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">3.6.2.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-number">3.6.3.</span> <span class="nav-text">方法的重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%88%E7%95%A5%EF%BC%89"><span class="nav-number">3.6.4.</span> <span class="nav-text">重写与重载的比较（略）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.5.</span> <span class="nav-text">抽象类与抽象方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.6.6.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E7%89%88%E6%9C%AC%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%94%B9%E5%8A%A8"><span class="nav-number">3.6.7.</span> <span class="nav-text">JDK版本中接口的改动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK7%EF%BC%9A%E5%B8%B8%E9%87%8F%E3%80%81%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.7.1.</span> <span class="nav-text">JDK7：常量、抽象方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK8%EF%BC%9A%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.7.2.</span> <span class="nav-text">JDK8：默认方法、静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK9%EF%BC%9A%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.7.3.</span> <span class="nav-text">JDK9：私有方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">3.6.8.</span> <span class="nav-text">接口与抽象类的对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-static-%E5%92%8C-final"><span class="nav-number">3.7.</span> <span class="nav-text">关键字 static 和 final</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">3.7.1.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.7.2.</span> <span class="nav-text">使用范围及注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="nav-number">3.7.3.</span> <span class="nav-text">类变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.4.</span> <span class="nav-text">类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main%E6%96%B9%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="nav-number">3.7.5.</span> <span class="nav-text">main方法说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-number">3.7.6.</span> <span class="nav-text">final</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.8.</span> <span class="nav-text">代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.8.1.</span> <span class="nav-text">静态代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.8.2.</span> <span class="nav-text">非静态代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.8.3.</span> <span class="nav-text">成员变量的赋值顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.8.4.</span> <span class="nav-text">同步代码块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">3.9.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%A6%82%E8%BF%B0"><span class="nav-number">3.9.1.</span> <span class="nav-text">多态概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.9.2.</span> <span class="nav-text">多态的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="nav-number">3.9.3.</span> <span class="nav-text">几点说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E4%B8%8A%E9%80%A0%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E9%80%A0%E5%9E%8B"><span class="nav-number">3.9.4.</span> <span class="nav-text">向上造型和向下造型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instance-of"><span class="nav-number">3.9.5.</span> <span class="nav-text">instance of</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="nav-number">3.9.6.</span> <span class="nav-text">虚拟方法调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">3.10.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="nav-number">3.10.1.</span> <span class="nav-text">内部类概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E9%9D%99%E6%80%81-x2F-%E9%9D%9E%E9%9D%99%E6%80%81%EF%BC%89"><span class="nav-number">3.10.2.</span> <span class="nav-text">成员内部类（静态&#x2F;非静态）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">3.10.3.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">3.10.4.</span> <span class="nav-text">匿名内部类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">Object类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#equals"><span class="nav-number">4.1.</span> <span class="nav-text">equals()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99equals-%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">4.1.1.</span> <span class="nav-text">重写equals()的原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x3D-x3D-%E4%B8%8Eequals"><span class="nav-number">4.1.2.</span> <span class="nav-text">&#x3D;&#x3D;与equals</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toString-NaN"><span class="nav-number">4.2.</span> <span class="nav-text">toString()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">Java常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK%E4%B8%BB%E8%A6%81%E5%8C%85%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.1.</span> <span class="nav-text">JDK主要包介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">5.2.</span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">5.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="nav-number">5.2.2.</span> <span class="nav-text">装箱和拆箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">5.2.3.</span> <span class="nav-text">包装类的缓存问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String"><span class="nav-number">5.3.</span> <span class="nav-text">String</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
