<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JavaSE  Java 概述Java发展历程 Java发展的重大事件  1990年，在 Sun 计算机公司中，由 atrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 Oak，后期命名为 Java。 1995年， Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。 19">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE">
<meta property="og:url" content="http://example.com/2023/02/28/JavaSE/index.html">
<meta property="og:site_name" content="MineTing">
<meta property="og:description" content="JavaSE  Java 概述Java发展历程 Java发展的重大事件  1990年，在 Sun 计算机公司中，由 atrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 Oak，后期命名为 Java。 1995年， Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。 19">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/02/28/JavaSE/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0%E7%AE%80%E5%8D%95%E7%89%88.png">
<meta property="og:image" content="http://example.com/2023/02/28/JavaSE/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="og:image" content="http://example.com/2023/02/28/JavaSE/BIO%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://example.com/2023/02/28/JavaSE/NIO%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://example.com/2023/02/28/JavaSE/NIO%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%A4%BA%E6%84%8F%E5%9B%BE%E7%AE%80%E5%8D%95%E7%89%88.png">
<meta property="og:image" content="http://example.com/2023/02/28/JavaSE/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png">
<meta property="article:published_time" content="2023-02-27T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-08T06:25:42.945Z">
<meta property="article:author" content="Fei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/02/28/JavaSE/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0%E7%AE%80%E5%8D%95%E7%89%88.png">

<link rel="canonical" href="http://example.com/2023/02/28/JavaSE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>JavaSE | MineTing</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MineTing</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/28/JavaSE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MineTing">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaSE
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2023-02-28T00:00:00+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-08 14:25:42" itemprop="dateModified" datetime="2023-03-08T14:25:42+08:00">2023-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <div align="center"><font size="70"><b>JavaSE</b></font></div>

<h1 id="Java-概述"><a href="#Java-概述" class="headerlink" title="Java 概述"></a>Java 概述</h1><h2 id="Java发展历程"><a href="#Java发展历程" class="headerlink" title="Java发展历程"></a>Java发展历程</h2><blockquote>
<p><strong>Java发展的重大事件</strong></p>
<ul>
<li>1990年，在 Sun 计算机公司中，由 atrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 Oak，后期命名为 Java。</li>
<li>1995年， Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。</li>
<li>1996年1月23日 Sun Microsystems 发布了 JDK 1.0。</li>
<li>1998年，JDK 1.2版本发布。同时，Sun 发布了 JSP&#x2F;Servlet、EJB 规范，以及将 Java 分成了 J2EE、J2SE 和 J2ME。这表明了 Java 开始向企业、桌面应用和移动设备应用3大领域挺进。</li>
<li>2000年，JDK 1.3 发布，Java HotSpot Virtual Machine正式发布，成为 Java 的默认虛拟机。</li>
<li>2002年，JDK 1.4 发布，古老的 Classic 虚拟机退出历史舞台。</li>
<li>2003年年底，Java 平台的 Scala 正式发布，同年 Groovy 也加入了 Java 阵营。</li>
<li>2004年，JDK 1.5 发布。同时 JDK 1.5 改名为 JavaSE 5.0。</li>
<li>2006年，JDK 6 发布。同年，Java 开源并建立了 OpenJDK。顺理成章，Hotspot 虚拟机也成为了 OpenJDK 中的默认虛拟机。</li>
<li>2007年，Java 平台迎来了新伙伴 Clojure。</li>
<li>2008年，Oracle 收购了BEA， 得到了 JRockit 虚拟机。</li>
<li>2009年，Twitter 宣布把后台大部分程序从 Ruby 迁移到 scala，这是 Java 平台的又一次大规模应用。</li>
<li>2010年，Oracle 收购了 Sun，获得 Java 商标和最具价值的 HotSpot 虚拟机。此时，Oracle 拥有市场占用率最高的两款虚拟机 HotSpot 和 JRockit，并计划在未来对它们进行整合： HotRockit. JCP组织管理： Java 语言</li>
<li>2011年，JDK7 发布。在JDK 1. 7u4中，正式启用了新的垃圾回收器G1。</li>
<li>2017年，JDK9 发布。将G1设置为默认GC，替代CMS，同年，IBM的J9开源，形成了现在的Open J9社区。</li>
<li>2018年，Android 的 Java 侵权案判决，Google 赔偿 Oracle 计88亿美元，同年，Oracle 宣告 JavaEE成为历史名词，JDBC、 JMS、Servlet 赠予 Eclipse 基金会，同年，JDK11 发布，LTS 版本的 JDK，发布革命性的 ZGC，调整 JDK 授权许可。</li>
<li>2019年，JDK12 发布，加入 RedHat 领导开发的 Shenandoah GC。</li>
</ul>
</blockquote>
<h2 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h2><blockquote>
<ul>
<li><p><strong>一次编译，到处运行（基于栈的指令设计）</strong></p>
</li>
<li><p><strong>自动内存管理</strong></p>
</li>
<li><p><strong>自动垃圾回收机制</strong></p>
</li>
</ul>
</blockquote>
<h2 id="Java两种核心机制"><a href="#Java两种核心机制" class="headerlink" title="Java两种核心机制"></a>Java两种核心机制</h2><blockquote>
<ul>
<li><strong>Java虚拟机 (Java Virtal Machine)</strong></li>
<li><strong>垃圾收集机制 (Garbage Collection)</strong></li>
</ul>
</blockquote>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><h1 id="Java-基本语法"><a href="#Java-基本语法" class="headerlink" title="Java 基本语法"></a>Java 基本语法</h1><h2 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h2><h2 id="数据类型及强制类型转换"><a href="#数据类型及强制类型转换" class="headerlink" title="数据类型及强制类型转换"></a>数据类型及强制类型转换</h2><h3 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h3><p><strong>1. 变量分类：按数据类型分类</strong> </p>
<ul>
<li><p>基本数据类型</p>
<ul>
<li>数值型：byte	short	long	double	float	int</li>
<li>字符型：char</li>
<li>布尔型：boolean</li>
</ul>
</li>
<li><p>引用数据类型</p>
<ul>
<li>类</li>
<li>接口</li>
<li>数组</li>
</ul>
</li>
</ul>
<p><strong>2. 变量分类：按声明类型分类</strong></p>
<ul>
<li><p>成员变量</p>
<ul>
<li>实例变量</li>
<li>类变量</li>
</ul>
</li>
<li><p>局部变量</p>
<ul>
<li>形参</li>
<li>方法局部变量</li>
<li>代码块局部变量</li>
</ul>
</li>
</ul>
<h3 id="数据类型说明"><a href="#数据类型说明" class="headerlink" title="数据类型说明"></a>数据类型说明</h3><p>字节分配大小：</p>
<table>
<thead>
<tr>
<th>byte</th>
<th>short</th>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>char</th>
<th>boolean</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>4</td>
<td>8</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>整数默认为 int 类型，小数默认 double 类型；</strong>因此，定义 long 类型时，要加 l 或 L ，定义 float 类型时要加 f 或 F。</p>
<p><strong>char类型</strong></p>
<blockquote>
<p><strong>注意事项</strong></p>
<ol>
<li><p>Java中的所有字符都使用 Unicode 字符集编码，用以存储一个字母，汉字等。</p>
</li>
<li><p>字符常量是用单引号 (‘ ‘) 括起来的单个字符。例如：char c1 &#x3D; ‘a’; char c2&#x3D; ‘中’; char c3 &#x3D; ‘9’;</p>
</li>
<li><p>Java中允许使用转义字符 ‘\‘ 来将其后的字符转变为特殊字符型常量。例如：char c3 &#x3D; ‘\n’;</p>
</li>
<li><p>直接使用 Unicode 值来表示字符型常量：‘\uXXXX’。其中，XXXX代表一个十六进制整数。如：\u000a 表示 \n。char 类型的范围为：\u0000到\uffff。</p>
</li>
<li><p>char 类型是可以进行运算的，因为它都对应有 Unicode 码。</p>
</li>
</ol>
</blockquote>
<p><strong>boolean类型</strong></p>
<blockquote>
<p><strong>注意事项</strong></p>
<ol>
<li><p>boolean 类型数据只允许取值 true 和 false，无null。</p>
</li>
<li><p>不可以使用 0 或非 0 的整数替代 false 和 true（boolean 类型不能与其它数据类型运算&#x2F;转换）。</p>
</li>
<li><p>Java 虚拟机中没有任何供 boolean 值专用的字节码指令，Java语言表达所操作的。</p>
</li>
<li><p>boolean 值，在编译之后都使用 java 虚拟机中的 int 数据类型来代替：true 用 1 表示，false 用 0 表示。——《java虚拟机规范 8版》</p>
</li>
</ol>
</blockquote>
<p><strong>数组元素（引用）的默认初始化值：</strong></p>
<table>
<thead>
<tr>
<th>数组元素类型</th>
<th>元素默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0F</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
</tbody></table>
<h3 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><blockquote>
<p>注意事项</p>
<ol>
<li><p>long 取值范围是小于 float 的</p>
</li>
<li><p>范围小的类型自动转换为范围大的数据类型</p>
</li>
<li><p>byte, short, char 之间不会相互转换，它们在计算时首先会转换为 int 类型</p>
</li>
<li><p>boolean 类型不能与其它数据类型运算</p>
</li>
<li><p>基本数据类型和 String 做加法运算时，会自动转换为 String 类型</p>
</li>
</ol>
</blockquote>
<h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><blockquote>
<p>注意事项</p>
<ol>
<li><p>将大范围数据类型转换为小范围的数据类型，但可能造成数据溢出，精度降低。</p>
</li>
<li><p>基本数据类型可以通过包装类转换为引用类型。</p>
</li>
</ol>
</blockquote>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><strong>+	-	*	&#x2F; 	%	++ 	–</strong> </p>
<h3 id="赋值运算符的一个问题"><a href="#赋值运算符的一个问题" class="headerlink" title="赋值运算符的一个问题"></a>赋值运算符的一个问题</h3><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><h1 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h1><h2 id="类与对象概述"><a href="#类与对象概述" class="headerlink" title="类与对象概述"></a>类与对象概述</h2><p><strong>面向过程（POP）与 面向对象（OOP）</strong></p>
<blockquote>
<p>二者都是一种思想，面向对象是相对于面向过程而言的。</p>
<p>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</p>
<p>面向对象：将功能封装进对象，强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。</p>
</blockquote>
<p><strong>对象的创建和使用</strong></p>
<p>创建对象语法： 类名 对象名称 &#x3D; new 类名( );</p>
<p>使用 “对象名.对象成员” 的方式访问对象成员（包括属性和方法）</p>
<p><strong>匿名对象</strong>：方法只调用一次 new Object( ).method( )</p>
<h2 id="内存分配概述"><a href="#内存分配概述" class="headerlink" title="内存分配概述"></a>内存分配概述</h2><p><strong>堆（Heap）</strong></p>
<p>​		此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</p>
<p><strong>栈（Stack）</strong></p>
<p>​		通常所说的栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char 、 short 、 int 、 float 、 long 、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。</p>
<p><strong>方法区（Method Area）</strong></p>
<p>​		用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p><img src="/2023/02/28/JavaSE/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0%E7%AE%80%E5%8D%95%E7%89%88.png" alt="内存结构概述简单版"></p>
<h2 id="局部变量没有初始值的原因"><a href="#局部变量没有初始值的原因" class="headerlink" title="局部变量没有初始值的原因"></a>局部变量没有初始值的原因</h2><blockquote>
<p>为什么类的成员变量有默认初始值而方法内的局部变量却没有初始值？</p>
<p>JVM 将字节码加载到内存中，涉及加载、验证、准备、解析、初始化等过程，对于静态成员变量，会有两次赋值，分别在准备阶段（赋值为默认值）和初始化阶段（赋值为具体的阶段）。对于非静态成员变量，只会在初始化阶段进行赋值。</p>
<p>局部变量属于方法，方法在被调用时，存储在栈帧的局部变量期间未经过初始化，因此需要先赋值才能使用。</p>
<p>对于基本数据类型而言，默认初始化值各有不同。</p>
<p>对于引用数据类型而言，默认初始化值为 null（注意与0不同）</p>
</blockquote>
<h2 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h2><h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><p>成员变量与局部变量的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>声明位置</td>
<td>直接在类中，方法体外</td>
<td>方法形参或内部、代码块、构造器等</td>
</tr>
<tr>
<td>修饰符</td>
<td>private、public、static、final</td>
<td>不能使用权限修饰符，但可以使用 final</td>
</tr>
<tr>
<td>初始化值</td>
<td>由默认初始化值</td>
<td>没有默认初始化值，必须显式赋值后，方可使用</td>
</tr>
<tr>
<td>内存加载位置</td>
<td>堆位置或静态域内</td>
<td>栈空间</td>
</tr>
</tbody></table>
<p>对象属性默认初始化值：基本类型：0 或 false 或、\u0000(char)，引用类型：null。</p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p><strong>方法的声明格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 形参<span class="number">1</span>, 参数类型 形参<span class="number">2</span>, ….）｛</span><br><span class="line"></span><br><span class="line">   方法体程序代码</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> 返回值;</span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p><strong>方法的返回值为void时，可以使用return；但没意义</strong></p>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><blockquote>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>在同一个类中，允许存在一个以上的同名方法，要求它们的参数个数或者参数类型或参数顺序不同即可。</li>
<li>与参数名称、返回值类型无关，只与参数列表，且<strong>参数列表</strong>必须不同。(参数个数、参数类型、参数顺序)。</li>
<li>调用时JVM进行区分，根据方法参数列表的不同来区别。</li>
</ul>
</blockquote>
<p>代码示例：（重载）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法的重载：</span></span><br><span class="line"><span class="comment"> * 与参数名称、返回值类型无关，只与参数列表，且参数列表必须不同。(参数个数、参数类型、参数顺序)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverLoadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&quot;原始方法&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printContent</span><span class="params">(String cent, <span class="type">int</span> point, <span class="type">boolean</span> append)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Original Method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重载：与参数名称无关</span></span><br><span class="line">    <span class="comment">/*public void printContent(String arg1, int arg2, boolean arg3) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Not OverLoad!&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重载：与返回值无关</span></span><br><span class="line">    <span class="comment">/*public int printContent(String cent, int point, boolean append) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Not OverLoad!&quot;);</span></span><br><span class="line"><span class="comment">        return 0;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载：与参数个数相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printContent</span><span class="params">(String cent, <span class="type">int</span> point)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverLoad!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载：与参数顺序相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printContent</span><span class="params">(<span class="type">int</span> point, String cent, <span class="type">boolean</span> append)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverLoad!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载：与参数类型相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printContent</span><span class="params">(String cent, String point, <span class="type">int</span> append)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverLoad!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h3><p><strong>Java 里方法的参数传递方式只有一种：值传递。</strong> </p>
<p>即将实际参数值的副本（复制）传入方法内，而参数本身不受影响。</p>
<p>形参是基本数据类型：将实参基本数据类型变量的 “数据值” 传递给形参。</p>
<p>形参是引用数据类型：将实参引用数据类型变量的 “地址值” 传递给形参。</p>
<p>代码示例：（值传递）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试值传递：</span></span><br><span class="line"><span class="comment"> * Java里方法的参数传递方式只有一种：值传递。</span></span><br><span class="line"><span class="comment"> * 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参。</span></span><br><span class="line"><span class="comment"> * 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParametersPassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changePrimaryType</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        num = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeReferenceType</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        changePrimaryType(num);</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + num); <span class="comment">// num = 0</span></span><br><span class="line">        changeReferenceType(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr)); <span class="comment">// arr = [-1, 2, 3]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可变参数的方法"><a href="#可变参数的方法" class="headerlink" title="可变参数的方法"></a>可变参数的方法</h3><blockquote>
<p>JavaSE 5.0 中提供了Varargs（variable number of arguments）机制，允许直接定义能和多个实参相匹配的形参。从而传递个数可变的实参。</p>
<ul>
<li><p>JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</p>
<p><strong>public static void method(int a ,String[] values);</strong></p>
</li>
<li><p>JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量</p>
<p><strong>public static void method(int a , String…args);</strong></p>
</li>
</ul>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>声明格式：方法名(参数的类型名 **…**参数名)。</p>
</li>
<li><p>方法的参数部分有可变形参，需要放在形参声明的最后。</p>
</li>
<li><p>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个。</p>
</li>
<li><p>可变个数形参的方法与同名的方法之间，彼此构成重载。</p>
</li>
<li><p>可变参数方法的使用与方法参数部分使用数组是一致的。</p>
</li>
<li><p>在一个方法的形参位置，最多只能声明一个可变个数形参。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（可变参数）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可变参数测试</span></span><br><span class="line"><span class="comment"> * 注意事项：</span></span><br><span class="line"><span class="comment"> * 1.声明格式：方法名(参数的类型名 ...参数名)。</span></span><br><span class="line"><span class="comment"> * 2.方法的参数部分有可变形参，需要放在形参声明的最后。</span></span><br><span class="line"><span class="comment"> * 3.可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个。</span></span><br><span class="line"><span class="comment"> * 4.可变个数形参的方法与同名的方法之间，彼此构成重载。</span></span><br><span class="line"><span class="comment"> * 5.可变参数方法的使用与方法参数部分使用数组是一致的。</span></span><br><span class="line"><span class="comment"> * 6.在一个方法的形参位置，最多只能声明一个可变个数形参。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarArgsTest</span> &#123;</span><br><span class="line">    <span class="comment">// 可变参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">(String title, String content, String... other)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;title: &quot;</span> + title + <span class="string">&quot;, content: &quot;</span> + content + <span class="string">&quot;, other: &quot;</span> + Arrays.asList(other));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可变个数形参的方法与同名的方法之间，彼此构成重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法及注意事项"><a href="#构造方法及注意事项" class="headerlink" title="构造方法及注意事项"></a>构造方法及注意事项</h3><p>构造方法的作用：创建对象并初始化</p>
<p><strong>语法格式：</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 类名 (参数列表) &#123;</span><br><span class="line">    初始化语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li>构造方法与类同名，一个类可以创建多个重载的构造器（使对象的创建更加灵活）</li>
<li>父类的构造器不可被子类继承（语法规范）</li>
<li>默认构造器的权限修饰符与所属类的权限修饰符一致（可以使用其他修饰符 private，默认的，protected，public）</li>
<li>构造方法没有返回值，不能被 static、final、synchronized、abstract、native 修饰，不能有 return 语句返回值，否则就是普通方法</li>
<li><strong>每个类都至少有一个构造器，一旦显式定义了构造器，则系统不再提供默认构造器</strong></li>
<li><strong>构造方法可以抛出异常</strong></li>
</ol>
</blockquote>
<h3 id="关键字-this"><a href="#关键字-this" class="headerlink" title="关键字 this"></a>关键字 this</h3><p><strong>this的含义</strong>：当前对象的引用，可以调用当前类的属性、方法和构造器。</p>
<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>使用 this 调用本类的构造器，通过 this(形参列表) 调用本类中重载的其他构造器，但不能调用自身</p>
</li>
<li><p>在类的构造器中，最多只能声明一个 this(形参列表)。且this(形参列表) 必须放在构造器的首行</p>
</li>
<li><p>this 可以调用当前对象的其他属性&#x2F;方法。也可以用 this 来区分属性和局部变量。如 this.name &#x3D; name;</p>
</li>
</ol>
</blockquote>
<p>代码示例：（this）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.构造方法与类同名，一个类可以创建多个重载的构造器（使对象的创建更加灵活）。</span></span><br><span class="line"><span class="comment"> * 2.父类的构造器不可被子类继承（语法规范）</span></span><br><span class="line"><span class="comment"> * 3.默认构造器的修饰符与所属类的修饰符一致（可以使用其他权限修饰符private，默认的，protected，public）</span></span><br><span class="line"><span class="comment"> * 4.构造方法没有返回值，不能被static、final、synchronized、abstract、native等关键字修饰，不能有return语句返回值。</span></span><br><span class="line"><span class="comment"> * 5.每个类都至少有一个构造器，一旦显式定义了构造器，则系统不再提供默认构造器。</span></span><br><span class="line"><span class="comment"> * 6.在类的构造器中，最多只能声明一个this(形参列表)。且this(形参列表) 必须放在构造器的首行。</span></span><br><span class="line"><span class="comment"> * 7.this可以调用当前对象的其他属性/方法。也可以用this来区分属性和局部变量。如：this.name = name;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorThisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ConstructorThisTest</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//    static ConstructorThisTest()&#123;</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;non-block&quot;</span>);</span><br><span class="line"><span class="comment">//        return null;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个类可以创建多个重载的构造器（使对象的创建更加灵活）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorThisTest</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封装性与权限修饰符"><a href="#封装性与权限修饰符" class="headerlink" title="封装性与权限修饰符"></a>封装性与权限修饰符</h2><h3 id="封装性概述"><a href="#封装性概述" class="headerlink" title="封装性概述"></a>封装性概述</h3><blockquote>
<p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉。</p>
<p>低耦合：仅对外暴露少量的方法用于使用。</p>
<p><strong>封装的思想</strong>：隐藏对象内部的复杂性，只对外公开简单的接口，便于外界调用，从而提高系统的可扩展性、可维护性。</p>
<p>Java 中通过将数据声明为私有的（private），再提供公共的 public 方法： getXxx()  和 setXxx() 实现对该属性的操作，以实现下述目的：</p>
<ol>
<li><p>隐藏一个类中不需要对外提供的实现细节。</p>
</li>
<li><p>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑。</p>
</li>
<li><p><strong>限制对属性的不合理操作。</strong></p>
</li>
<li><p>便于修改，增强代码的可维护性。</p>
</li>
</ol>
<p>即：<strong>使用者对类内部定义的属性（对象的成员变量）的直接操作会导致数据的错误、混乱或安全性问题。</strong></p>
</blockquote>
<h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>package 语句作为 Java 源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。它的格式为：package 域名反写..子包名 ;</p>
<p>包的作用：</p>
<ol>
<li><p>包帮助管理大型软件系统：将功能相近的类划分到同一个包中。</p>
</li>
<li><p>包可以包含类和子包，划分项目层次，便于管理。</p>
</li>
<li><p>解决类命名冲突的问题。</p>
</li>
<li><p>控制访问权限。</p>
</li>
</ol>
<blockquote>
<p><strong>注意事项：</strong></p>
<p>使用 javac 编译单个 java 文件没有问题，但对于带有 package 的 Java 源文件进行编译时，可以使用 **javac -d文件目录 Test.java **进行编译，之后切换至 class 文件所在目录通过 java 命令运行程序。</p>
</blockquote>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>为使用定义在不同包中的 Java 类，需用 import 语句来引入指定包层次下所需要的类或全部类(.*)。</p>
<p>语法格式：import 包名. 类名;</p>
<blockquote>
<p>注意事项：</p>
<ol>
<li><p>在源文件中使用 import 显式的导入指定包下的类或接口。</p>
</li>
<li><p>声明在包的声明和类的声明之间。</p>
</li>
<li><p>如果需要导入多个类或接口，那么就并列显式多个 import 语句即可。也可以使用 java.util.* 的方式，一次性导入 util包下所有的类或接口。</p>
</li>
<li><p>如果导入的类或接口是 java.lang 包下的，或者是当前包下的，则可以省略此 import 语句。</p>
</li>
<li><p><strong>如果在代码中使用不同包下的同名的类。</strong>那么就需要使用类的全类名的方式指明调用的是哪个类。</p>
</li>
<li><p>如果已经导入 java.a 包下的类。那么如果需要使用 a 包的子包下的类的话，仍然需要导入。</p>
</li>
<li><p><strong>import static 组合的使用：</strong>调用指定类或接口下的静态的属性或方法。</p>
</li>
</ol>
</blockquote>
<h3 id="四种访问权限修饰符"><a href="#四种访问权限修饰符" class="headerlink" title="四种访问权限修饰符"></a>四种访问权限修饰符</h3><p>Java 权限修饰符 public、protected、 (缺省)、 private 置于类的成员定义前，用来限定对象对该类成员的访问权限。</p>
<blockquote>
<p><strong>注意事项</strong></p>
<ol>
<li><p><strong>对于 外部类的权限修饰只可以用 public 和 default （缺省）</strong></p>
</li>
<li><p>一个 Java 文件只能有一个 public 类（如果有多个，则不知道调用那个类的 main 方法，且文件名必须与 public 修饰的类一致），如果一个文件有多个类，类名和文件名一样，该类必须使用 public 修饰，其他类不能使用 public 修饰。若没用 public 修饰，类名与文件名可以不一样</p>
</li>
<li><p>四种访问权限修饰符的对比</p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>(default)</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>同一个包</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>不同包子类</td>
<td>是</td>
<td><strong>是</strong></td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>不同包非子类</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
</li>
<li><p>protected 当前类，相同包下的类，不同包的子类（给子类使用）可以访问</p>
<p><strong>补充：</strong>若子类与父类不在同一包中，那么在子类中，可以通过子类实例访问从父类继承而来的protected方法，而不能直接访问父类实例的protected方法</p>
</li>
<li><p><strong>默认修饰符：只能在同包中访问，子包也不可以</strong></p>
</li>
</ol>
</blockquote>
<p>代码示例：（protected ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.oop.permit.pa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.oop.permit.pb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.oop.permit.pa.Super;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodA()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Super</span> <span class="variable">aSuper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Super</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            若子类与父类不在同一包中，那么在子类中，</span></span><br><span class="line"><span class="comment">            可以通过子类实例访问从父类继承而来的protected方法，</span></span><br><span class="line"><span class="comment">            而不能直接访问父类实例的protected方法，</span></span><br><span class="line"><span class="comment">            否则提示没有权限</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// aSuper.methodA();</span></span><br><span class="line">        <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        sub.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（default）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.oop.permit.pc.pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FuClass</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FuClass methodA()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FuClass methodB()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.oop.permit.pc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.oop.permit.pc.pd.FuClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiffPackageClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FuClass</span> <span class="variable">fuClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FuClass</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            默认权限修饰符：只能在同包中访问，子包也不可以</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//fuClass.methodA();</span></span><br><span class="line">        fuClass.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承概述"><a href="#继承概述" class="headerlink" title="继承概述"></a>继承概述</h3><p>将多个类中相同的属性和方法，抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承单独的类即可。多个类称为子类(派生类)，单独的这个类称为父类(基类或超类)。</p>
<p>可以理解为：“子类 is a 父类”。</p>
<blockquote>
<p><strong>继承的作用</strong></p>
<ol>
<li><p>减少了代码冗余，提高了代码的复用性，更有利于功能的扩展。</p>
</li>
<li><p>使类与类之间产生了耦合，同时也提供了多态的前提。</p>
</li>
</ol>
<p><strong>继承的注意事项</strong></p>
<ol>
<li><p>子类不能直接访问父类中私有的（private）的成员变量和方法。</p>
</li>
<li><p>子类只能获取父类非私有成员，若子类和父类都有相同成员变量，则采用【就近原则】。</p>
</li>
<li><p>Java 只支持单继承和多层继承，不允许多重继承。</p>
</li>
<li><p>super 可以获取父类的成员变量和方法，super.name，super.method。</p>
</li>
<li><p>如果访问父类方法不加 super，则会调用当前类方法，出现栈溢出。</p>
</li>
</ol>
<p><strong>继承的优点：</strong></p>
<p>​		代码重用，提高代码的可扩展性。</p>
<p><strong>继承的缺点：</strong></p>
<ol>
<li><p><strong>继承是侵入性的，只要继承就必须拥有父类的所有属性和方法。</strong></p>
</li>
<li><p>可能造成子类代码冗余、灵活性降低，因为子类必须拥有父类的属性和方法。</p>
</li>
<li><p>增强了耦合性。当父类的常量、变量和方法被修改时，必须考虑子类的修改，而且在缺乏规范的环境下，可能带来大量的代码重构。</p>
</li>
</ol>
</blockquote>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><strong>作用</strong></p>
<p>​		super可用于访问父类中定义的属性、成员方法、构造方法。</p>
<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p><strong>当子父类出现同名成员时，可以用 super 表明调用的是父类中的成员。</strong></p>
</li>
<li><p><strong>子类中所有的构造器默认都会访问父类中的空参构造器。</strong></p>
</li>
<li><p><strong>当父类中没有空参数的构造器时，子类的构造器必须通过 this(参数列表) 或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，this 与 super 只能 “二选一”，且必须放在构造器的首行。</strong></p>
</li>
<li><p><strong>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错。因此父类强烈建议：有空参构造,且不是private修饰</strong></p>
</li>
<li><p><strong>可以在子类的构造方法中使用 super( ) ，可以含参数调用父类的构造方法，子类的构造方法可以使用 this( ) 可以含参，调用当前类的其他构造方法。</strong></p>
</li>
</ol>
</blockquote>
<p>代码示例：（super 的使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试super的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类强烈建议有空参构造,且不是 private 修饰：</span></span><br><span class="line"><span class="comment"> * 1. 子类继承</span></span><br><span class="line"><span class="comment"> * 2. 反射创建对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person Constructor!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person Constructor With Arguments!&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person Common Methods!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当父类中没有空参数的构造器时，子类的构造器必须通过 this(参数列表) 或者super(参数列表)语句</span></span><br><span class="line"><span class="comment"> * 指定调用本类或者父类中相应的构造器。同时，只能&quot;二选一&quot;，且必须放在构造器的首行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Worker&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类中所有的构造器默认都会访问父类中的空参构造器</span></span><br><span class="line"><span class="comment">        且 this 和 super 只能&quot;二选一&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        <span class="comment">//super(name);</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        super调用父类属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printSuper</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + <span class="built_in">super</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        super和this访问属性/方法和构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.method();</span><br><span class="line">        System.out.println(<span class="string">&quot;Worker Common Methods!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;Worker&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + worker.name);<span class="comment">//name = Worker</span></span><br><span class="line">        worker.printSuper(); <span class="comment">//name = Person</span></span><br><span class="line">        worker.method();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            this和super都不能在静态方法中使用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;name = &quot; + super.name);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            不能访问父类的私有属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*Person person = new Person();</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;age = &quot; + person.age);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;age = &quot; + worker.age);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p><strong>方法的重写&#x2F;覆盖 (override&#x2F;overwrite)</strong></p>
<p>定义：在子类中根据需要对父类中继承来的方法进行改造。</p>
<p>在子类方法上面加 @override，表明该方法为重写，若方法声明不同，则会在编译期报错，重写发生在运行期。</p>
<blockquote>
<p><strong>重写的规则：</strong> </p>
<ol>
<li><strong>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表（顺序、类型、个数）。</strong></li>
<li><strong>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型。返回值类型为 void 和基本类型时，子类方法也为 void 和基本类型，如果是引用类型，重写的方法返回值必须相同或是其子类。</strong></li>
<li><strong>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限，子类不能重写父类中声明为 private 权限的方法。</strong></li>
<li><strong>子类方法抛出的异常不能大于父类被重写方法的异常或不抛异常。</strong></li>
<li><strong>private 修饰不能重写，final 修饰不能重写。（不能被继承，没有多态，自然不能被重写）</strong></li>
<li><strong>静态方法不能重写，子类和父类的静态方法可以相同，但不是重写（重写发生在运行期）, static 方法是属于类的，子类无法覆盖父类的方法。</strong></li>
<li><strong>构造方法不能被重写。（反例：方法名必须和类名相同）</strong></li>
<li><strong>static 和 abstract 不能同时修饰方法（抽象方法要被重写）。</strong></li>
<li><strong>父类的静态方法不能被子类覆盖为非静态方法，父类的非静态方法不能被子类覆盖为静态方法。</strong></li>
<li><strong>父类的抽象方法可以被子类通过两种途径覆盖（即实现和覆盖）。父类的非抽象方法可以被覆盖为抽象方法，此时子类必须为抽象类。</strong></li>
</ol>
</blockquote>
<p>代码示例：（重写规则）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverWriteTest</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodA()...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodB()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodC()...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">methodD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodD()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">methodE</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodE()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodF</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodF()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        static修饰的方法不能被重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodG</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodG()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        final修饰的方法不能被重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">methodH</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodH()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private Super()&#123;&#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Super</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        构造方法不能重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Super</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodG()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类抛出异常必须小于等于父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodI</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodI()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodJ</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodJ()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodK</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super methodK()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        抽象方法要么实现，要么覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodL</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        static 和 abstract 不能同时使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// public static abstract void methodM();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对于引用类型，方法的返回值必须父类相同或是父类的子类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodA()...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对于void和基本数据类型，方法的返回值必须父类相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodB()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// public long methodC() &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodC()...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        private修饰的方法不能被重写，如果 @Override 修饰会报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    private void methodD()&#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Sub methodD()...&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">methodE</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// void methodE() &#123;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodE()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类方法抛出的异常不能大于父类被重写方法的异常或不抛异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// public void methodF() throws Exception &#123;//报错</span></span><br><span class="line">    <span class="comment">// public void methodF() &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodF</span><span class="params">()</span> <span class="keyword">throws</span> DownloadException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodF()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        静态方法不不能重写，是属于类的，不会报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodG</span><span class="params">()</span> <span class="keyword">throws</span> DownloadException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub methodF()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父类的静态方法不能被子类覆盖为非静态方法，父类的非静态方法不能被子类覆盖为静态方法。</span></span><br><span class="line">    <span class="comment">/*public void methodI() throws DownloadException &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Sub methodF()...&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static void methodJ() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Sub methodB()...&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        父类的非抽象方法可以被覆盖为抽象方法，子类必须为抽象类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodK</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        父类的抽象方法可以被子类通过两种途径覆盖（即实现和覆盖）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodL</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重写与重载的比较（略）"><a href="#重写与重载的比较（略）" class="headerlink" title="重写与重载的比较（略）"></a>重写与重载的比较（略）</h3><h3 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h3><p>使用 abstract 修饰的类和方法分别为抽象类和抽象方法。</p>
<p>对于抽象方法，只有方法的声明，没有方法的实现，以分号结束。</p>
<p><strong>解决的问题</strong></p>
<p>​		将类中不确定的功能提取出来，由不同的子类去实现，抽象类作为多个子类的模板。抽象类体现的就是一种<strong>模板模式</strong>的设计。</p>
<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>含有抽象方法的类必须被声明为抽象类。</p>
</li>
<li><p>抽象类不能被实例化，但可以有构造方法（给成员变量初始化）。</p>
</li>
<li><p>不能用 abstract 修饰变量、代码块、构造器。</p>
</li>
<li><p>不能用 abstract 修饰私有方法、静态方法、final 的方法、final 的类。</p>
</li>
<li><p>抽象类中可以有非抽象的方法、成员变量以及 final 常量。</p>
</li>
<li><p>抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体或 @Override 重写。若子类没有重写全部的抽象方法，仍为抽象类。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（抽象类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.含有抽象方法的类必须被声明为抽象类。</span></span><br><span class="line"><span class="comment"> * 2.抽象类不能被实例化，但可以有构造方法（给成员变量初始化）。</span></span><br><span class="line"><span class="comment"> * 3.不能用abstract修饰变量、代码块、构造器。</span></span><br><span class="line"><span class="comment"> * 4.不能用abstract修饰私有方法、静态方法、final的方法、final的类。</span></span><br><span class="line"><span class="comment"> * 5.抽象类中可以有非抽象的方法、成员变量以及final常量。</span></span><br><span class="line"><span class="comment"> * 6.抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体或<span class="doctag">@Override</span>重写。若子类没有重写全部的抽象方法，仍为抽象类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClassTest</span> &#123;</span><br><span class="line"><span class="comment">//public abstract final class AbstractClassTest &#123;</span></span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClassTest</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;abstract&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AbstractClassTest methodA()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private abstract void methodB()&#123;&#125;</span></span><br><span class="line"><span class="comment">//    public abstract final void methodB()&#123;&#125;</span></span><br><span class="line"><span class="comment">//    private abstract static void methodB()&#123;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbstractClassTest</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;AbstractClassTest methodC()...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口（interface）是抽象方法和常量值的集合。</p>
<p>接口一方面提供多继承的效果，另一方面抽取相同的行为特征（不是is a的关系）。</p>
<p>接口就是规范，定义的是一组规则，体现了现实世界中 “如果你是&#x2F;要…则必须能…” 的思想。</p>
<p>继承是一个”是不是”的关系，而接口实现则是 “能不能” 的关系。</p>
<blockquote>
<p><strong>接口注意事项：</strong></p>
<ol>
<li><p>接口中的成员变量默认由 public static final 修饰，抽象方法默认由 public abstract 修饰。</p>
</li>
<li><p>定义Java类的语法格式：先写 extends，后写 implements。</p>
</li>
<li><p>接口中没有构造器，接口采用多继承机制。一个类可以实现多个接口，接口也可以继承其它接口。</p>
</li>
<li><p>实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化，否则仍为抽象类。</p>
</li>
<li><p>与继承关系类似，接口与实现类之间存在多态性。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（interface）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.接口中的成员变量默认由public static final修饰，抽象方法默认由public abstract修饰。</span></span><br><span class="line"><span class="comment"> * 2.定义Java类的语法格式：先写extends，后写implements。</span></span><br><span class="line"><span class="comment"> * 3.接口中没有构造器，接口采用多继承机制。一个类可以实现多个接口，接口也可以继承其它接口。</span></span><br><span class="line"><span class="comment"> * 4.实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化，否则仍为抽象类。</span></span><br><span class="line"><span class="comment"> * 5.与继承关系类似，接口与实现类之间存在多态性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceTest</span> <span class="keyword">extends</span> <span class="title class_">ClassA</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">S</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//    JDK8：默认方法、静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ((InterfaceA) () -&gt; System.out.println(<span class="string">&quot;interface main()...&quot;</span> + S)).method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassA</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK版本中接口的改动"><a href="#JDK版本中接口的改动" class="headerlink" title="JDK版本中接口的改动"></a>JDK版本中接口的改动</h3><h4 id="JDK7：常量、抽象方法"><a href="#JDK7：常量、抽象方法" class="headerlink" title="JDK7：常量、抽象方法"></a>JDK7：常量、抽象方法</h4><h4 id="JDK8：默认方法、静态方法"><a href="#JDK8：默认方法、静态方法" class="headerlink" title="JDK8：默认方法、静态方法"></a>JDK8：默认方法、静态方法</h4><p>Java 8中，可以为接口添加静态方法和默认方法。</p>
<p><strong>添加静态方法</strong>：使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。如 Collection&#x2F;Collections 或</p>
<p>者Path&#x2F;Paths这样成对的接口和类。</p>
<p><strong>添加默认方法</strong>：默认方法使用 default 关键字修饰。可以通过实现类对象来调用。默认方法主要用于接口升级，在已有的</p>
<p>接口中提供新方法的同时，保持与旧版本代码的兼容性。如 java 8 API中对Collection、List、Comparator等接口提供了</p>
<p>大量的默认方法。</p>
<blockquote>
<p><strong>默认方法的注意事项</strong></p>
<ol>
<li><p>若一个接口中定义了一个默认方法，而另一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：<strong>接口冲突</strong>。</p>
<p><strong>解决办法</strong>：实现类必须覆盖接口中同名同参数的方法，来解决冲突。</p>
</li>
<li><p>若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。此时遵守：<strong>类优先原则</strong>。接口中具有相同名称和参数的默认方法会被忽略。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（默认方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口中的默认方法:</span></span><br><span class="line"><span class="comment"> * 1.若一个接口中定义了一个默认方法，而另一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），</span></span><br><span class="line"><span class="comment"> * 在实现类同时实现了这两个接口时，会出现：接口冲突。</span></span><br><span class="line"><span class="comment"> * 解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。</span></span><br><span class="line"><span class="comment"> * 2.若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，</span></span><br><span class="line"><span class="comment"> * 则不会出现冲突问题。此时遵守：类优先原则。接口中具有相同名称和参数的默认方法会被忽略。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceTest2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        接口冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>, Pet &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            必须实现相同的默认方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cat eat()...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        类优先原则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Taxi</span> <span class="keyword">extends</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Traffic</span> &#123;</span><br><span class="line">        <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">        public void run() &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Taxi run()...&quot;);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InterfaceTest2</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceTest2</span>();</span><br><span class="line">        test.<span class="keyword">new</span> <span class="title class_">Cat</span>().eat(); <span class="comment">// Cat eat()...</span></span><br><span class="line">        test.<span class="keyword">new</span> <span class="title class_">Taxi</span>().run(); <span class="comment">// Car run()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal eat()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pet eat()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Traffic</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Traffic run()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car run()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="JDK9：私有方法"><a href="#JDK9：私有方法" class="headerlink" title="JDK9：私有方法"></a>JDK9：私有方法</h4><p>解决问题：多个默认方法共有的重复代码提取出来，不给实现类使用。</p>
<h3 id="接口与抽象类的对比"><a href="#接口与抽象类的对比" class="headerlink" title="接口与抽象类的对比"></a>接口与抽象类的对比</h3><table>
<thead>
<tr>
<th>区别点</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>组成</td>
<td>构造方法、抽象方法、普通方法、常量、变量</td>
<td>常量、抽象方法、（JDK8默认方法、静态方法）</td>
</tr>
<tr>
<td>使用</td>
<td>子类继承</td>
<td>子类实现</td>
</tr>
<tr>
<td>关系</td>
<td>抽象类可实现多个接口</td>
<td>接口不能继承抽象类，但允许继承多个接口</td>
</tr>
<tr>
<td>常见的设计模式</td>
<td>模板方法</td>
<td>简单工厂、抽象工厂、代理模式</td>
</tr>
<tr>
<td>实际</td>
<td>作为一个模板</td>
<td>作为一个标准（规范）</td>
</tr>
</tbody></table>
<p><strong>优先使用接口，避免单继承</strong>  </p>
<p>代码示例：（接口练习一）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PracticeA</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//int x = 2;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// The field x is ambiguous(二义性，编译不通过)</span></span><br><span class="line">        <span class="comment">//System.out.println(x);</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.x);</span><br><span class="line">        System.out.println(A.x);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">D</span>().x);</span><br><span class="line">        <span class="comment">//System.out.println(x);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//默认常量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（接口练习二）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PracticeB</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Playable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bounceable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 接口中的变量默认为public static final，在Ball类的Play()方法中，&quot;ball = new Ball(&quot;Football&quot;);&quot;</span></span><br><span class="line"><span class="comment"> 改变了ball的reference，final的object是不能被改变reference的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Rollable</span> <span class="keyword">extends</span> <span class="title class_">Playable</span>, Bounceable &#123;</span><br><span class="line">    <span class="type">Ball</span> <span class="variable">ball</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ball</span>(<span class="string">&quot;PingPang&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ball</span> <span class="keyword">implements</span> <span class="title class_">Rollable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ball</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 报错：接口中的变量默认为public static final，不能被修改</span></span><br><span class="line">        <span class="comment">// ball = new Ball(&quot;Football&quot;);</span></span><br><span class="line">        System.out.println(ball.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键字-static-和-final"><a href="#关键字-static-和-final" class="headerlink" title="关键字 static 和 final"></a>关键字 static 和 final</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>类属性</strong>：作为该类各个对象之间共享的变量，不因对象的不同而改变。</p>
<p><strong>类方法</strong>：如果方法与调用者无关，则这样的方法通常被声明为类方法，直接由类名调用。</p>
<p>堆：new出来的结构：对象、数组</p>
<p>方法区：类的结构信息、静态变量、常量</p>
<p><strong>static优点：</strong></p>
<ol>
<li><p>对对象的共享数据提供单独的存储，节省空间。</p>
</li>
<li><p>可以直接被类名调用，不用在堆内存创建对象。</p>
</li>
</ol>
<p><strong>static缺点</strong>：访问出现局限性</p>
<h3 id="使用范围及注意事项"><a href="#使用范围及注意事项" class="headerlink" title="使用范围及注意事项"></a>使用范围及注意事项</h3><blockquote>
<p>在Java类中，可用static修饰属性、方法、代码块、<strong>内部类</strong></p>
<p>被修饰后的成员具备以下特点：</p>
<ol>
<li><p><strong>随着类的加载而加载，优先于对象存在，修饰的成员，被所有对象所共享。</strong></p>
</li>
<li><p><strong>访问权限允许时，可不创建对象，直接被类调用。</strong></p>
</li>
<li><p><strong>private 和 static 可以一起用，两者没有联系 private 只是权限修饰符。</strong></p>
</li>
<li><p><strong>静态方法只能访问静态成员（成员变量、成员方法），两者都最先加载。</strong></p>
</li>
<li><p><strong>静态方法中不可以使用 this super关键字（类名访问，不需要实例）。</strong></p>
</li>
<li><p><strong>非静态方法既可以访问静态也可以访问非静态，但不可以定义静态变量。</strong></p>
</li>
<li><p><strong>static 不能修饰局部变量，由于局部变量属于方法，static 优先于对象加载。</strong> </p>
</li>
<li><p><strong>static 不能修饰类，但可以修饰内部类。</strong></p>
</li>
<li><p><strong>static 不能和 abstract 一起使用。</strong></p>
</li>
<li><p><strong>static 修饰的方法不能被重写，子类和父类可以有相同方法且使用 static 修饰，但不是重写。（静态方法在编译期确定，重写方法在运行期）</strong></p>
</li>
<li><p><strong>多个静态代码块可以自上而下为定义的变量赋值。（类的加载先会加载类的结构，如变量的声明，方法的声明，之后再进行变量的赋值，赋值由上而下顺序执行(声明和赋值不会同时进行，<clinit>类构造方法由类变量和静态代码块中的语句按照顺序合并产生））</clinit></strong></p>
</li>
<li><p><strong>静态代码块可以为之后的变量赋值，但不能操作变量的原因（非法的前向引用）：类的加载先会加载类的结构，如变量的声明，方法的声明，之后再进行变量的赋值，赋值由上而下顺序执行（声明和赋值不会同时进行）。</strong></p>
</li>
</ol>
</blockquote>
<h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p>类变量：由该类的所有实例共享</p>
<p>堆：new 出来的结构：对象、数组</p>
<p>方法区：类的加载信息、静态变量、常量</p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><ol>
<li><p>没有对象的实例时，可以用类名.方法名( ) 的形式访问由 static 修饰的类方法。</p>
</li>
<li><p>在 static 方法内部只能访问类的 static 修饰的属性或方法，不能访问类的非 static 的结构。</p>
</li>
<li><p>因为不需要实例就可以访问 static 方法，因此 static 方法内部不能有 this，也不能有 super。不能使用 super 父类的静态方法。this 和 super 都不能在静态方法中使用。</p>
</li>
<li><p>static 修饰的方法不能被重写。（静态方法在编译期确定，重写方法在运行期）</p>
</li>
</ol>
<p>代码示例：（static）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于static的几点说明：</span></span><br><span class="line"><span class="comment"> * 1.静态方法不能调用非静态属性：</span></span><br><span class="line"><span class="comment"> *        非静态方法可以调用的原因:默认使用this.属性名调用</span></span><br><span class="line"><span class="comment"> * 2.static不能修饰局部变量的原因：</span></span><br><span class="line"><span class="comment"> *        局部变量属于方法，static优先于对象加载</span></span><br><span class="line"><span class="comment"> * 3.静态代码块中可以对自上而下靠后定义的变量赋值，但不能操作变量的原因：</span></span><br><span class="line"><span class="comment"> *        类的加载先会加载类的结构，如变量的声明，方法的声明，之后再进行变量的赋值，赋值由上而下顺序执行(声明和赋值不会同时进行)。</span></span><br><span class="line"><span class="comment"> 初始化：c 的值由&lt;clinit&gt;方法决定，&lt;clinit&gt;类构造方法由类变量和静态代码块中的语句按照顺序合并产生。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        b = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        c = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//可以给c赋值，但不能操作</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;c = &quot;+c);//Illegal forward reference</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多个静态代码块会依次由上而下执行</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//static可以修饰内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private仅仅是权限修饰符，局部变量只可以使用final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// static int b = 2;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//static修饰的方法不能重写，但子类可以有相同的方法（不是重写）</span></span><br><span class="line">    <span class="comment">//静态方法在编译期确定，重写发生在运行期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的static方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//静态方法不能使用非静态变量</span></span><br><span class="line">        <span class="comment">// System.out.println(a);</span></span><br><span class="line">        <span class="comment">// output：</span></span><br><span class="line">        <span class="comment">// b = 2</span></span><br><span class="line">        <span class="comment">// b = 3</span></span><br><span class="line">        <span class="comment">// c = 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTestSub</span> <span class="keyword">extends</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的static方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        methodB(); <span class="comment">// 子类的static方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="main方法说明"><a href="#main方法说明" class="headerlink" title="main方法说明"></a>main方法说明</h3><ol>
<li><p>Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public。</p>
</li>
<li><p>Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的。</p>
</li>
<li><p>main()方法接收String数组，该数组中保存执行Java命令时传递给所运行的类的参数。</p>
</li>
<li><p>由于main() 方法是静态的，必须创建该类的一个实例对象后，才能访问该对象中的非静态成员。</p>
</li>
</ol>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p><strong>在 Java 中声明类、变量和方法时，可使用关键字final来修饰表示 “最终的”。</strong></p>
</li>
<li><p><strong>final 标记的类不能被继承。提高安全性，提高程序的可读性。如 String、System、StringBuffer。</strong></p>
</li>
<li><p><strong>final 标记的方法不能被子类重写。如：Object 类中的 public final native Class&lt;?&gt; getClass();。</strong></p>
</li>
<li><p><strong>final 标记的变量（成员变量）即称为常量。名称建议大写，且只能被赋值一次。对于非静态属性：必须在构造方法执行之前赋值如：直接赋值、构造方法赋值、实例块赋值。</strong></p>
</li>
</ol>
<p> <strong>5.   final 修饰的引用类型，只是地址不可变，而非内容不可变。</strong></p>
<p> <strong>6.   final 标记局部变量或形参时，仅在使用时不能改变，在使用前需要完成初始化。</strong></p>
<ol start="7">
<li><p><strong>由于成员变量具有默认值null或者其他，所以使用 final 修饰后必须赋值。</strong></p>
</li>
<li><p><strong>final 标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。</strong></p>
</li>
<li><p><strong>static final：全局常量，对于 static 静态属性，必须在类加载时赋值，如:直接赋值、静态块中赋值。</strong></p>
</li>
</ol>
</blockquote>
<p>代码示例：（final 属性）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：final修饰成员变量</span></span><br><span class="line"><span class="comment"> * final修饰成员属性：</span></span><br><span class="line"><span class="comment"> *        1.必须赋初值：由于成员变量具有默认值null或者其他，所以使用final修饰后必须赋值。</span></span><br><span class="line"><span class="comment"> *           对于非静态属性：必须在构造方法执行之前赋值</span></span><br><span class="line"><span class="comment"> *              如：直接赋值、构造方法赋值、实例块赋值</span></span><br><span class="line"><span class="comment"> *           对于static静态属性：必须在类加载时赋值（static final全局常量）</span></span><br><span class="line"><span class="comment"> *              如:直接赋值、静态块中赋值</span></span><br><span class="line"><span class="comment"> *        2.不能被改变，且只能被赋值一次</span></span><br><span class="line"><span class="comment"> *     final修饰局部变量：</span></span><br><span class="line"><span class="comment"> *        作为参数：仅在使用时不能改变</span></span><br><span class="line"><span class="comment"> *        定义变量时不能改变，在使用前完成初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalTest</span> &#123;</span><br><span class="line">    <span class="comment">//直接赋值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例块赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        B = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> C;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法赋值，每个构造方法都要赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalTest</span><span class="params">()</span> &#123;</span><br><span class="line">        C = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//final修饰变量只能赋值一次</span></span><br><span class="line">        <span class="comment">//A = 4;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalTest</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        C = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态属性直接赋值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">D</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态块赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        E = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//final修饰局部变量不能修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> f, <span class="keyword">final</span> <span class="type">int</span> g)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        f = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//局部变量不能修改</span></span><br><span class="line">        <span class="comment">// g = 7;</span></span><br><span class="line">        <span class="comment">// g = g++；</span></span><br><span class="line">        System.out.println(<span class="string">&quot;g = &quot;</span> + g);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FinalTest</span> <span class="variable">finalTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalTest</span>();</span><br><span class="line">        System.out.println(finalTest.A); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(finalTest.B); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(finalTest.C); <span class="comment">// 3</span></span><br><span class="line">        System.out.println(FinalTest.D); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(FinalTest.E); <span class="comment">// 5</span></span><br><span class="line">        finalTest.method(<span class="number">10</span>, <span class="number">12</span>); <span class="comment">//g = 12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（final 类、方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> * 测试：<span class="keyword">final</span>修饰类不能被继承，修饰方法不能被重写</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalTest2</span> &#123;</span><br><span class="line"><span class="comment">//public final class FinalTest2 &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FinalTest2 methodA()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FinalTest2 methodA()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final修饰类不能被继承</span></span><br><span class="line"><span class="comment">/*class FinalTestSub extends FinalTest2&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// final修饰方法不能被重写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FinalTestSub</span> <span class="keyword">extends</span> <span class="title class_">FinalTest2</span> &#123;</span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void methodB() &#123;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（对象生成唯一标识）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给一个类的对象生成唯一标识</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalTest3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalTest3</span><span class="params">()</span> &#123;</span><br><span class="line">        ID = ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FinalTest3</span> <span class="variable">finalTest3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalTest3</span>();</span><br><span class="line">        <span class="type">FinalTest3</span> <span class="variable">finalTest4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalTest3</span>();</span><br><span class="line">        System.out.println(finalTest3.ID); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(finalTest4.ID); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ol>
<li><p>代码块(或初始化块)的作用：对Java类属性或成员变量进行初始化</p>
</li>
<li><p>代码块可以分为静态代码块（static{ }）和实例块（{ }）。</p>
</li>
<li><p>一个类中代码块若有修饰符，则只能被 static 修饰，称为静态代码块。</p>
</li>
</ol>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><ol>
<li><p>static 代码块通常用于初始化 static 的属性或其他事情。</p>
</li>
<li><p>static 代码块中不可以对非静态的属性初始化。</p>
</li>
<li><p>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</p>
</li>
<li><p>静态代码块的执行要先于非静态代码块。</p>
</li>
<li><p>静态代码块随着类的加载而加载，且只执行一次。</p>
</li>
</ol>
<h3 id="非静态代码块"><a href="#非静态代码块" class="headerlink" title="非静态代码块"></a>非静态代码块</h3><ol>
<li><p>可以对类的属性、类的声明进行初始化操作。</p>
</li>
<li><p>除了调用非静态的结构外，还可以调用静态的变量或方法。</p>
</li>
<li><p>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</p>
</li>
<li><p>每次创建对象的时候，都会执行一次且先于构造器执行。</p>
</li>
</ol>
<h3 id="成员变量的赋值顺序"><a href="#成员变量的赋值顺序" class="headerlink" title="成员变量的赋值顺序"></a>成员变量的赋值顺序</h3><p><strong>成员变量的默认初始化 –&gt; 显式初始化、代码块初始化 –&gt; 构造器初始化 –&gt; 赋值操作</strong></p>
<p>代码示例：（代码块）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//不能对非静态变量进行初始化</span></span><br><span class="line">        <span class="comment">// a = 0;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span>+b);</span><br><span class="line">        b = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span>+b);</span><br><span class="line">        c = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// System.out.println(c);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;实例块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeBlockTest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法执行&quot;</span>);</span><br><span class="line">        a = <span class="number">6</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        c = <span class="number">7</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;c = &quot;</span>+c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeBlockTest</span>();</span><br><span class="line">        <span class="comment">// b = 2</span></span><br><span class="line">        <span class="comment">// b = 3</span></span><br><span class="line">        <span class="comment">// 静态块执行</span></span><br><span class="line">        <span class="comment">// c = 7</span></span><br><span class="line">        <span class="comment">// a = 5</span></span><br><span class="line">        <span class="comment">// 实例块执行</span></span><br><span class="line">        <span class="comment">// 构造方法执行</span></span><br><span class="line">        <span class="comment">// a = 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态概述"><a href="#多态概述" class="headerlink" title="多态概述"></a>多态概述</h3><p>Java 引用变量有两个类型：<strong>编译时类型和运行时类型</strong>。</p>
<p>编译时类型由<strong>声明该变量时</strong>使用的类型决定，运行时类型由<strong>实际赋给该变量的对象</strong>决定。</p>
<p>若编译时类型和运行时类型不一致，就出现了对象的多态性（Polymorphism）。</p>
<p><strong>对象的多态性</strong>：父类或接口的引用指向子类的对象。</p>
<p>动态绑定：运行期间的方法（是方法，不是变量）根据子类类型绑定，编译期间根据父类类型绑定。</p>
<h3 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h3><p><strong>多态的格式</strong>：<strong>父类&#x2F;接口  引用 &#x3D; new  子类&#x2F;实现类 ( );</strong></p>
<p>多态发生的前提：子父类的继承关系、方法重写、父类引用指向子类对象。</p>
<p>示例：Animal a &#x3D; new Cat( );</p>
<h3 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h3><ol>
<li><p>多态的作用：<strong>提高了代码的通用性</strong>，常称作接口重用。</p>
</li>
<li><p><strong>多态的前提</strong>：需要存在继承或者实现关系，有方法的重写。</p>
</li>
<li><p><strong>多态优缺点</strong></p>
<ul>
<li><p>无法直接访问子类特有成员（向下造型解决，需要 instanceof 判断）</p>
</li>
<li><p>可以提高可维护性，提高代码的可扩展性【可扩展性：将父类型作为方法参数，定义接口，子类实现】</p>
</li>
</ul>
</li>
</ol>
<p><strong>4.</strong>   <strong>多态的特点和注意事项</strong></p>
<blockquote>
<p>1） 对于多态，程序在编译时没有对象，父类不能调用子类的成员变量，运行时才有对象。</p>
<p>2） 成员变量：编译时根据父类判断，是否有相应的变量，<strong>不具备多态性，只看引用变量所声明的类。</strong></p>
<p>3） 成员方法：编译时要看引用变量所声明的类中是否有所调用的方法。运行时调用实际 new 的对象所属的类中的重写方法。</p>
<p>4） 静态方法：父类子类中含有静态方法，调用父类方法，变量 value 是用变量的类型的类去调用（编译和运行时相同）</p>
<p>5） 多态是对象之间的规则，和类无关，即和 static 无关。覆盖依赖于类的实例，静态方法和类实例没有关系。而且静态方法在编译时就已经确定，而方法覆盖是在运行时确定的（动态绑定）</p>
</blockquote>
<h3 id="向上造型和向下造型"><a href="#向上造型和向下造型" class="headerlink" title="向上造型和向下造型"></a>向上造型和向下造型</h3><p><strong>向上造型（upcasting）：只能调用父类的方法，执行的则是子类的方法</strong></p>
<blockquote>
<p>Java中，子类的对象可以替代父类的对象使用，一个变量只能有一种确定的数据类型，一个引用类型变量可能指向（引用）多种不同类型的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// Object 类型的变量 o，指向 Person 类型的对象</span></span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> <span class="title class_">Student</span>();  <span class="comment">// Object 类型的变量 o，指向 Student 类型的对象</span></span><br></pre></td></tr></table></figure>

<p>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型（upcasting）。</p>
</blockquote>
<p><strong>向下造型</strong>：<strong>可以调用子类特有的方法</strong></p>
<blockquote>
<p><strong>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法，属性是在编译时确定的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">m.school = <span class="string">&quot;pku&quot;</span>; 	<span class="comment">// 合法，Student类有school成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">e.school = <span class="string">&quot;pku&quot;</span>; 	<span class="comment">//非法，Person类没有school成员变量</span></span><br></pre></td></tr></table></figure>

<p><strong>属性是在编译时确定的，编译时 e 为 Person 类型，没有 school 成员变量，因而编译错误。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上造型</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="comment">// 向下造型</span></span><br><span class="line"><span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat) a;</span><br></pre></td></tr></table></figure>

<p><strong>先向上造型，再向下造型</strong>，如果类型不匹配，可能造成类造型异常，需要通过 instanceOf 先判断是否是原本的对象。</p>
<h3 id="instance-of"><a href="#instance-of" class="headerlink" title="instance of"></a>instance of</h3><p>X instanceof A：检验 X 是否为类 A 的子类会实现类，返回值为 boolean 型</p>
<p>代码示例：（多态）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试多态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphismTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            向上造型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.method(); <span class="comment">// Cat method()...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            对于成员变量不存在多态，输出父类的属性，属性是在编译时确定的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(dog.name); <span class="comment">//Animal</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            静态方法（编译器确定）不是重写（运行期确定）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        animal.staticMethod();<span class="comment">//Animal staticMethod()...</span></span><br><span class="line">        Animal.staticMethod();<span class="comment">//Animal staticMethod()...</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            父类无法的访问子类特有成员(属性/方法)，需要向下转型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// dog.voice();</span></span><br><span class="line">        <span class="comment">// dog.barking();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// java.lang.ClassCastException,使用instanceof判断</span></span><br><span class="line">        <span class="comment">// Dog dog2 = (Dog) cat;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            instanceof 向下造型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (dog <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> (Dog) dog;</span><br><span class="line">            System.out.println(dog2.voice); <span class="comment">// WangWang</span></span><br><span class="line">            dog2.barking(); <span class="comment">// the dog is barking! WangWang</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Animal&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal method()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal staticMethod()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat method()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">voice</span> <span class="operator">=</span> <span class="string">&quot;WangWang&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog method()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barking</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;the dog is barking! &quot;</span> + voice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚拟方法调用"><a href="#虚拟方法调用" class="headerlink" title="虚拟方法调用"></a>虚拟方法调用</h3><p><strong>Virtual Method Invocation</strong></p>
<p>​		虚拟方法调用产生于多态条件，子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为<strong>虚拟方法</strong>，父类根据赋给它的不同子类对象，动态调用属于子类的方法，这样的方法调用在编译期是无法确定的。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类概述"><a href="#内部类概述" class="headerlink" title="内部类概述"></a>内部类概述</h3><p>内部类：当一个类的内部需要一个完整的结构为该类提供服务时，可以使用内部类。</p>
<p>Inner class 的名字不能与包含它的外部类类名相同。</p>
<p>内部类的分类：</p>
<ol>
<li>成员内部类（static成员内部类和非static成员内部类）</li>
<li>部内部类（没有修饰符）、匿名内部类</li>
</ol>
<h3 id="成员内部类（静态-x2F-非静态）"><a href="#成员内部类（静态-x2F-非静态）" class="headerlink" title="成员内部类（静态&#x2F;非静态）"></a>成员内部类（静态&#x2F;非静态）</h3><blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p><strong>一般在外部类中 new 内部类的对象，调用其方法。若不先创建外部类而要使用内部类对象，可以导包或者使用outer.inner x &#x3D; new Outer().new inner() 【非静态内部类】或者 OuterClass.InnerClass3 innerClass3 &#x3D; new OuterClass.InnerClass3()【静态内部类】会调用构造方法。</strong></p>
</li>
<li><p><strong>外部类访问成员内部类的成员，需要 “内部类.成员” 或 “内部类对象.成员” 方式。</strong> </p>
</li>
<li><p><strong>编译以后生成 OuterClass$InnerClass.class 字节码文件（也适用于局部内部类）。</strong></p>
</li>
<li><p><strong>可以在内部类中定义属性、方法、构造器等结构，成员内部类可以直接使用外部类的所有成员，包括私有的数据&#x2F;方法。</strong></p>
</li>
<li><p><strong>成员内部类作为类的成员： 可以声明为 private 或 protected。外部类只能使用 public 修饰或不修饰。</strong></p>
</li>
<li><p><strong>private 修饰内部类，单独为内部类提供服务，可以在外部创建对象，但在其他类不能使用。</strong></p>
</li>
<li><p><strong>可以声明为 abstract 和 final。（被其他内部类继承或不能被实现）</strong></p>
</li>
<li><p><strong>当外部类的静态成员部分需要使用内部类时，可以考虑内部类声明为静态的。</strong></p>
</li>
<li><p><strong>若内部类用 static 修饰，外部类可以通过 Outer.Inner i &#x3D; new Outer.Inner();</strong></p>
</li>
<li><p><strong>内部类可以声明为 static 的，可以定义非 static 成员，但不能访问外部类的非 static 的成员变量。</strong></p>
</li>
<li><p><strong>只有在外部类或 static 的成员内部类中才可声明 static 成员，非 static 的内部类的成员不能声明为 static，也不可以使用 static 块，但可以使用外部类 static 成员，但可以在非 static 内部类中声明 static final 常量。</strong></p>
</li>
<li><p><strong>如果内部类和外部类有同名&#x2F;非同名的变量，可以使用 this.value，OuterClass.this.value 区分变量（需要添加this，如果直接 OuterClass.value 则是把 value 当做静态变量了）。</strong></p>
</li>
</ol>
</blockquote>
<p>代码示例：（成员内部类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试成员内部类相关注意事项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberInnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            外部类使用非静态的内部类,new OuterClass()会调用OuterClass构造方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>().<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            外部类使用静态内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        OuterClass.<span class="type">InnerClass3</span> <span class="variable">innerClass3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>.InnerClass3();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            其他类不能使用私有的内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// new OuterClass().InnerClass2();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OuterClass</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="comment">// this可以省略</span></span><br><span class="line">        <span class="comment">// InnerClass innerClass = this.new InnerClass();</span></span><br><span class="line">        System.out.println(innerClass.l); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(InnerClass.n); <span class="comment">// 常量 n = 3</span></span><br><span class="line">        innerClass.printStaticField(); <span class="comment">// 4</span></span><br><span class="line">        innerClass.printSameField(); <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInnerClassField</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(inner.m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//非static内部类中不能定义static变量/代码块</span></span><br><span class="line">        <span class="comment">/*static int n = 3;</span></span><br><span class="line"><span class="comment">        static &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">//内部类可以定义常量</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//非static内部类可以使用OutClass的static成员</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStaticField</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(OuterClass.p); <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printSameField</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">            System.out.println(l); <span class="comment">// 2</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.l); <span class="comment">// 1</span></span><br><span class="line">            <span class="comment">//需要添加this，如果直接OuterClass.l则是把 l当做静态变量了</span></span><br><span class="line">            System.out.println(OuterClass.<span class="built_in">this</span>.l); <span class="comment">// 0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        内部类可以使用private/protected/public/默认修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InnerClass2</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        内部类可以使用static以及final修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InnerClass3</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        内部类可以使用abstract修饰，可以不被实现/继承</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InnerClassSuper</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodAbstract</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassSub</span> <span class="keyword">extends</span> <span class="title class_">InnerClassSuper</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodAbstract</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类InnerClassSub继承内部类InnerClassSuper&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        静态内部类可以定义非静态成员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p><strong>定义一个类的时候，权限修饰符规则：</strong></p>
<ol>
<li><p><strong>外部类：public &#x2F; (default) &#x2F; abstract &#x2F; final</strong></p>
</li>
<li><p><strong>成员内部类：public &#x2F; protected &#x2F; (default) &#x2F; private &#x2F; static &#x2F; abstract &#x2F; final</strong></p>
</li>
<li><p><strong>局部内部类：什么都不能写</strong></p>
</li>
</ol>
<p>在类中的<strong>方法内部</strong>定义类，但必须先创建内部类才能使用其方法，离开该方法，类及变量就消失了。</p>
<p>​		<strong>局部内部类只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类，但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型，返回的对象只能以多态的形式访问（必须具有相同的方法，无意义）。</strong></p>
<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。</p>
</li>
<li><p>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的 .class 文件，但前面会加上外部类的类名和$符号，以及数字编号。</p>
</li>
<li><p>局部内部类可以使用外部类的成员，包括私有的。</p>
</li>
<li><p>局部内部类和局部变量地位类似，不能使用 public, protected, 缺省，private。</p>
</li>
<li><p>局部内部类不能使用 static 修饰，因此也不能包含静态成员。</p>
</li>
<li><p>局部内部类可以使用外部方法的局部变量，但是必须是有效 final 的。从 Java8 开始，只要局部变量事实不变，那么final可以省略。原因：由局部内部类和局部变量的声明周期不同所致。new 出来的对象在堆内存中，局部变量在栈内存中，方法运行结束后，局部变量消失，但 new 出来的对象会持续存在，直到垃圾回收。</p>
</li>
<li><p>对于同名的变量，由于优先级的原因，无法访问同名的方法中的变量。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（局部内部类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试局部内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalInnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInner</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">                <span class="comment">//如果a未重新定义，则为this.a</span></span><br><span class="line">                System.out.println(a); <span class="comment">// 4</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.a); <span class="comment">// 3</span></span><br><span class="line">                <span class="comment">// 作用域越小优先级越高,访问不到同名的方法内的局部变量 a</span></span><br><span class="line">                System.out.println(b); <span class="comment">// 5</span></span><br><span class="line">                System.out.println(LocalInnerClassTest.<span class="built_in">this</span>.a); <span class="comment">// 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalInner</span> <span class="variable">localInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInner</span>();</span><br><span class="line">        localInner.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LocalInnerSuperClass <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInnerClassSub</span> <span class="keyword">extends</span> <span class="title class_">LocalInnerSuperClass</span> &#123;</span><br><span class="line">            <span class="comment">//局部内部类不能被static修饰，因此不能使用static</span></span><br><span class="line">            <span class="comment">//static int m = 1;</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;LocalInnerClassSub print()...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//局部内部类可以通过方法返回，但返回的类型必须是局部内部类的超类或接口</span></span><br><span class="line">        <span class="comment">//且返回的对象只能以多态的形式访问（必须具有相同的方法，无意义）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalInnerClassSub</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LocalInnerSuperClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;LocalInnerSuperClass print()...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalInnerClassTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInnerClassTest</span>();</span><br><span class="line">        test.methodA();</span><br><span class="line">        <span class="type">LocalInnerSuperClass</span> <span class="variable">localInnerSuperClass</span> <span class="operator">=</span> test.methodB();</span><br><span class="line">        localInnerSuperClass.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li><p><strong>匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。</strong></p>
</li>
<li><p><strong>一个匿名内部类一定是在 new 的后面，隐含实现一个接口或继承一个类。</strong></p>
</li>
<li><p><strong>匿名内部类必须继承父类或实现接口。</strong></p>
</li>
<li><p><strong>匿名内部类只能有一个对象且只能使用多态形式引用。</strong></p>
</li>
</ol>
</blockquote>
<p>代码示例：（匿名内部类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试匿名内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnonymousSuper</span> <span class="variable">anonymousSuper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousSuper</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;AnonymousSuper AnonymousImpl...&quot;</span>);</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnonymousSuper2</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;AnonymousSuper2 AnonymousImpl...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.methodC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        anonymousSuper.methodB();</span><br><span class="line">        <span class="comment">// AnonymousSuper AnonymousImpl...</span></span><br><span class="line">        <span class="comment">// AnonymousSuper2 AnonymousImpl...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnonymousSuper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AnonymousSuper2</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>Object 类是所有 Java 类的父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            timeout++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><h3 id="重写equals-的原则"><a href="#重写equals-的原则" class="headerlink" title="重写equals()的原则"></a>重写equals()的原则</h3><blockquote>
<ol>
<li><p>对称性：如果x.equals(y) 返回是 “true”，那么 y.equals(x) 也应该返回是 “true”。</p>
</li>
<li><p>自反性：x.equals(x) 必须返回是 “true”。</p>
</li>
<li><p>传递性： 如果 x.equals(y) 返回是 “true”，而且 y.equals(z) 返回是 “true”，那么 z.equals(x) 也应该返回是 “true”。</p>
</li>
<li><p>一致性：如果 x.equals(y) 返回是 “true”，只要 x 和 y 内容一直不变，不管你重复 x.equals(y) 多少次，返回都是 “true”。</p>
</li>
<li><p>任何情况下，x.equals(null)，永远返回是 “false”。</p>
</li>
<li><p>x.equals（和 x 不同类型的对象）永远返回是 “false”。</p>
</li>
<li><p>通常情况下，重写 equals 方法，会比较类中的相应属性是否都相等</p>
</li>
</ol>
</blockquote>
<h3 id="x3D-x3D-与equals"><a href="#x3D-x3D-与equals" class="headerlink" title="&#x3D;&#x3D;与equals"></a>&#x3D;&#x3D;与equals</h3><p>**&#x3D;&#x3D;**：既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址。</p>
<p>用 “&#x3D;&#x3D;” 进行比较时，符号两边的数据类型必须兼容（可自动转换的基本数据类型除外），否则编译出错。</p>
<p>**equals()**：默认比较地址，同&#x3D;&#x3D;，java.lang.Object 的方法，可以重写。</p>
<p>注意：当用 equals( ) 方法进行比较时，对类File、String、Date及包装类等来说，<strong>这些类中重写了 Object 类的 equals() 方法，</strong>是比较类型及内容而不考虑引用的是否是同一个对象。</p>
<p>代码示例：（&#x3D;&#x3D;与equals）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 == 和 equals</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">fl</span> <span class="operator">=</span> <span class="number">65.0f</span>;</span><br><span class="line">        <span class="comment">// 自动类型转换</span></span><br><span class="line">        System.out.println(<span class="string">&quot;65 == 65.0f ：&quot;</span> + (it == fl)); <span class="comment">//true</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch2</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch3</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;65 == &#x27;A&#x27; ：&quot;</span> + (it == ch1));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;12== ch2 ：&quot;</span> + (<span class="number">12</span> == ch2));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;65== ch3 ：&quot;</span> + (it == ch3));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(ch3); <span class="comment">//A</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;str1 == str2 ：&quot;</span> + (str1 == str2));<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str1.equals(str2) ：&quot;</span> + (str1.equals(str2)));<span class="comment">//true</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;hello&quot; == new java.util.Date()); //编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 与其它类型数据进行拼接时，会自动调用对象的 toString() 方法。对于基本数据类型会调用包装类的toString()方法。</p>
<p>代码示例：（toString）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试System.out.println的细节问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line">        System.out.println(arr);  <span class="comment">// abc</span></span><br><span class="line">        System.out.println(arr.toString());  <span class="comment">// [C@2401f4c3</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        System.out.println(arr1);  <span class="comment">// [I@2401f4c3</span></span><br><span class="line">        <span class="type">double</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">double</span>[] &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span> &#125;;</span><br><span class="line">        System.out.println(arr2);  <span class="comment">// [D@7637f22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载方法 System.out.println( )</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印字符数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span> x[])</span> &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">           print(x);</span><br><span class="line">           newLine();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印字符数组：对于char数组，会将每一个字符遍历打印在控制台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span> buf[])</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">               ensureOpen();</span><br><span class="line">               textOut.write(buf);</span><br><span class="line">               textOut.flushBuffer();</span><br><span class="line">               charOut.flushBuffer();</span><br><span class="line">               <span class="keyword">if</span> (autoFlush) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buf.length; i++)</span><br><span class="line">                       <span class="keyword">if</span> (buf[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                           out.flush();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">           Thread.currentThread().interrupt();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">           trouble = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印对象：对于其他类型，会刷出到输出流里面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(x);</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">           print(s);</span><br><span class="line">           newLine();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">               ensureOpen();</span><br><span class="line">               textOut.write(s);</span><br><span class="line">               textOut.flushBuffer();</span><br><span class="line">               charOut.flushBuffer();</span><br><span class="line">               <span class="keyword">if</span> (autoFlush &amp;&amp; (s.indexOf(<span class="string">&#x27;\n&#x27;</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                   out.flush();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">           Thread.currentThread().interrupt();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">           trouble = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h1><h2 id="JDK主要包介绍"><a href="#JDK主要包介绍" class="headerlink" title="JDK主要包介绍"></a>JDK主要包介绍</h2><blockquote>
<ol>
<li>java.lang	包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能，不需要导包。</li>
<li>java.net		含执行与网络相关的操作的类和接口。</li>
<li>java.io		包含能提供多种输入&#x2F;输出功能的类。</li>
<li>java.util	包含一些实用工具类，如系统特性、接口的集合框架类、使用与日期日历相关的函数。</li>
<li>java.text	包含了一些java格式化相关的类</li>
<li>java.sql 	包含了java进行JDBC数据库编程的相关类&#x2F;接口</li>
<li>java.awt 	包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。</li>
</ol>
</blockquote>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​		针对八种基本数据类型定义相应的引用类型—包装类（封装类）有了类的特点，就可以调用类中的方法，Java才是真正的面向对象。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
</tbody></table>
<p>注意：除了 Boolean  和  Character  没有继承 Number 类，其他六种基本数据类型都继承了 Number 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;Character&gt; &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Boolean</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,                           Comparable&lt;Boolean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Integer&gt; &#123;</span><br></pre></td></tr></table></figure>

<h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h3><ul>
<li><p>装箱：将基本数据类型包装成包装类的实例。</p>
<p><strong>方式：通过包装类构造方法实现，方法参数可以为字符串。</strong></p>
</li>
<li><p>拆箱：将包装类对象中转为基本数据类型。</p>
<p><strong>方式：调用包装类的 XXX .xxxValue() 方法。</strong></p>
</li>
</ul>
<p>代码示例：（基本数据类型与包装类拆装箱）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    装箱</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="comment">//Integer j = new Integer(&quot;abc&quot;); // NumberFormatException</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    拆箱</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> i2.intValue();</span><br></pre></td></tr></table></figure>

<p>代码示例：（字符串转换成基本数据类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符串转换成基本数据类型</span></span><br><span class="line"><span class="comment">    方式：</span></span><br><span class="line"><span class="comment">    构造方法</span></span><br><span class="line"><span class="comment">    XXX.parseXXX()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;12&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;12&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    基本数据类型转换成字符串</span></span><br><span class="line"><span class="comment">    方式：</span></span><br><span class="line"><span class="comment">     String.valueOf()</span></span><br><span class="line"><span class="comment">     + 拼接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(<span class="number">12.0</span>);</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="number">12.0</span> + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="包装类的缓存问题"><a href="#包装类的缓存问题" class="headerlink" title="包装类的缓存问题"></a>包装类的缓存问题</h3><p>代码示例：（包装类的缓存）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Integer、new Integer() 和 int 的比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerWrapperTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 两个new Integer() 比较：false ，new 产生的是两个对象，内存地址不同</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">        System.out.println(i == j); <span class="comment">// false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Integer变量 和 new Integer() 变量比较 ，为 false。</span></span><br><span class="line">        <span class="comment">//因为 Integer变量 指向的是 java 常量池 中的对象，</span></span><br><span class="line">        <span class="comment">// 而 new Integer() 的变量指向堆中新建的对象，两者在内存中的地址不同。</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两个Integer 变量比较，如果两个变量的值在区间-128到127 之间，</span></span><br><span class="line">        <span class="comment">// 则比较结果为true，如果两个变量的值不在此区间，则比较结果为 false 。</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Integer内部维护了缓存池</span></span><br><span class="line"><span class="comment">         * private static class IntegerCache &#123;</span></span><br><span class="line"><span class="comment">         *         static final int low = -128;</span></span><br><span class="line"><span class="comment">         *         static final int high;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(m == n); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.println(x == y); <span class="comment">// false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//包装类Integer和基本数据类型int比较时，会自动拆包装为int ，然后进行比较</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(c == d); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项</p>
<ol>
<li><p>String类： Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</p>
</li>
<li><p>String 是一个 final 类，代表不可变的字符序列。【不可变性带来效率问题】</p>
</li>
<li><p>String 对象的字符内容是存储在一个字符数组 value[ ]中的，因此可以 string.toCharArray( ) 方法对字串进行操作。</p>
</li>
<li><p>String字面量存放在方法区的字符串常量池中。</p>
</li>
</ol>
</blockquote>
<h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><h3 id="Objects-requireNonNull-obj"><a href="#Objects-requireNonNull-obj" class="headerlink" title="Objects.requireNonNull(obj)"></a>Objects.requireNonNull(obj)</h3><p>使用Objects.requireNonNull(obj)简化非空判断；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Objects.requireNonNull(obj,&quot;参数为null&quot;)</span></span><br><span class="line"><span class="comment"> * 代替 if(obj==null)throw new NullPointerException();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">method</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="comment">// Objects.requireNonNull(obj,&quot;参数为null&quot;)</span></span><br><span class="line">    <span class="keyword">if</span>(obj==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> (T) obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h2><blockquote>
<p>异常：程序执行中发生的不正常情况称为”异常”。本身是一个类，产生异常，即创建异常并抛出异常。</p>
<p>Java程序在执行过程中所发生的异常事件可分为两类：</p>
<ul>
<li>Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。</li>
<li>Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：空指针访问，网络连接中断，试图读取不存在的文件，数组角标越界。</li>
</ul>
<p>java.lang.Throwable：Throwable类是Java语言中所有错误和异常的父类。</p>
</blockquote>
<h2 id="Error与Exception的区别"><a href="#Error与Exception的区别" class="headerlink" title="Error与Exception的区别"></a>Error与Exception的区别</h2><blockquote>
<ul>
<li>首先，Error类和Exception类都是继承Throwable类</li>
<li>Error（错误）是系统中的错误，程序员是不能改变的和处理的，是在程序编译时出现的错误，只能通过修改程序才能修正。一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。</li>
<li>Exception（异常）表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</li>
<li>Exception又分为两类：<ul>
<li>CheckedException：（编译时异常） 需要用try—catch显示的捕获，对于可恢复的异常使用CheckedException。</li>
<li>UnCheckedException（RuntimeException）：（运行时异常）不需要捕获，对于程序错误（不可恢复）的异常使用RuntimeException。</li>
</ul>
</li>
</ul>
</blockquote>
<p>代码示例：（测试error和exception）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试error和exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorAndException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 栈溢出 Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br><span class="line">        main(args);</span><br><span class="line">        <span class="comment">//堆溢出 Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line">        Integer[] integers = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译时异常和运行时异常"><a href="#编译时异常和运行时异常" class="headerlink" title="编译时异常和运行时异常"></a>编译时异常和运行时异常</h2><blockquote>
<ol>
<li><p>运行时异常</p>
<p>是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</p>
</li>
<li><p>编译时异常</p>
<p>是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。对于这类异常，如果程序不处理，可能会带来意想不到的结果。</p>
</li>
<li><p>常见异常</p>
<p>java.lang.RuntimeException<br>ClassCastException<br>ArrayIndexOutOfBoundsException<br>NullPointerException<br>ArithmeticException<br>NumberFormatException<br>InputMismatchException<br>….<br>java.io.IOExeption<br>FileNotFoundException<br>EOFException<br>java.lang.ClassNotFoundException<br>java.lang.InterruptedException<br>java.io.FileNotFoundException<br>java.sql.SQLException</p>
</li>
</ol>
</blockquote>
<h2 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h2><blockquote>
<p>注意：不要在循环中try-catch异常，发生异常时，虚拟机会创建异常类对象，应该使用tr-catch在循环外面处理异常。</p>
<p>   Java采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。</p>
<p>Java提供的是异常处理的抓抛模型。</p>
<p>   Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。</p>
</blockquote>
<p><strong>异常对象的生成：</strong></p>
<blockquote>
<p>1）由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出。</p>
<p>2）开发人员手动创建：Exception exception&#x3D;new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样。</p>
<p>如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。</p>
<p>如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。程序员通常只能处理Exception，而对Error无能为力。</p>
<p>异常处理是通过try-catch-finally语句实现的。</p>
</blockquote>
<h2 id="异常处理机制一：try-catch-finally"><a href="#异常处理机制一：try-catch-finally" class="headerlink" title="异常处理机制一：try-catch-finally"></a>异常处理机制一：try-catch-finally</h2><h3 id="try"><a href="#try" class="headerlink" title="try"></a>try</h3><p>   捕获异常的第一步是用**try{…}**语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。</p>
<h3 id="catch-Exceptiontype-e"><a href="#catch-Exceptiontype-e" class="headerlink" title="catch(Exceptiontype e)"></a>catch(Exceptiontype e)</h3><blockquote>
<p>​		在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p>
<p>如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。比如：可以用ArithmeticException类作为参数的地方，就可以用RuntimeException类作为参数，或者用所有异常的父类Exception类作为参数。但不能是与ArithmeticException类无关的异常，如NullPointerException（catch中的语句将不会执行）。</p>
<p>捕获多个异常：可以使用 |。</p>
<p>catch中的异常范围应该由小到大，如果大的异常被捕获，则后面小的更精确的异常不会再执行。</p>
</blockquote>
<h3 id="捕获异常的有关信息"><a href="#捕获异常的有关信息" class="headerlink" title="捕获异常的有关信息"></a>捕获异常的有关信息</h3><blockquote>
<p>与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。</p>
<p>getMessage()：获取异常信息，返回字符串。</p>
<p>printStackTrace()：获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。</p>
</blockquote>
<p>代码示例：（try-catch的使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试简单的try-catch:</span></span><br><span class="line"><span class="comment"> * 1. 捕获多个异常：可以使用 |</span></span><br><span class="line"><span class="comment"> * ArithmeticException | NumberFormatException exception</span></span><br><span class="line"><span class="comment"> * 2. catch中的异常范围应该由小到大，如果大的异常被捕获，则后面小的更精确的异常不会再执行</span></span><br><span class="line"><span class="comment"> * 3. e.getMessage()</span></span><br><span class="line"><span class="comment"> * exception.printStackTrace();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            String s = &quot;Hello World&quot;.split(&quot; &quot;)[2];</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;1ds&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DivisorNegativeException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a / b;</span><br><span class="line">            System.out.println(<span class="string">&quot;result &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException | NumberFormatException exception) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MathException...&quot;</span>);</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ArrayIndexOutOfBoundsException...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DivisorNegativeException divisorNegativeException) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;divisorNegativeException...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivisorNegativeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DivisorNegativeException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DivisorNegativeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DivisorNegativeException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><blockquote>
<p>捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。</p>
<ol>
<li><p>不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。可以try-finally，不需要catch。</p>
</li>
<li><p>finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</p>
</li>
<li><p>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（finally的使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试finally的使用</span></span><br><span class="line"><span class="comment"> * 像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，</span></span><br><span class="line"><span class="comment"> * 我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryFinallyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">            System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finally-x2F-return"><a href="#finally-x2F-return" class="headerlink" title="finally&#x2F;return"></a>finally&#x2F;return</h3><blockquote>
<p>finally 语句和 catch 语句是任选的。</p>
<p>在执行时，是 return 语句先把返回值写入但内存中，然后停下来等待 finally 语句块执行完，return 再执行后面的一段。</p>
<p>注意事项：</p>
<ul>
<li>对于单独的return，会结束方法，在此之前会先把finally执行结束。</li>
<li>try中如果发生了异常，try语句后面的return不会执行。</li>
<li>方法有返回值，如果finally中没有return，则catch里面必须有return，且会将值返回，或在try外面return。</li>
<li>如果try、finally和catch里面都有返回值(具体值)，则finally的返回值会覆盖。</li>
<li>对于基本数据类型，如果finally中没有return，只是简单的修改赋值，则修改的值不会返回。</li>
<li>对于引用类型：【对象地址】不会改变，但属性值可以修改。</li>
</ul>
</blockquote>
<p>代码示例：（finally和return的使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试finally和return一起使用的注意事项：</span></span><br><span class="line"><span class="comment"> * 0. 对于单独的return，会结束方法，在此之前会先把finally执行结束。</span></span><br><span class="line"><span class="comment"> * 1. try中如果发生了异常，try语句后面的return不会执行</span></span><br><span class="line"><span class="comment"> * 2. 方法又返回值，如果finally中没有return，则catch里面必须有return，且会将值返回，或在try外面return</span></span><br><span class="line"><span class="comment"> * 3. 如果try、finally和catch里面都有返回值(具体值)，则finally的返回值会覆盖其他返回值</span></span><br><span class="line"><span class="comment"> * 4. 对于基本数据类型，如果finally中没有return，只是简单的修改赋值，则修改的值不会返回</span></span><br><span class="line"><span class="comment"> * 5. 对于引用类型：【对象地址】不会改变，但属性值可以修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinallyReturnTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method();</span><br><span class="line">        <span class="comment">// try...</span></span><br><span class="line">        <span class="comment">// finally...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line">        System.out.println(methodA());</span><br><span class="line">        <span class="comment">// try...</span></span><br><span class="line">        <span class="comment">// finally...</span></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line">        System.out.println(methodB()); <span class="comment">//1</span></span><br><span class="line">        System.out.println(methodC()); <span class="comment">//d</span></span><br><span class="line">        System.out.println(methodD()); <span class="comment">//c</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于单独的return，会结束方法，在此之前会先把finally执行结束。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试try-catch-finally中包含return的情况:</span></span><br><span class="line"><span class="comment">     * 1. try中如果发生了异常，try语句后面的return不会执行</span></span><br><span class="line"><span class="comment">     * 2. 方法有返回值，如果finally中没有return，则catch里面必须有return，且会将值返回，或在try外面return</span></span><br><span class="line"><span class="comment">     * 3. 如果try、finally和catch里面都有返回值(具体值)，则finally的返回值会覆盖其他的返回值并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;try...&quot;</span>);</span><br><span class="line">            <span class="comment">// 如果发生了异常，后面的return不会执行</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch...&quot;</span>);</span><br><span class="line">            <span class="comment">// 如果finally中没有return，则catch里面必须有return，且会将值返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally...&quot;</span>);</span><br><span class="line">            <span class="comment">// 如果在catch里面返回值(具体值)，则finally的返回值会覆盖</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于基本数据类型，如果finally中没有return，只是简单的修改赋值而没有return value，则修改的值不会返回。</span></span><br><span class="line"><span class="comment">     * output: 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">1</span> / <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//return i;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于引用类型：【对象地址】不会改变，但属性值可以修改</span></span><br><span class="line"><span class="comment">     * output: d</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sb.setCharAt(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> sb;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            sb.setCharAt(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> sb;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sb.setCharAt(<span class="number">0</span>, <span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">            <span class="comment">//return sb;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output: c</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">methodD</span><span class="params">()</span> &#123;</span><br><span class="line">        StringBuffer sb;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sb = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sb;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PractiseTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">            output += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            output += <span class="string">&quot;2&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            output += <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output += <span class="string">&quot;4&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        foo(<span class="number">0</span>);</span><br><span class="line">        System.out.println(output);<span class="comment">//134</span></span><br><span class="line">        foo(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//发生异常。直接返回</span></span><br><span class="line">        System.out.println(output);<span class="comment">// 13423 output是static</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>这种写法是对try catch resource的简写。</p>
<p>try(一般是资源文件) 如果出现异常，（）里面的资源会立即关闭，<strong>其中资源应实现 Closeable 接口</strong></p>
<p>代码示例：（测试try-with-resources）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * try的方式三: try-with-resources语句</span></span><br><span class="line"><span class="comment"> * 初始化一个或多个资源，此处的资源指得是那些必须在程序结束时必须关闭的资源（比如数据库连接，网络连接等），</span></span><br><span class="line"><span class="comment"> * try语句在该语句结束时自动关闭这些资源，其中资源应实现 Closeable 接口。</span></span><br><span class="line"><span class="comment"> * 这种称为try-with-resources语句。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryWithResourcesTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>子类方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。</p>
<p>代码示例：（方法重写抛出异常）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法重写的规则之一：</span></span><br><span class="line"><span class="comment"> * 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideExceptionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(SuperClass s)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.method();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">OverrideExceptionTest</span>().display(<span class="keyword">new</span> <span class="title class_">SubClass</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;superclass...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;subclass...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常处理机制二：throws"><a href="#异常处理机制二：throws" class="headerlink" title="异常处理机制二：throws"></a>异常处理机制二：throws</h2><h3 id="声明抛出：throws"><a href="#声明抛出：throws" class="headerlink" title="声明抛出：throws"></a>声明抛出：throws</h3><blockquote>
<p>   throws XXException</p>
<ol>
<li>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</li>
<li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。可以抛出多个。</li>
</ol>
</blockquote>
<h3 id="手动抛出：throw"><a href="#手动抛出：throw" class="headerlink" title="手动抛出：throw"></a>手动抛出：throw</h3><blockquote>
<p>使用格式：throw new xxxException(args);</p>
<ul>
<li><p><strong>对于有返回值的方法，可以抛出异常而不用return。</strong></p>
</li>
<li><p>throw关键字必须写在方法的内部。</p>
</li>
<li><p>throw 后面必须是异常Exception或其子类。</p>
</li>
<li><p>throw异常后，后面的代码不会再执行。</p>
</li>
<li><p>throw会在finally之后抛出。</p>
</li>
<li><p><strong>throw 后面抛出的是RunTimeException，可以不处理，由JVM处理</strong></p>
<p> Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出。首先要</p>
</li>
</ul>
<p>生成异常类对象，然后通过throw语句实现抛出操作（提交给Java运行环境）。</p>
<p>IOException e&#x3D;new IOException();</p>
<p>throw e;</p>
<p>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误：</p>
<p>throw newString(“string exception”);</p>
</blockquote>
<p>代码示例：（测试抛出异常）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 throws 和 throw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowsAndThrowTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * throws:</span></span><br><span class="line"><span class="comment">     * 将异常交由调用放处理</span></span><br><span class="line"><span class="comment">     * 可以抛出父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methosA</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * throw</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//此处抛出异常，需要在方法也抛出异常，但RunTimeException不需要</span></span><br><span class="line">            <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//            throw new Exception();</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">            <span class="comment">//编译不通过,unreachment</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;A&quot;);</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Objects.requireNonNull(obj,&quot;参数为null&quot;)</span></span><br><span class="line"><span class="comment">     * 代替 if(obj==null)throw new NullPointerException();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">method</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="comment">// Objects.requireNonNull(obj,&quot;参数为null&quot;)</span></span><br><span class="line">        <span class="keyword">if</span>(obj==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">return</span> (T) obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><blockquote>
<ul>
<li><p>一般地，用户自定义异常类都是继承RuntimeException或者Exception的子类。</p>
</li>
<li><p>自定义异常类通常需要编写几个重载的构造器。</p>
</li>
<li><p>自定义异常需要提供serialVersionUID。</p>
</li>
<li><p>自定义的异常通过throw抛出。</p>
</li>
<li><p>自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。</p>
</li>
</ul>
</blockquote>
<p>代码示例：（测试自定义异常）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.自定义异常类通常需要编写几个重载的构造器。</span></span><br><span class="line"><span class="comment"> * 2.自定义异常需要提供serialVersionUID</span></span><br><span class="line"><span class="comment"> * 3.自定义的异常通过throw抛出。</span></span><br><span class="line"><span class="comment"> * 4.自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">766092514011636274L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常：ID不能为负</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IdNotNegativeException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">971972836047875539L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numId;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IdNotNegativeException</span><span class="params">(String message,<span class="type">int</span> numId)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.numId = numId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.numId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产生自定义异常并捕获</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyExceptionTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyExceptionTest</span>();</span><br><span class="line">        test.management(-<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">management</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            register(id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IdNotNegativeException e) &#123;</span><br><span class="line">            <span class="comment">// e.getMessage() Throwable</span></span><br><span class="line">            System.out.println(<span class="string">&quot;发生异常&quot;</span> + e.getNumId() + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> IdNotNegativeException &#123;</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IdNotNegativeException</span>(<span class="string">&quot;ID不能为负数&quot;</span>, id);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















































































































































<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程、线程、协程、调度方式"><a href="#进程、线程、协程、调度方式" class="headerlink" title="进程、线程、协程、调度方式"></a>进程、线程、协程、调度方式</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><blockquote>
<p>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</p>
<p>并发：一个CPU(采用时间片)同时执行多个任务。比如：多个人做同一件事。</p>
</blockquote>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><blockquote>
<p>进程：进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。是正在运行的程序是系统进行资源分配和调用的独立单位，每一个进程都有它自己的内存空间和系统资源。</p>
<p>线程：程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。是进程中的单个顺序控制流，是一条执行路径<strong>。多个线程的执行顺序是不固定的。</strong></p>
<p>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)。</p>
<p>单线程：一个进程如果只有一条执行路径，则称为单线程程序。</p>
<p>多线程：一个进程如果有多条执行路径，则称为多线程程序。</p>
<p><strong>进程与线程的区别：</strong></p>
<ol>
<li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位。</li>
<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。</li>
<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内线程在其他进程不可见。</li>
<li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li>
</ol>
</blockquote>
<h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><blockquote>
<ul>
<li><p>线程种调度方式</p>
<ul>
<li>分时调度模型（时间片）： 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</li>
<li>抢占式调度模型： 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。</li>
</ul>
</li>
<li><p>Java 的调度方法</p>
<ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略对高优先级，使用优先调度的抢占式策略。</li>
</ul>
</li>
</ul>
<p>线程的执行具有随机性：假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的。</p>
</blockquote>
<h2 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h2><p>​		线程的切换需要时间，对于单核CPU，不一定比多线程慢，对于多核CPU，不需要进行线程的切换，由不同的核执行，快。</p>
<h3 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h3><blockquote>
<ol>
<li>继承 Thread 类，重写 Thread 类中的 run 方法。</li>
<li>调用线程对象 start 方法启动线程，执行 run 方法。</li>
</ol>
</blockquote>
<h4 id="Thread的常用构造方法"><a href="#Thread的常用构造方法" class="headerlink" title="Thread的常用构造方法"></a>Thread的常用构造方法</h4><blockquote>
<ul>
<li>Thread()：创建新的 Thread 对象。</li>
<li>Thread(String threadname)：创建线程并指定线程实例名。</li>
<li>Thread(Runnable target)：指定创建线程的目标对象，它实现了 Runnable 接口中的 run 方法。</li>
<li>Thread(Runnable target, String name)：创建新的 Thread 对象。</li>
</ul>
</blockquote>
<h4 id="run-x2F-start"><a href="#run-x2F-start" class="headerlink" title="run() &#x2F; start()"></a>run() &#x2F; start()</h4><blockquote>
<ul>
<li>run()：封装线程执行的代码，直接调用，相当于普通方法的调用。</li>
<li>start()：启动线程；然后由JVM调用此线程的 run( ) 方法。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void  run()</td>
<td>在线程开启后，此方法将被调用执行</td>
</tr>
<tr>
<td>void  start()</td>
<td>使此线程开始执行，Java虚拟机会调用run方法()</td>
</tr>
</tbody></table>
</blockquote>
<p><strong>注意事项</strong></p>
<blockquote>
<ul>
<li>run( ) 方法由 JVM 调用，什么时候调用，执行的过程控制都有操作系统的 CPU 调度决定。</li>
<li>想要启动多线程，必须调用 start 方法。</li>
<li>一个线程对象只能调用一次 start( ) 方法启动，如果重复调用了，则将抛出异常”IllegalThreadStateException”。</li>
</ul>
</blockquote>
<p>代码示例：（继承Thread类创建多线程）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程创建方式一：继承Thread类</span></span><br><span class="line"><span class="comment"> * 1. Thread()：创建新的Thread对象。</span></span><br><span class="line"><span class="comment"> * 2. Thread(String threadName)：创建线程并指定线程实例名。</span></span><br><span class="line"><span class="comment"> * 3. Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法。</span></span><br><span class="line"><span class="comment"> * 4. Thread(Runnable target, String name)：创建新的Thread对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i += <span class="number">31</span>) &#123;</span><br><span class="line">            <span class="comment">// getName()方法属于Thread，Runnable只有一个run抽象方法</span></span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; : &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadTest</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ThreadTest</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ThreadTest2</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ThreadTest2</span>(),<span class="string">&quot;ThreadTest2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  线程创建方式二：实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTest2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i+=<span class="number">19</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;: &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h3><blockquote>
<p>定义子类，实现Runnable接口，重写Runnable接口中的run方法。</p>
<p>通过Thread类含参构造器创建线程对象。</p>
<p>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</p>
<p>调用Thread的start方法：开启线程，调用Runnable子类接口的run方法。</p>
</blockquote>
<h3 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br></pre></td></tr></table></figure>

<p><strong>实现方式的好处</strong></p>
<blockquote>
<p>避免了单继承的局限性。</p>
<p>多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。</p>
</blockquote>
<p>代码示例：（测试Runnable）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Runnable的好处：</span></span><br><span class="line"><span class="comment"> * 1. 避免单继承</span></span><br><span class="line"><span class="comment"> * 2. 多个线程可以共用一个Runnable接口</span></span><br><span class="line"><span class="comment"> * 注意：getName()可以直接在Thread类中使用，Thread.currentThread().getName()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableTest2</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTest2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableTest2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Thread类的相关方法"><a href="#Thread类的相关方法" class="headerlink" title="Thread类的相关方法"></a>Thread类的相关方法</h2><blockquote>
<ul>
<li><p>void start()：启动线程，并执行对象的run()方法。</p>
</li>
<li><p>run()：线程在被调度时执行的操作。</p>
</li>
<li><p>String getName()：返回线程的名称。</p>
</li>
<li><p>void setName(String name)：设置该线程名称。</p>
</li>
<li><p>static Thread currentThread()： 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类</p>
<p>static void yield()：线程让步暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程，若队列中没有</p>
<p>同优先级的线程，忽略此方法。</p>
</li>
<li><p>join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程</p>
<p>执行完为止，低优先级的线程也可以获得执行（在当前线程加入其他线程）。</p>
</li>
<li><p>static void sleep(long millis)：(指定时间:毫秒)令当前活动线程在指定时间段内放弃对CPU控制，使其他线程有机会被执行,时间到后重排队。抛出InterruptedException异常。</p>
</li>
<li><p>stop()：强制线程生命期结束，不推荐使用。</p>
</li>
<li><p>boolean isAlive()：返回boolean，判断线程是否还活着。</p>
</li>
<li><p>void setDaemon(boolean on)：将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出。</p>
</li>
</ul>
</blockquote>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><blockquote>
<p>线程的优先级等级</p>
<ul>
<li>MAX_PRIORITY ：10</li>
<li>MIN _PRIORITY：1</li>
<li>NORM_PRIORITY：5（默认）</li>
</ul>
<p>涉及的方法</p>
<ul>
<li><p>getPriority() ：返回线程优先值。</p>
</li>
<li><p>setPriority(int newPriority) ：改变线程的优先级。</p>
</li>
</ul>
<p>说明：</p>
<ul>
<li>线程创建时继承父线程的优先级。</li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用。</li>
</ul>
</blockquote>
<p>代码示例：（测试线程的优先级）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试线程的优先级</span></span><br><span class="line"><span class="comment"> * 线程的优先级等级</span></span><br><span class="line"><span class="comment"> * MAX_PRIORITY：10</span></span><br><span class="line"><span class="comment"> * MIN _PRIORITY：1</span></span><br><span class="line"><span class="comment"> * NORM_PRIORITY：5（默认）</span></span><br><span class="line"><span class="comment"> * 1. getPriority() ：返回线程优先值。</span></span><br><span class="line"><span class="comment"> * 2. setPriority(int newPriority) ：改变线程的优先级。</span></span><br><span class="line"><span class="comment"> * 注意:</span></span><br><span class="line"><span class="comment"> * 1.线程创建时继承父线程的优先级。</span></span><br><span class="line"><span class="comment"> * 2.低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPriorityTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPriorityTest</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPriorityTest</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;线程二&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;线程三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(thread01.getPriority());     <span class="comment">//5</span></span><br><span class="line">        System.out.println(thread02.getPriority());     <span class="comment">//5</span></span><br><span class="line">        System.out.println(thread03.getPriority());     <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.MAX_PRIORITY);    <span class="comment">//10</span></span><br><span class="line">        System.out.println(Thread.NORM_PRIORITY);   <span class="comment">//5</span></span><br><span class="line">        System.out.println(Thread.MIN_PRIORITY);    <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        thread01.setPriority(<span class="number">10</span>);       <span class="comment">//大部分优先运行结束</span></span><br><span class="line">        thread02.setPriority(<span class="number">5</span>);</span><br><span class="line">        thread03.setPriority(<span class="number">1</span>);</span><br><span class="line">        thread01.start();</span><br><span class="line">        thread02.start();</span><br><span class="line">        thread03.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()); <span class="comment">//main</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h2><blockquote>
<ol>
<li><p>Java中的线程分为两类：一种是守护线程，一种是用户线程。</p>
</li>
<li><p>它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。</p>
</li>
<li><p>守护线程是用来服务用户线程的，通过在start()方法前调用</p>
</li>
<li><p>thread.setDaemon(true) 可以把一个用户线程变成一个守护线程。</p>
</li>
<li><p>Java垃圾回收就是一个典型的守护线程。</p>
</li>
<li><p>若JVM中都是守护线程，当前JVM将退出。</p>
</li>
<li><p>一个Java程序至少有3个线程：</p>
<p>​	main</p>
<p>​	gc    回收对象等，不影响主线程main的执行</p>
<p>​	Exception 异常也是单独的一个线程</p>
<p>​	Main 线程执行的同时，也会执行垃圾回收线程</p>
</li>
</ol>
</blockquote>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><blockquote>
<p>JDK中用 Thread.State 类定义了线程的几种状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：</p>
<ol>
<li><p><strong>新建</strong>： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。</p>
</li>
<li><p><strong>就绪</strong>：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源。</p>
</li>
<li><p><strong>运行</strong>：当就绪的线程被调度并获得CPU资源时，便进入运行状态， run()方法定义了线程的操作和功能。</p>
</li>
<li><p><strong>阻塞</strong>：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态。</p>
</li>
<li><p><strong>死亡</strong>：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束。</p>
</li>
</ol>
<p><img src="/2023/02/28/JavaSE/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程的生命周期.png"></p>
</blockquote>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="售票问题"><a href="#售票问题" class="headerlink" title="售票问题"></a>售票问题</h3><p>模拟火车站售票程序，开启三个窗口售票。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安全问题出现的条件：</span></span><br><span class="line"><span class="comment"> * 1.是多线程环境</span></span><br><span class="line"><span class="comment"> * 2.有共享数据</span></span><br><span class="line"><span class="comment"> * 3.有多条语句操作共享数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WindowThread</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">window1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window, <span class="string">&quot;window1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">window2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window, <span class="string">&quot;window2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">window3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(window, <span class="string">&quot;window3&quot;</span>);</span><br><span class="line">        window1.start();</span><br><span class="line">        window2.start();</span><br><span class="line">        window3.start();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * window1正在出售票数：3</span></span><br><span class="line"><span class="comment">         * window1正在出售票数：2</span></span><br><span class="line"><span class="comment">         * window1正在出售票数：1</span></span><br><span class="line"><span class="comment">         * window2正在出售票数：37</span></span><br><span class="line"><span class="comment">         * window3正在出售票数：29</span></span><br><span class="line"><span class="comment">         * window3正在出售票数：-1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 使用Runnable不需要声明属性static，被多个线程共享</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;, 正在出售票数：&quot;</span> + tickets);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据安全问题"><a href="#数据安全问题" class="headerlink" title="数据安全问题"></a>数据安全问题</h3><blockquote>
<p><strong>问题的原因：</strong></p>
<p>当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。</p>
<p><strong>问题出现的条件：</strong></p>
<ul>
<li>是多线程环境</li>
<li>有共享数据</li>
<li>有多条语句操作共享数据</li>
</ul>
<p>解决方案： 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可。</p>
</blockquote>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>线程同步有三种方式：同步代码块、同步方法、Lock。</p>
<h4 id="同步的范围和利弊"><a href="#同步的范围和利弊" class="headerlink" title="同步的范围和利弊"></a>同步的范围和利弊</h4><blockquote>
<p>范围太小：没锁住所有有安全问题的代码，范围太大：没发挥多线程的功能。</p>
<p>好处：解决了多线程的数据安全问题。</p>
<p>弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</p>
<p>只同步共享数据的操作代码块。</p>
</blockquote>
<h4 id="同步锁：-同步机制中的锁"><a href="#同步锁：-同步机制中的锁" class="headerlink" title="同步锁： 同步机制中的锁"></a>同步锁： 同步机制中的锁</h4><blockquote>
<p>Thinking in Java：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法：就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。</p>
</blockquote>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="JUC简介"><a href="#JUC简介" class="headerlink" title="JUC简介"></a>JUC简介</h3><h3 id="volatile关键字：内存可见性"><a href="#volatile关键字：内存可见性" class="headerlink" title="volatile关键字：内存可见性"></a>volatile关键字：内存可见性</h3><p>问题示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.thread.juc.volatiletest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(t1).start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t1.isFlag()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;flag: &quot;</span> + isFlag());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>flag: true</p>
<p>并没有打印 ———-main———-</p>
<p>原因：</p>
<ol>
<li><p><strong>JVM对于每个线程，都会分配一份独立的缓存用于操作数据，真正的共享数据位于主存中，每一个线程操作数据时会从主存中取出数据放入自己的缓存，修改完成后，再将缓存中的数据刷新到主存。main线程通过 while(true) 不断读取数据，实际读取的是第一次放入自己缓存的数据，从而引发了【内存可见性】的问题。</strong></p>
</li>
<li><p><strong>内存可见性：多个线程操作共享数据时，彼此不可见</strong></p>
<p>（1）<strong>使用volatile解决内存可见性问题，使用volatile后，系统的内存栅栏会时刻的将线程缓存的数据刷新到主存，可以认为多个线程直接操作的是主存的数据。</strong></p>
<p>（2）<strong>但是，volatile不具有互斥性，即当前线程访问共享数据时，其他线程依然可以访问；同时volatile不能保证原子性。</strong></p>
</li>
</ol>
<p>解决方案：</p>
<ol>
<li><p>加锁，保证线程每次都从主存中读取数据，但效率太低。</p>
<p>其他线程没有获取到锁，就会阻塞，重新等待CPU分配时间片，效率低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (t1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1.isFlag()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用volatile关键字修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>———-main———-<br>flag: true</p>
</li>
</ol>
<h3 id="原子变量与CAS算法"><a href="#原子变量与CAS算法" class="headerlink" title="原子变量与CAS算法"></a>原子变量与CAS算法</h3><p>问题示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicDemo</span> <span class="variable">atomicDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(atomicDemo).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">serialNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSerialNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>Thread-1 : 0<br>Thread-0 : 0<br>Thread-3 : 1<br>Thread-2 : 1<br>Thread-9 : 2<br>Thread-8 : 3<br>Thread-7 : 4<br>Thread-6 : 5<br>Thread-5 : 6<br>Thread-4 : 7</p>
<p>问题原因：</p>
<p><strong>i++ 的原子性问题</strong></p>
<p>i++的操作实际分为三步：读 改 写</p>
<p>int i &#x3D; 10;</p>
<p>i &#x3D; i++;</p>
<p>相当于三步：</p>
<p>int temp &#x3D; i;</p>
<p>i &#x3D; i + 1;</p>
<p>i &#x3D; temp;</p>
<p>原子变量：</p>
<p>jdk1.5后 java.concurrent.atomic 包下提供了原子变量</p>
<p>其中所有的变量使用 volatile 修饰，保证内存可见性。</p>
<p>通过 CAS （Compare And Swap）算法保证数据的原子性，CAS是硬件对于并发操作共享数据的支持，JVM 同样也做了支持。</p>
<p>CAS 包含三个操作数：内存值 V，预估值 A，更新值 B，当且仅当 V&#x3D;&#x3D;A 时，V &#x3D; B，否则不作任何操作。</p>
<p>步骤说明：</p>
<p>如两个线程执行 serialNumber++ 操作：</p>
<p>serialNumber初始值为0，两个线程都将主存中的数据拷贝至当前线程的缓存，此时内存值为 0，线程一修改主存值时，得到预估值为 0，修改值为 1，此时 V&#x3D;&#x3D;A，进行修改没有问题；但线程二获取的内存值为0，预估值 A&#x3D;1，更新值为 1，此时 V!&#x3D;A，不进行更新，以此保证原子性，有且仅有一个线程更新成功。</p>
<p>CAS算法效率比锁的效率高，因为不会放弃CPU给的执行权，不会阻塞，而是再次尝试更新。缺点可以说是代码写的多。</p>
<p><strong>CAS无锁，不会阻塞，没有上下文切换问题。</strong></p>
<p>问题解决：使用原子变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicDemo</span> <span class="variable">atomicDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(atomicDemo).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private volatile int serialNumber = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">serialNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSerialNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>Thread-0 : 0<br>Thread-6 : 1<br>Thread-5 : 2<br>Thread-4 : 3<br>Thread-3 : 4<br>Thread-2 : 5<br>Thread-1 : 6<br>Thread-7 : 7<br>Thread-9 : 8<br>Thread-8 : 9</p>
<p>volatile 不能保证互斥性，多个线程可以同时操作数据，不能保证原子性。</p>
<p>模拟CAS算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.thread.juc.atomic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟CAS算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareAndSwapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CompareAndSwap</span> <span class="variable">cas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompareAndSwap</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">expectedValue</span> <span class="operator">=</span> cas.getValue();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> cas.compareAndSet(expectedValue, (<span class="type">int</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;result: &quot;</span> + result);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompareAndSwap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">compareAndSwap</span><span class="params">(<span class="type">int</span> expectedValue, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">        <span class="comment">//模拟从内存中取值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldValue</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">if</span> (expectedValue == oldValue) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expectedValue, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expectedValue == compareAndSwap(expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap锁分段机制"><a href="#ConcurrentHashMap锁分段机制" class="headerlink" title="ConcurrentHashMap锁分段机制"></a>ConcurrentHashMap锁分段机制</h3><p>Hashtable的问题：</p>
<ol>
<li>单独方法加锁，效率低</li>
<li>复合操作仍然是线程不安全的，如不存在则添加操作。</li>
</ol>
<p>Java8以后，ConcurrentHashMap采用CAS代替，不再使用分段锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.thread.juc.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CopyOnWriteArrayList/Set</span></span><br><span class="line"><span class="comment"> * 写时复制，避免了并发修改问题，但是写入数据时会复制一份List/Set，效率低</span></span><br><span class="line"><span class="comment"> * 适合于多读少些，但又有并发修改需求的场景</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CopyOnWriteArrayListDemo</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayListDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(thread).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayListDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 使用Collections包装为同步List</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list =</span><br><span class="line">            Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            <span class="comment">//迭代时添加数据会报java.util.ConcurrentModificationException</span></span><br><span class="line">            list.add(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>使用 CopyOnWriteArrayList 代替 List</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h3 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h3><h4 id="CountDownLatch闭锁"><a href="#CountDownLatch闭锁" class="headerlink" title="CountDownLatch闭锁"></a>CountDownLatch闭锁</h4><p>同步辅助类</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.thread.juc.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CountDownLatch：</span></span><br><span class="line"><span class="comment"> * 闭锁，在完成某些运算时，只有其他线程的运算全部完成，当前运算才继续执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(count);</span><br><span class="line">        <span class="type">CountDownLatchThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatchThread</span>(countDownLatch);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(thread).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Times: &quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountDownLatchThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountDownLatchThread</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 必须执行，否则阻塞</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CyclicBarrier循环栅栏"><a href="#CyclicBarrier循环栅栏" class="headerlink" title="CyclicBarrier循环栅栏"></a>CyclicBarrier循环栅栏</h4><h4 id="Semaphore信号灯"><a href="#Semaphore信号灯" class="headerlink" title="Semaphore信号灯"></a>Semaphore信号灯</h4><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><h3 id="Lock同步锁"><a href="#Lock同步锁" class="headerlink" title="Lock同步锁"></a>Lock同步锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.thread.juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(t, i + <span class="string">&quot;号窗口&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock(); <span class="comment">//上锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + (--tickets));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">//必须释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p>通过wait()和notifyAll()控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.thread.juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者消费者案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerAndConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer, <span class="string">&quot;生产者一&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer, <span class="string">&quot;消费者一&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进货</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (product &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;产品已满&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + (++product));</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖货</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (product &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;缺货&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + (--product));</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            clerk.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            clerk.sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在问题：</p>
<p>修改product&gt;&#x3D;1，延长时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.thread.juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者消费者案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerAndConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer, <span class="string">&quot;生产者一&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer, <span class="string">&quot;消费者一&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进货</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (product &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;产品已满&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + (++product));</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖货</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (product &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;缺货&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + (--product));</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>线程阻塞，程序无法结束</p>
<p>生产者一 : 1<br>消费者一 : 0<br>缺货<br>生产者一 : 1<br>消费者一 : 0<br>缺货<br>生产者一 : 1<br>消费者一 : 0<br>缺货<br>生产者一 : 1<br>产品已满<br>消费者一 : 0</p>
<p>原因：虚假唤醒</p>
<p>当sale()方法循环次数只剩一次，get()方法循环次数只剩二次，product&#x3D;0时：</p>
<p>sale()方法先执行，之后wait()，此时生产者拿到锁资源，循环一次，++prodcut，之后notifyAll() ，消费者拿到锁资源，wait()结束，循环次数结束，此时生产者拿到锁资源，此时product&#x3D;&#x3D;1，wait()之后，便没有人唤醒，程序便不会终止。</p>
<p>解决方式：去掉 else 判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.thread.juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者消费者案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerAndConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer, <span class="string">&quot;生产者一&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer, <span class="string">&quot;消费者一&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进货</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (product &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;产品已满&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + (++product));</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖货</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (product &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;缺货&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + (--product));</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时程序正常执行结束，但是再增加消费者和生产者时，出现问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer, <span class="string">&quot;生产者一&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer, <span class="string">&quot;消费者一&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer, <span class="string">&quot;生产者二&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer, <span class="string">&quot;消费者二&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer, <span class="string">&quot;生产者三&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer, <span class="string">&quot;消费者三&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>生产者一 : 1<br>产品已满<br>消费者一 : 0<br>消费者三 : -1<br>生产者二 : 0<br>生产者一 : 1</p>
<p>原因：</p>
<p>如第一个消费者抢到资源，阻塞在 wait() 方法处，第二个消费者又抢到资源，阻塞在 wait() 方法处，此时生产者 notiyfAll() ，两个消费者同时执行 –product 便会出负值。</p>
<p>解决方式：使用while代替if</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>

<p>导致当前线程等待，直到另一个线程调用该对象的<a href="../../java/lang/Object.html#notify--"><code>notify()</code></a>方法或<a href="../../java/lang/Object.html#notifyAll--"><code>notifyAll()</code></a>方法。换句话说，这个方法的行为就好像简单地执行呼叫<code>wait(0)</code> 。</p>
<p>当前的线程必须拥有该对象的显示器。  该线程释放此监视器的所有权，并等待另一个线程通知等待该对象监视器的线程通过调用<code>notify</code>方法或<code>notifyAll</code>方法<code>notifyAll</code>  。 然后线程等待，直到它可以重新获得监视器的所有权并恢复执行。 </p>
<p>像在一个参数版本中，中断和虚假唤醒是可能的，并且该方法应该始终在循环中使用： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">       <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">           obj.wait();</span><br><span class="line">       ... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>

<p>该方法只能由作为该对象的监视器的所有者的线程调用。 </p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.thread.juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者消费者案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerAndConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer, <span class="string">&quot;生产者一&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer, <span class="string">&quot;消费者一&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer, <span class="string">&quot;生产者二&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer, <span class="string">&quot;消费者二&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer, <span class="string">&quot;生产者三&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer, <span class="string">&quot;消费者三&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进货</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (product &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;产品已满&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + (++product));</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖货</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (product &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;缺货&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + (--product));</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Condition控制线程通信"><a href="#Condition控制线程通信" class="headerlink" title="Condition控制线程通信"></a>Condition控制线程通信</h3><h3 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h3><h3 id="线程按序交替执行"><a href="#线程按序交替执行" class="headerlink" title="线程按序交替执行"></a>线程按序交替执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.thread.juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三个线程交替打印ABC，示例：AABBBCCCCAABBBCCCC...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlternatePrintABCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AlternatePrintABC</span> <span class="variable">alternatePrintABC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlternatePrintABC</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                alternatePrintABC.loopA(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                alternatePrintABC.loopB(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                alternatePrintABC.loopC(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlternatePrintABC</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//线程标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loopA</span><span class="params">(<span class="type">int</span> loop)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i + <span class="string">&quot;\t&quot;</span> + loop);</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loopB</span><span class="params">(<span class="type">int</span> loop)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i + <span class="string">&quot;\t&quot;</span> + loop);</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loopC</span><span class="params">(<span class="type">int</span> loop)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i + <span class="string">&quot;\t&quot;</span> + loop);</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h3><h3 id="线程八锁-1"><a href="#线程八锁-1" class="headerlink" title="线程八锁"></a>线程八锁</h3><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.thread.juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非静态方法的锁this，静态方法的锁为对应的Class实例</span></span><br><span class="line"><span class="comment"> * 同一时刻，只能有一个线程持有锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread8MonitorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printA()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printB()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 两个普通同步方法，两个线程，输出A B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2. 新增Thread.sleep()方法给printA()，输出 A B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread8MonitorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printA()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printB()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. 新增普通方法printC()，输出 C A B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread8MonitorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printA()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printB()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printC()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4. 两个T对象，第一个对象调用printA()方法，第二个调用printB()方法，输出B C A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread8MonitorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printA()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t2.printB()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printC()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第五种"><a href="#第五种" class="headerlink" title="第五种"></a>第五种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5. 修改printA()为静态方法，同一个T对象，输出B A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread8MonitorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printA()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printB()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第六种"><a href="#第六种" class="headerlink" title="第六种"></a>第六种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 6. 修改printA()和printB()都为静态方法，同一个T对象，输出A B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread8MonitorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printA()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printB()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第七种"><a href="#第七种" class="headerlink" title="第七种"></a>第七种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 7. 修改printA()为静态方法,printB()为非静态方法，两个T对象，输出 B A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread8MonitorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printA()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t2.printB()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第八种"><a href="#第八种" class="headerlink" title="第八种"></a>第八种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8. 修改printA()和printB()都为静态方法，两个T对象，输出A B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread8MonitorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t.printA()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t2.printB()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>提供了一组线程队列，保存着所有等待状态的线程，避免了线程的创建与销毁额外开销，提高了响应的速度。</p>
<p>体系结构：</p>
<p>java.util.concurrent.Executor：线程使用与调度的总接口</p>
<p>​		|–**ExecutorService子接口：线程池的主要接口</p>
<p>​				|–ThreadPoolExecutor：线程池的实现类</p>
<p>​				|–ScheduledExecutorService：线程调度（延时或定时执行）接口</p>
<p>​						|–ScheduledThreadPoolExecutor：继承ThreadPoolExecutor</p>
<p>工具类：Executors</p>
<p>ExecutorService newFixedThreadPool()：创建固定大小的线程池</p>
<p>ExecutorService newCachedThreadPool()：创建可变大小的线程池</p>
<p>ExecutorService newSingleThreadExecutor()：创建单一大小的线程池</p>
<p>ScheduledExecutorService newScheduledThreadPool()：创建固定大小的线程，可以延时或定时执行任务</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h3 id="ForkJoinPool分支、合并框架"><a href="#ForkJoinPool分支、合并框架" class="headerlink" title="ForkJoinPool分支、合并框架"></a>ForkJoinPool分支、合并框架</h3><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><blockquote>
<p><strong>File类介绍</strong></p>
<p>它是文件和目录路径名的抽象表示，文件和目录是可以通过File封装成对象的 对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的。</p>
<p><strong>File****的注意事项：</strong></p>
<ol>
<li><p>路径中的每级目录之间用一个路径分隔符隔开。</p>
</li>
<li><p>路径分隔符和系统有关：windows和DOS系统默认使用”&quot;来表示，UNIX和URL使用”&#x2F;“来表示。</p>
</li>
<li><p>Java程序支持跨平台运行，因此路径分隔符要慎用。为了解决这个隐患，File类提供了一个常量：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String separator;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>根据操作系统，动态的提供分隔符。</p>
<ol start="4">
<li>Java中的删除不走回收站。 要删除一个文件目录，请注意该目录内不能包含文件或者文件目录。</li>
</ol>
<p><strong>File类的构造方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>File(String pathname)</td>
<td>通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例</td>
</tr>
<tr>
<td>File(String parent, String child)</td>
<td>从父路径名字符串和子路径名字符串创建新的 File实例</td>
</tr>
<tr>
<td>File(File parent, String child)</td>
<td>从父抽象路径名和子路径名字符串创建新的 File实例</td>
</tr>
</tbody></table>
</blockquote>
<p>代码示例：（<strong>file构造方法</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * File的构造方法：</span></span><br><span class="line"><span class="comment"> * File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例</span></span><br><span class="line"><span class="comment"> * File(String parent, String child) 从父路径名字符串和子路径名字符串创建新的 File实例</span></span><br><span class="line"><span class="comment"> * File(File parent, String child) 从父抽象路径名和子路径名字符串创建新的 File实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileConstructorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//E:\idea-workspace\Basic\JavaBasicLearn\java.txt</span></span><br><span class="line">        System.out.println(file.getAbsolutePath());</span><br><span class="line">        <span class="comment">//E:\idea-workspace\Basic\JavaBasicLearn\src\java.txt</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/java.txt&quot;</span>);</span><br><span class="line">        System.out.println(file1.getAbsolutePath());</span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\idea-workspace\\Basic\\JavaBasicLearn&quot;</span>, <span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">        System.out.println(file2);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\idea-workspace\\Basic\\JavaBasicLearn&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file3, <span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">        System.out.println(file4);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            file = <span class="keyword">new</span> <span class="title class_">File</span>(i + <span class="string">&quot;.downloading&quot;</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newFile</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line">            System.out.println(newFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>File类相关方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean createNewFile()</td>
<td>当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空的文件，若文件存在则返回false</td>
</tr>
<tr>
<td>public boolean mkdir()</td>
<td>创建此抽象路径名命名的目录。创建多级目录返回false</td>
</tr>
<tr>
<td>public boolean mkdirs()</td>
<td>创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录，创建多级目录</td>
</tr>
<tr>
<td>方法名</td>
<td>说明</td>
</tr>
<tr>
<td>public boolean isDirectory()</td>
<td>测试此抽象路径名表示的File是否为目录</td>
</tr>
<tr>
<td>public boolean isFile()</td>
<td>测试此抽象路径名表示的File是否为文件</td>
</tr>
<tr>
<td>public boolean exists()</td>
<td>测试此抽象路径名表示的File是否存在</td>
</tr>
<tr>
<td>public String getAbsolutePath()</td>
<td>返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>将此抽象路径名转换为路径名字符串</td>
</tr>
<tr>
<td>public String getName()</td>
<td>返回由此抽象路径名表示的文件或目录的名称</td>
</tr>
<tr>
<td>public String[] list()</td>
<td>返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</td>
</tr>
<tr>
<td>public File[] listFiles()</td>
<td>返回此抽象路径名表示的目录中的文件和目录的File对象数组</td>
</tr>
<tr>
<td>public boolean delete()</td>
<td>删除由此抽象路径名表示的文件或目录</td>
</tr>
</tbody></table>
<p>代码示例：（FilenameFilter的使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目录列表:正则过滤</span></span><br><span class="line"><span class="comment"> *        使用策略模式，提供行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilenameFileterTest</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">      <span class="type">File</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\idea-workspace\\Basic\\JavaBasicLearn&quot;</span>);</span><br><span class="line">      String[] list;</span><br><span class="line">      <span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;.*.txt&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span>(reg.length()==<span class="number">0</span>)</span><br><span class="line">         list = path.list();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         list = path.list(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(reg);</span><br><span class="line">            <span class="comment">// 此处使用策略模式</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">      Arrays.sort(list,String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">      <span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">         System.out.println(string);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（<strong>File类相关方法</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.io.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * File常用方法</span></span><br><span class="line"><span class="comment"> * public boolean createNewFile() 当文件不存在时，创建新的空文件，若文件存在则返回false</span></span><br><span class="line"><span class="comment"> * public boolean mkdir() 创建此抽象路径名命名的目录。创建多级目录返回false</span></span><br><span class="line"><span class="comment"> * public boolean mkdirs() 创建由此抽象路径名命名的目录，创建多级目录</span></span><br><span class="line"><span class="comment"> * public boolean isDirectory()    测试此抽象路径名表示的File是否为目录</span></span><br><span class="line"><span class="comment"> * public boolean isFile() 测试此抽象路径名表示的File是否为文件</span></span><br><span class="line"><span class="comment"> * public boolean exists() 测试此抽象路径名表示的File是否存在</span></span><br><span class="line"><span class="comment"> * public String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串</span></span><br><span class="line"><span class="comment"> * public String getPath() 将此抽象路径名转换为路径名字符串</span></span><br><span class="line"><span class="comment"> * public String getName() 返回由此抽象路径名表示的文件或目录的名称</span></span><br><span class="line"><span class="comment"> * public String[] list()  返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</span></span><br><span class="line"><span class="comment"> * public File[] listFiles()   返回此抽象路径名表示的目录中的文件和目录的File对象数组</span></span><br><span class="line"><span class="comment"> * public boolean delete() 删除由此抽象路径名表示的文件或目录</span></span><br><span class="line"><span class="comment"> * long lastModified() 返回此抽象路径名表示的文件上次修改的时间。</span></span><br><span class="line"><span class="comment"> * long length() 返回由此抽象路径名表示的文件的长度。</span></span><br><span class="line"><span class="comment"> * boolean renameTo(File dest) 重命名由此抽象路径名表示的文件。</span></span><br><span class="line"><span class="comment"> * String getName() 返回由此抽象路径名表示的文件或目录的名称。</span></span><br><span class="line"><span class="comment"> * String getParent() 返回此抽象路径名的父 null的路径名字符串，如果此路径名未命名为父目录，则返回null。</span></span><br><span class="line"><span class="comment"> * File getParentFile() 返回此抽象路径名的父，或抽象路径名 null如果此路径名没有指定父目录。</span></span><br><span class="line"><span class="comment"> * boolean setReadable(boolean readable) 一种方便的方法来设置所有者对此抽象路径名的读取权限。</span></span><br><span class="line"><span class="comment"> * boolean setReadable(boolean readable, boolean ownerOnly) 设置此抽象路径名的所有者或每个人的读取权限。</span></span><br><span class="line"><span class="comment"> * boolean setReadOnly() 标记由此抽象路径名命名的文件或目录，以便只允许读取操作。</span></span><br><span class="line"><span class="comment"> * boolean setWritable(boolean writable) 一种方便的方法来设置所有者对此抽象路径名的写入权限。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileMethodTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。</span></span><br><span class="line"><span class="comment">     * 说明：程序的运行实在bin目录中，加载class,因此建议不要将文件写在src下面，项目打包没有src</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 相对路径的写法：不建议</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;javatest.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src\\javatest.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src\\com\\example\\io\\file\\text-file.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">        System.out.println(f3.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. &quot;/&quot; 代表bin目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">f4</span> <span class="operator">=</span> FileMethodTest.class.getResource(<span class="string">&quot;/test.txt&quot;</span>).getFile();</span><br><span class="line">        <span class="type">String</span> <span class="variable">f6</span> <span class="operator">=</span> FileMethodTest.class.getClassLoader().getResource(<span class="string">&quot;/test.txt&quot;</span>).getFile();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">File</span>(f4).getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">File</span>(f6).getAbsolutePath());</span><br><span class="line">        <span class="comment">// 3. &quot; &quot; 代表bin目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">f5</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;test.txt&quot;</span>).getFile();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">File</span>(f5).getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * boolean exists() 测试此抽象路径名表示的文件或目录是否存在。</span></span><br><span class="line"><span class="comment">     * String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串。</span></span><br><span class="line"><span class="comment">     * long getFreeSpace() 返回分区未分配的字节数 named此抽象路径名。</span></span><br><span class="line"><span class="comment">     * String getName() 返回由此抽象路径名表示的文件或目录的名称。</span></span><br><span class="line"><span class="comment">     * String getParent() 返回此抽象路径名的父 null的路径名字符串，如果此路径名未命名为父目录，则返回null。</span></span><br><span class="line"><span class="comment">     * boolean isDirectory() 测试此抽象路径名表示的文件是否为目录。</span></span><br><span class="line"><span class="comment">     * boolean isFile() 测试此抽象路径名表示的文件是否为普通文件。</span></span><br><span class="line"><span class="comment">     * boolean isHidden() 测试此抽象路径名命名的文件是否为隐藏文件。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\idea-workspace\\Basic\\JavaBasicLearn\\some.txt&quot;</span>);</span><br><span class="line">        f1.createNewFile();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> f1.exists();</span><br><span class="line">        System.out.println(exists); <span class="comment">//true</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">absolutePath</span> <span class="operator">=</span> f1.getAbsolutePath();</span><br><span class="line">        System.out.println(absolutePath); <span class="comment">//E:\idea-workspace\Basic\JavaBasicLearn\some.txt</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> f1.getName();</span><br><span class="line">        System.out.println(name); <span class="comment">//some.txt</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hidden</span> <span class="operator">=</span> f1.isHidden();</span><br><span class="line">        System.out.println(hidden); <span class="comment">//false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">file</span> <span class="operator">=</span> f1.isFile();</span><br><span class="line">        System.out.println(file); <span class="comment">//true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">dir</span> <span class="operator">=</span> f1.isDirectory();</span><br><span class="line">        System.out.println(dir); <span class="comment">//false</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> f1.getParent();</span><br><span class="line">        System.out.println(parent); <span class="comment">//E:\idea-workspace\Basic\JavaBasicLearn</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">freeSpace</span> <span class="operator">=</span> f1.getFreeSpace();</span><br><span class="line">        System.out.println(freeSpace/<span class="number">1024</span>/<span class="number">1024</span>); <span class="comment">//3289</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  boolean createNewFile() 当且仅当具有该名称的文件尚不存在时，创建一个由该抽象路径名命名的新的空文件。</span></span><br><span class="line"><span class="comment">     *  boolean delete() 删除由此抽象路径名表示的文件或目录。</span></span><br><span class="line"><span class="comment">     *  boolean mkdir() 创建由此抽象路径名命名的目录。</span></span><br><span class="line"><span class="comment">     * boolean mkdirs() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录。</span></span><br><span class="line"><span class="comment">     *     说明：</span></span><br><span class="line"><span class="comment">     *        mkdir()：只能创建一个目录</span></span><br><span class="line"><span class="comment">     *     mkdirs():可以创建多级目录</span></span><br><span class="line"><span class="comment">     *     file.delete():只能删除单个文件，不能删除目录，如果目录为空，则可以删除目录</span></span><br><span class="line"><span class="comment">     *     createNewFile():文件可以没有后缀名，只能创建一次，不能创建多次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\idea-workspace\\Basic\\JavaBasicLearn\\mkdir\\dir1\\dir2&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">mkdir</span> <span class="operator">=</span> f1.mkdir();</span><br><span class="line">        System.out.println(mkdir); <span class="comment">//false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">mkdirs</span> <span class="operator">=</span> f1.mkdirs();</span><br><span class="line">        System.out.println(mkdirs); <span class="comment">//true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">renameTo</span> <span class="operator">=</span> f1.renameTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\idea-workspace\\Basic\\JavaBasicLearn\\testdir\\mkdir\\dir3\\dir2&quot;</span>));</span><br><span class="line">        System.out.println(renameTo);</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\idea-workspace\\Basic\\JavaBasicLearn\\testdir\\dir\\inner&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">delete</span> <span class="operator">=</span> f2.delete();</span><br><span class="line">        System.out.println(delete);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">createNewFile</span> <span class="operator">=</span> f2.createNewFile();</span><br><span class="line">            System.out.println(createNewFile);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">createAgain</span> <span class="operator">=</span> f2.createNewFile();</span><br><span class="line">            System.out.println(createAgain); <span class="comment">//false</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * long lastModified() 返回此抽象路径名表示的文件上次修改的时间。</span></span><br><span class="line"><span class="comment">     * long length() 返回由此抽象路径名表示的文件的长度。</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     *        length(): 对于文件夹，大小为0</span></span><br><span class="line"><span class="comment">     *        lastModified():仅仅以当前系统的时间作为修改时间，无法做到时间的统一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src\\com\\example\\io\\file\\txt_file.txt&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newFile</span> <span class="operator">=</span> f1.createNewFile();</span><br><span class="line">        <span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> f1.length();</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestramp</span> <span class="operator">=</span> f1.lastModified();</span><br><span class="line">        System.out.println(length);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(timestramp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * boolean renameTo(File dest) 重命名由此抽象路径名表示的文件。</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     *        1. 对文件进行重新命名：</span></span><br><span class="line"><span class="comment">     *              只能对文件进行重新命名</span></span><br><span class="line"><span class="comment">     *        2. 对目录进行重新命名</span></span><br><span class="line"><span class="comment">     *              只能对单级目录进行命名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//        E:\idea-workspace\Basic\JavaBasicLearn\testdir\a\b\a.txt</span></span><br><span class="line"><span class="comment">//        E:\idea-workspace\Basic\JavaBasicLearn\testdir\c\b\a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        File f1 = new File(&quot;E:\\idea-workspace\\Basic\\JavaBasicLearn\\testdir\\a\\b&quot;);</span></span><br><span class="line"><span class="comment">//        File f2 = new File(&quot;E:\\idea-workspace\\Basic\\JavaBasicLearn\\testdir\\a\\d&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(f1.renameTo(f2));</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  String[] list() 返回一个字符串数组，命名由此抽象路径名表示的目录中的文件和目录。</span></span><br><span class="line"><span class="comment">     * String[] list(FilenameFilter filter) 返回一个字符串数组，命名由此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></span><br><span class="line"><span class="comment">     * File[] listFiles() 返回一个抽象路径名数组，表示由该抽象路径名表示的目录中的文件。</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     *    file.list():返回null</span></span><br><span class="line"><span class="comment">     *    dir.list():返回[]</span></span><br><span class="line"><span class="comment">     *    file.listFiles():返回null</span></span><br><span class="line"><span class="comment">     *    dir.listFiles():返回[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dirEmpty1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\idea-workspace\\Basic\\JavaBasicLearn\\testdir\\dir&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">dirEmpty2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\idea-workspace\\Basic\\JavaBasicLearn\\testdir&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\idea-workspace\\Basic\\JavaBasicLearn\\testdir\\some.txt&quot;</span>);</span><br><span class="line">        String[] list1 = f1.list();</span><br><span class="line">        String[] list2 = dirEmpty1.list();</span><br><span class="line">        System.out.println(list1); <span class="comment">//null</span></span><br><span class="line">        System.out.println(Arrays.toString(list2)); <span class="comment">//[Ljava.lang.String;@3b2da18f  []</span></span><br><span class="line">        <span class="keyword">for</span>(String path : dirEmpty1.list()) &#123; <span class="comment">//nothing</span></span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String path : dirEmpty2.list()) &#123;</span><br><span class="line"><span class="comment">//       dir</span></span><br><span class="line"><span class="comment">//       some.txt</span></span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// f1.list()的返回值为null,不能调用迭代器</span></span><br><span class="line">        <span class="comment">// java.lang.NullPointerException: Cannot read the array length because the return value of &quot;java.io.File.list()&quot; is null</span></span><br><span class="line"><span class="comment">//    for(String path : f1.list()) &#123;</span></span><br><span class="line"><span class="comment">//       System.out.println(path);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">        File[] fls = f1.listFiles();</span><br><span class="line">        File[] dirls = dirEmpty1.listFiles();</span><br><span class="line"></span><br><span class="line">        System.out.println(fls); <span class="comment">// null</span></span><br><span class="line">        System.out.println(Arrays.toString(dirls)); <span class="comment">//[]</span></span><br><span class="line">        <span class="keyword">for</span>(File file : dirEmpty1.listFiles()) &#123; <span class="comment">// nothing</span></span><br><span class="line">            System.out.println(file.getAbsolutePath()+<span class="string">&quot;:&quot;</span>+file.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(File file : dirEmpty2.listFiles()) &#123;</span><br><span class="line"><span class="comment">//       F:\LF\eclipse-workspace\testdir\dir:dir</span></span><br><span class="line"><span class="comment">//       F:\LF\eclipse-workspace\testdir\some.txt:some.txt</span></span><br><span class="line">            System.out.println(file.getAbsolutePath()+<span class="string">&quot;:&quot;</span>+file.getName());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//    for(File file : f1.listFiles()) &#123;</span></span><br><span class="line"><span class="comment">//       System.out.println(file.getAbsolutePath()+&quot;:&quot;+file.getName()); //nothing</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String编码解码"><a href="#String编码解码" class="headerlink" title="String编码解码"></a>String编码解码</h2><p><strong>常见的编码表</strong></p>
<blockquote>
<ul>
<li>ASCII：美国标准信息交换码。用一个字节的7位可以表示。</li>
<li>ISO8859-1：拉丁码表。欧洲码表。用一个字节的8位表示。</li>
<li>GB2312：中国的中文编码表。最多两个字节编码所有字符。</li>
<li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码。</li>
<li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li>
<li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。中文三个字节，英文字母1个字节。</li>
</ul>
</blockquote>
<p><strong>字符编码</strong></p>
<blockquote>
<ol>
<li><p>Unicode不完美，这里就有三个问题，一个是，我们已经知道，英文字母只用一个字节表示就够了，第二个问题是如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现。</p>
</li>
<li><p>面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</p>
</li>
<li><p>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。</p>
</li>
</ol>
</blockquote>
<p> <strong>字符串中的编码解码问题</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>byte[] getBytes()</td>
<td>使用平台的默认字符集将该 String编码为一系列字节</td>
</tr>
<tr>
<td>byte[]  getBytes(String charsetName)</td>
<td>使用指定的字符集将该 String编码为一系列字节</td>
</tr>
<tr>
<td>String(byte[] bytes)</td>
<td>使用平台的默认字符集解码指定的字节数组来创建字符串</td>
</tr>
<tr>
<td>String(byte[] bytes, String  charsetName)</td>
<td>通过指定的字符集解码指定的字节数组来创建字符串</td>
</tr>
</tbody></table>
<p>代码示例：String编码说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中文的Unicode字符集对应的字符编码为负数</span></span><br><span class="line"><span class="comment"> * ISO8859-1不支持中文</span></span><br><span class="line"><span class="comment"> * GBK:中文2个字节，英文1个字节</span></span><br><span class="line"><span class="comment"> * UTF-8：中文3个字节，英文1个字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringEncodeDecodeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = s.getBytes();    <span class="comment">//[-28, -67, -96, -27, -91, -67]</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = s.getBytes(<span class="string">&quot;GBK&quot;</span>);  <span class="comment">//[-60, -29, -70, -61]</span></span><br><span class="line">        <span class="type">byte</span>[] bytes2 = s.getBytes(<span class="string">&quot;ISO8859-1&quot;</span>);    <span class="comment">//[63, 63]</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">        System.out.println(Arrays.toString(bytes1));</span><br><span class="line">        System.out.println(Arrays.toString(bytes2));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);     <span class="comment">//你好</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;utf-8&quot;</span>);   <span class="comment">//你好</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;GBK&quot;</span>);      <span class="comment">//浣犲ソ</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;ISO8859-1&quot;</span>);      <span class="comment">//ä½ å¥½</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes1,<span class="string">&quot;GBK&quot;</span>);     <span class="comment">//你好</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes1,<span class="string">&quot;utf-8&quot;</span>);   <span class="comment">//���</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes1,<span class="string">&quot;ISO8859-1&quot;</span>);   <span class="comment">//ÄãºÃ</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes2,<span class="string">&quot;GBK&quot;</span>);     <span class="comment">//??</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes2,<span class="string">&quot;utf-8&quot;</span>);   <span class="comment">//??</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str9</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes2,<span class="string">&quot;ISO8859-1&quot;</span>);   <span class="comment">//??</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;默认解码结果：&quot;</span>+str);</span><br><span class="line">        System.out.println(<span class="string">&quot;utf-8解码结果：&quot;</span>+str1);</span><br><span class="line">        System.out.println(<span class="string">&quot;utf-8编码，GBK解码结果：&quot;</span>+str2);</span><br><span class="line">        System.out.println(<span class="string">&quot;utf-8编码，ISO8859-1解码结果：&quot;</span>+str3);</span><br><span class="line">        System.out.println(<span class="string">&quot;GBK编码，GBK解码结果：&quot;</span>+str4);</span><br><span class="line">        System.out.println(<span class="string">&quot;GBK编码，utf-8解码结果：&quot;</span>+str5);</span><br><span class="line">        System.out.println(<span class="string">&quot;GBK编码，ISO8859-1解码结果：&quot;</span>+str6);</span><br><span class="line">        System.out.println(<span class="string">&quot;ISO8859-1编码，GBK解码结果：&quot;</span>+str7);</span><br><span class="line">        System.out.println(<span class="string">&quot;ISO8859-1编码，utf-8解码结果：&quot;</span>+str8);</span><br><span class="line">        System.out.println(<span class="string">&quot;ISO8859-1编码，ISO8859-1解码结果：&quot;</span>+str9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="IO流概述与分类"><a href="#IO流概述与分类" class="headerlink" title="IO流概述与分类"></a>IO流概述与分类</h2><blockquote>
<p><strong>IO流介绍</strong></p>
<p>IO：输入&#x2F;输出（Input&#x2F;Output）</p>
<p>流：是一种抽象概念，是对数据传输的总称。流的本质是数据传输，用来处理设备间数据的传输问题。</p>
<p><strong>常见的应用</strong>：文件复制、上传、下载。</p>
<p><strong>IO流的分类</strong></p>
<p>按照数据的流向：输入流，输出流。</p>
<p>按照数据类型：字节流，字符流。</p>
<p><strong>为什么要关闭流？</strong></p>
<p><strong>程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件 IO 资源。</strong></p>
</blockquote>
<p>流的分类：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td>基类</td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td>访问文件</td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td>访问数组</td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td>访问管道</td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
</tr>
<tr>
<td>访问字符串</td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr>
<td>缓冲流</td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>转换流</td>
<td></td>
<td></td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td>对象流</td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td>过滤流</td>
<td>FilterInputStream</td>
<td>FileterOutputStream</td>
<td>FilterReader</td>
<td>FileterWriter</td>
</tr>
<tr>
<td>打印流</td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
</tr>
<tr>
<td>推回输入流</td>
<td>PushbackInputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr>
<td>特殊流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h2><blockquote>
<p>文件输出流 FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 。</p>
<p>字节流写数据的三种方式：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int b)</td>
<td>将指定的字节写入此文件输出流  一次写一个字节数据</td>
</tr>
<tr>
<td>void write(byte[] b)</td>
<td>将 b.length字节从指定的字节数组写入此文件输出流一次写一个字节数组数据</td>
</tr>
<tr>
<td>void write(byte[] b, int off, int len)</td>
<td>将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流一次写一个字节数组的部分数据</td>
</tr>
</tbody></table>
<p>字节流写数据如何实现换行：</p>
<p><strong>windows:\r\n  linux:\n    mac:\r</strong> </p>
<p>字节流写数据追加写入：<strong>public FileOutputStream(String name,boolean append)</strong> </p>
</blockquote>
<p>代码示例：（字节输出流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试字节输出流写入数据：</span></span><br><span class="line"><span class="comment"> * void write(int b)</span></span><br><span class="line"><span class="comment"> * void write(byte[] b)</span></span><br><span class="line"><span class="comment"> * void write(byte[] b, int off, int len)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamTest</span> &#123;</span><br><span class="line">    <span class="comment">// 写入字节</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testDir/java.txt&quot;</span>);</span><br><span class="line">        fos.write(<span class="number">97</span>);</span><br><span class="line">        fos.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>&#125;);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入字节,添加偏移量</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testDir/java.txt&quot;</span>)) &#123;</span><br><span class="line">            fos.write(<span class="string">&quot;ABCDEFG&quot;</span>.getBytes(StandardCharsets.UTF_8),<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">            <span class="comment">// CDEFG</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追加并换行</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testDir/java.txt&quot;</span>,<span class="literal">true</span>)) &#123;</span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                fos.write(<span class="string">&quot;你好&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h2><blockquote>
<p>字节流读数据：FileInputStream(String name)。</p>
</blockquote>
<p>代码示例：（字节输入流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        读取数据到单个字节中，返回的是字节的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;testDir/java.txt&quot;</span>);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testDir/java2.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// byteVal: 读取到的数据（值）</span></span><br><span class="line">            <span class="comment">// 如果使用数组缓存，则表示读入到数组的长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">byteVal</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>((byteVal = fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(byteVal);</span><br><span class="line">            &#125;</span><br><span class="line">            fos.close();</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        读入到数组中，返回的是读入到数组中的数据长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;testDir/java.txt&quot;</span>);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testDir/java2.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// byteArr 相当于一个缓冲区</span></span><br><span class="line">            <span class="comment">// 如果使用数组缓存，则表示读入到字节数组的长度</span></span><br><span class="line">            <span class="type">byte</span>[] byteArr =  <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(byteArr))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(byteArr,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            fos.close();</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><blockquote>
<p>BufferedOutputStream：该类实现缓冲输出流。 通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用。</p>
<p>BufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BufferedOutputStream(OutputStream out)</td>
<td>创建字节缓冲输出流对象</td>
</tr>
<tr>
<td>BufferedInputStream(InputStream in)</td>
<td>创建字节缓冲输入流对象</td>
</tr>
</tbody></table>
</blockquote>
<p>代码示例：（字节缓冲流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节缓冲流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedOutputStreamBufferedInputStreamTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testDir/java3.txt&quot;</span>));</span><br><span class="line">        bos.write(<span class="string">&quot;hello\r\n&quot;</span>.getBytes());</span><br><span class="line">        bos.write(<span class="string">&quot;world\r\n&quot;</span>.getBytes());</span><br><span class="line">        bos.close();</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;testDir/java3.txt&quot;</span>));</span><br><span class="line">        <span class="type">int</span> buffer;</span><br><span class="line">        <span class="comment">/*while ((buffer = bis.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println((char) buffer);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓冲字节流复制视频</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mylove.mp4&quot;</span>));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mylove2.mp4&quot;</span>));</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符输入-x2F-输出流"><a href="#字符输入-x2F-输出流" class="headerlink" title="字符输入&#x2F;输出流"></a>字符输入&#x2F;输出流</h2><blockquote>
<p><strong>InputStreamReader</strong>：是从字节流到字符流的桥梁，它读取字节，并使用指定的编码将其解码为字符，它使用的字符集可以由名称指定，或者可以接受平台的默认字符集。</p>
<p><strong>OutputStreamWriter</strong>：是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节，它使用的字符集可以由名称指定，或者可以接受平台的默认字符集。</p>
<p><strong>构造方法：</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>InputStreamReader(InputStream in)</td>
<td>使用默认字符编码创建InputStreamReader</td>
</tr>
<tr>
<td>InputStreamReader(InputStream in,String chatset)</td>
<td>使用指定的字符编码创建InputStreamReader</td>
</tr>
<tr>
<td>OutputStreamWriter(OutputStream out)</td>
<td>使用默认字符编码创建OutputStreamWriter</td>
</tr>
<tr>
<td>OutputStreamWriter(OutputStream out,String charset)</td>
<td>使用指定的字符编码创建OutputStreamWriter</td>
</tr>
</tbody></table>
</blockquote>
<p>代码示例：（字符流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符输入输出流：字节流无法指定编码，但是字符流可以指定编码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderOutputStreamWriterTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符流写数据的5种方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testDir/java5.txt&quot;</span>));</span><br><span class="line">        osw.write(<span class="number">97</span>);</span><br><span class="line">        <span class="type">char</span>[] chs = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">        osw.write(chs);</span><br><span class="line">        osw.write(chs, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        osw.write(str);</span><br><span class="line">        osw.write(str, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        osw.close();</span><br><span class="line">        <span class="comment">//aabcdebchellohel</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符流读取数据的两种方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;testDir/java5.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 字符流指定编码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;testDir/java5.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">/*int ch;</span></span><br><span class="line"><span class="comment">        while((ch=isr.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println((char)ch);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>字符流写数据的5种方式：</strong></p>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>void write(int c)</strong></td>
<td>写一个字符</td>
</tr>
<tr>
<td><strong>void write(char[] cbuf)</strong></td>
<td>写入一个字符数组</td>
</tr>
<tr>
<td><strong>void write(char[] cbuf, int  off, int len)</strong></td>
<td>写入字符数组的一部分</td>
</tr>
<tr>
<td><strong>void write(String str)</strong></td>
<td>写一个字符串</td>
</tr>
<tr>
<td><strong>void write(String str, int  off, int len)</strong></td>
<td>写一个字符串的一部分</td>
</tr>
</tbody></table>
<p><strong>刷新和关闭的方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flush()</td>
<td>刷新流，之后还可以继续写数据</td>
</tr>
<tr>
<td>close()</td>
<td>关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td>
</tr>
</tbody></table>
<p><strong>BufferedWriter: close时会自动flush,都会调用flushBuffer方法。</strong></p>
<p><strong>字符流读数据的2种方式</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>一次读一个字符数据</td>
</tr>
<tr>
<td>int read(char[] cbuf)</td>
<td>一次读一个字符数组数据</td>
</tr>
</tbody></table>
<p><strong>FileWriter：对字符流的改进（文本操作）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符流：文本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterFileReaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;src/java1.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/java2.txt&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileReader.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fileWriter.write(chars, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        fileWriter.close();</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h2><blockquote>
<p><strong>BufferedWriter：</strong></p>
<p>将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以使用默认大小。</p>
<p><strong>BufferedReader：</strong></p>
<p>从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。</p>
<p>构造方法：</p>
<table>
<thead>
<tr>
<th>BufferedWriter(Writer out)</th>
<th>创建字符缓冲输出流对象</th>
</tr>
</thead>
<tbody><tr>
<td>BufferedReader(Reader in)</td>
<td>创建字符缓冲输入流对象</td>
</tr>
</tbody></table>
<p><strong>字符缓冲流特有功能</strong></p>
<table>
<thead>
<tr>
<th><strong>void newLine()</strong></th>
<th>写一行行分隔符，行分隔符字符串由系统属性定义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>String readLine()</strong></td>
<td>读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经 到达，则为null</td>
</tr>
</tbody></table>
</blockquote>
<p>代码示例：（字符缓冲流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符缓冲流复制文件，使用readline()和newLine()</span></span><br><span class="line"><span class="comment"> * BufferedWriter: close时会自动flush,都会调用flushBuffer方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterBufferedWriterTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用readline()和newLine()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;src/java6.txt&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            bw.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        bw.close();</span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;src/java2.txt&quot;</span>));</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/java6.txt&quot;</span>));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">			<span class="comment">//bw.flush();</span></span><br><span class="line">        &#125;</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 复制文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;src/java1.txt&quot;</span>));</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/java2.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// int ch;</span></span><br><span class="line">        <span class="comment">// while((ch=bufferedReader.read())!=-1)&#123;</span></span><br><span class="line">        <span class="comment">//      System.out.println((char)ch);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bufferedReader.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bufferedWriter.write(chars, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><blockquote>
<p>实现将基本数据类型的数据格式转化为字符串输出，</p>
<p>打印流：PrintStream和PrintWriter。</p>
<ol>
<li><p>提供了一系列重载的print()和println()方法，用于多种数据类型的输出。</p>
</li>
<li><p>PrintStream和PrintWriter的输出不会抛出IOException异常。</p>
</li>
<li><p>PrintStream和PrintWriter有自动flush功能。</p>
</li>
<li><p>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。</p>
</li>
<li><p>在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。</p>
</li>
<li><p>System.out返回的是PrintStream的实例</p>
</li>
</ol>
</blockquote>
<p>代码示例：（打印流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintWriterPrintReaderTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">printStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 第二个参数：是否自动刷新</span></span><br><span class="line">        <span class="comment">// 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\n&#x27; 时都会刷新输出缓冲区)</span></span><br><span class="line">        printStream = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(Files.newOutputStream(Paths.get(<span class="string">&quot;testDir/print.txt&quot;</span>)), <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (printStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 把标准输出流(控制台输出)改成文件</span></span><br><span class="line">            System.setOut(printStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">255</span>; i++) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) i);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (printStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            printStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><blockquote>
<p>为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。</p>
<p>数据流有两个类：(用于读取和写出基本数据类型、String类的数据）DataInputStream 和 DataOutputStream。分别 “套接” 在 InputStream 和 OutputStream 子类的流上。</p>
<p>DataInputStream中的方法</p>
<p><strong>1.</strong>   <strong>boolean readBoolean() byte readByte()</strong></p>
<p><strong>2.</strong>   <strong>char readChar() float readFloat()</strong></p>
<p><strong>3.</strong>   <strong>double readDouble() short readShort()</strong></p>
<p><strong>4.</strong>   <strong>long readLong() int readInt()</strong></p>
<p><strong>5.</strong>   <strong>String readUTF() void readFully(byte[] b)</strong></p>
</blockquote>
<p>代码示例：（数据流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按顺序写入什么类型的值，就应该按顺序读入什么类型的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataInputStreamOutputStreamTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 创建连接到指定文件的数据输出流对象</span></span><br><span class="line">            dos = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;destData.dat&quot;</span>));</span><br><span class="line">            dos.writeUTF(<span class="string">&quot;月落乌啼霜满天&quot;</span>); <span class="comment">// 写UTF字符串</span></span><br><span class="line">            dos.writeBoolean(<span class="literal">false</span>); <span class="comment">// 写入布尔值</span></span><br><span class="line">            dos.writeLong(<span class="number">1234567890L</span>); <span class="comment">// 写入长整数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;写文件完成!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 关闭流对象</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (dos != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 关闭过滤流时,会自动关闭它包装的底层节点流</span></span><br><span class="line">                    dos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dis = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;destData.dat&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> dis.readLong();</span><br><span class="line">            System.out.println(info);</span><br><span class="line">            System.out.println(flag);</span><br><span class="line">            System.out.println(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><blockquote>
<p><strong>ObjectInputStream和OjbectOutputSteam</strong></p>
<p>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p>
<p><strong>序列化</strong>：用ObjectOutputStream类保存基本类型数据或对象的机制。</p>
<p><strong>反序列化</strong>：用ObjectInputStream类读取基本类型数据或对象的机制。</p>
<p><strong>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量。</strong></p>
<p><strong>对象的序列化</strong></p>
<ol>
<li><p>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</p>
</li>
<li><p>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原。</p>
</li>
<li><p>序列化是 RMI（Remote Method Invoke: 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是JavaEE 平台的基础。</p>
</li>
<li><p>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出NotSerializableException异常。</p>
</li>
</ol>
<p><strong>Serializable以及Externalizable。</strong></p>
<ol start="5">
<li>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：</li>
</ol>
<p><strong>private static final long serialVersionUID;</strong></p>
<p>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</p>
<p>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明。</p>
<p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)</p>
<p>若某个类实现了 Serializable 接口，该类的对象就是可序列化的。</p>
<p><strong>序列化</strong>：创建一个 ObjectOutputStream，调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象，注意写出一次，操作flush()一次。</p>
<p><strong>反序列化：</strong>创建一个 ObjectInputStream，调用 readObject() 方法读取流中的对象。</p>
<p>强调：<strong>如果某个类的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化。</strong></p>
</blockquote>
<blockquote>
<p><strong>谈谈对java.io.Serializable接口的理解：</strong></p>
<ol>
<li><p>实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。<strong>这意味着序列化机制能自动补偿操作系统间的差异。</strong>换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。</p>
</li>
<li><p>由于大部分作为参数的类如String、Integer等都实现了java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（序列化）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectSerializableTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pojo</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">9581</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">String</span> <span class="variable">config</span> <span class="operator">=</span> <span class="string">&quot;config&quot;</span>;</span><br><span class="line">        <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Pojo&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&quot;, num=&quot;</span> + num + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化，注意不要传入路径，而应传入流作为参数，防止该jar被其他jar调用而无法传入路径问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(OutputStream outputStream, Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(outputStream)) &#123;</span><br><span class="line">            oos.writeObject(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">readObject</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(inputStream)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Pojo</span> <span class="variable">pojo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pojo</span>();</span><br><span class="line">        writeObject(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;obj.dat&quot;</span>), pojo);</span><br><span class="line"></span><br><span class="line">        <span class="type">Pojo</span> <span class="variable">objects</span> <span class="operator">=</span> readObject(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;obj.dat&quot;</span>));</span><br><span class="line">        System.out.println(objects);</span><br><span class="line">        <span class="comment">// Pojo&#123;name=&#x27;name&#x27;, num=0&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><blockquote>
<ul>
<li>RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。</li>
<li>RandomAccessFile 类支持”随机访问”的方式，程序可以直接跳到文件的任意地方来读、写文件，支持只访问文件的部分内容，可以向已存在的文件后追加内容。</li>
<li>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。</li>
<li>RandomAccessFile 类对象可以自由移动记录指针：<ul>
<li>long getFilePointer()：获取文件记录指针的当前位置。</li>
<li>void seek(long pos)：将文件记录指针定位到 pos 位置。</li>
</ul>
</li>
</ul>
<p>构造器</p>
<ul>
<li><strong>public RandomAccessFile(File file, String mode)</strong></li>
<li><strong>public RandomAccessFile(String name, String mode)</strong></li>
</ul>
<p>创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式：</p>
<ul>
<li>r：以只读方式打开。</li>
<li>rw：打开以便读取和写入。</li>
<li>rwd：打开以便读取和写入；同步文件内容的更新。</li>
<li>rws：打开以便读取和写入；同步文件内容和元数据的更新。</li>
</ul>
<p>如果模式为只读 r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 如果模式为 rw 读写。如果文件不存在则会去创建文件，如果存在则不会创建。</p>
</blockquote>
<p>代码示例：（RandomAccessFile）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。</span></span><br><span class="line">        <span class="comment">// 如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;testDir/raf.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">// 每50个字节为一个数据块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            raf.seek(raf.length());</span><br><span class="line">            raf.write(Arrays.copyOf((<span class="string">&quot;Hello World!&quot;</span> + String.valueOf(i) + <span class="string">&quot;\r\n&quot;</span>).getBytes(StandardCharsets.UTF_8), <span class="number">50</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;write over!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; raf.length() / <span class="number">50</span>; i++) &#123;</span><br><span class="line">            raf.seek(i * <span class="number">50L</span>);</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">50</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> raf.read(bytes);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len).trim());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;read over!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。</p>
<p>NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的</p>
<p>IO操作。NIO将以更加高效的方式进行文件的读写操作。</p>
<p>Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<p>java.nio.channels.Channel。</p>
<ul>
<li>FileChannel：处理本地文件。</li>
<li>SocketChannel：TCP网络编程的客户端的Channel。</li>
<li>ServerSocketChannel:TCP网络编程的服务器端的Channel。</li>
<li>DatagramChannel：UDP网络编程中发送端和接收端的Channel。</li>
</ul>
</blockquote>
<h3 id="Path、Paths和Files核心API"><a href="#Path、Paths和Files核心API" class="headerlink" title="Path、Paths和Files核心API"></a>Path、Paths和Files核心API</h3><blockquote>
<p>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</p>
<p>NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在。</p>
<p>在以前IO操作都是这样写的：<strong>import java.io.File;File file &#x3D; new File(“index.html”);</strong></p>
<p>但在Java7 中，我们可以这样写：</p>
<p><strong>import java.nio.file.Path;import java.nio.file.Paths;Path path &#x3D; Paths.get(“index.html”);</strong></p>
<p>同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法。</p>
<p>Paths 类提供的静态 get() 方法用来获取 Path 对象：</p>
<p>static Path get(String first, String … more) : 用于将多个字符串串连成路径。</p>
<p>static Path get(URI uri): 返回指定uri对应的Path路径。</p>
</blockquote>
<h3 id="Path接口"><a href="#Path接口" class="headerlink" title="Path接口"></a>Path接口</h3><blockquote>
<p><strong>Path 常用方法：</strong></p>
<ol>
<li>String toString() ： 返回调用 Path 对象的字符串表示形式。</li>
<li>boolean startsWith(String path) : 判断是否以 path 路径开始。</li>
<li>boolean endsWith(String path) : 判断是否以 path 路径结束。</li>
<li>boolean isAbsolute() : 判断是否是绝对路径。</li>
<li>Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径。</li>
<li>Path getRoot() ：返回调用 Path 对象的根路径。</li>
<li>Path getFileName() : 返回与调用 Path 对象关联的文件名。</li>
<li>int getNameCount() : 返回Path 根目录后面元素的数量。</li>
<li>Path getName(int idx) : 返回指定索引位置 idx 的路径名称。</li>
<li>Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象。</li>
<li>Path resolve(Path p)：合并两个路径，返回合并后的路径对应的Path对象。</li>
<li>File toFile()：将Path转化为File类的对象。</li>
</ol>
</blockquote>
<h3 id="Files-类"><a href="#Files-类" class="headerlink" title="Files 类"></a>Files 类</h3><p>java.nio.file.Files 用于操作文件或目录的工具类。</p>
<p><strong>Files常用方法：</strong></p>
<blockquote>
<ol>
<li><p>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制。</p>
</li>
<li><p>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录。</p>
</li>
<li><p>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件。</p>
</li>
<li><p>void delete(Path path) : 删除一个文件&#x2F;目录，如果不存在，执行报错。</p>
</li>
<li><p>void deleteIfExists(Path path) : Path对应的文件&#x2F;目录如果存在，执行删除。</p>
</li>
<li><p>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置。</p>
</li>
<li><p>long size(Path path) : 返回 path 指定文件的大小。</p>
</li>
</ol>
</blockquote>
<p><strong>Files常用方法：用于判断</strong></p>
<blockquote>
<ol>
<li><p>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在。</p>
</li>
<li><p>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录。</p>
</li>
<li><p>boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件。</p>
</li>
<li><p>boolean isHidden(Path path) : 判断是否是隐藏文件。</p>
</li>
<li><p>boolean isReadable(Path path) : 判断文件是否可读。</p>
</li>
<li><p>boolean isWritable(Path path) : 判断文件是否可写。</p>
</li>
<li><p>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在。</p>
</li>
</ol>
</blockquote>
<p><strong>Files常用方法：用于操作内容</strong></p>
<blockquote>
<ol>
<li><p>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</p>
</li>
<li><p>DirectoryStream<Path> newDirectoryStream(Path path) : 打开 path 指定的目录。</Path></p>
</li>
<li><p>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象。</p>
</li>
<li><p>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象。</p>
</li>
</ol>
</blockquote>
<h1 id="NIO-1"><a href="#NIO-1" class="headerlink" title="NIO"></a>NIO</h1><h2 id="Java-BIO编程"><a href="#Java-BIO编程" class="headerlink" title="Java BIO编程"></a>Java BIO编程</h2><h3 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h3><blockquote>
<ul>
<li>异步与同步：针对于调用者来说，调用者发送请求，等待对方响应结果之后再执行其他事情就是同步，如果发送请求之后不等对方作出响应就去做其他事情，就是异步。</li>
<li>阻塞与非阻塞：针对被调用者，被调用者接受请求之后，做完任务之后才给出反馈的结果就是同步，接受请求后立即作出反馈，然后在去执行结果就是非阻塞。</li>
</ul>
</blockquote>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>Java共支持 3 种网络编程模型&#x2F;IO模式：BIO、NIO、AIO</p>
<blockquote>
<p>（1） Java BIO：同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。</p>
<p><img src="/2023/02/28/JavaSE/BIO%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B.png" alt="BIO基本模型.png"></p>
<p>（2）Java NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即</p>
<p>客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求就进行处理。</p>
<p><img src="/2023/02/28/JavaSE/NIO%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B.png" alt="NIO基本模型.png"></p>
<p>（3） Java AIO(NIO.2)：异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor</p>
<p>模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p>
</blockquote>
<h3 id="BIO、NIO、AIO适用场景分析"><a href="#BIO、NIO、AIO适用场景分析" class="headerlink" title="BIO、NIO、AIO适用场景分析"></a>BIO、NIO、AIO适用场景分析</h3><blockquote>
<ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
</blockquote>
<h3 id="Java-BIO-基本介绍"><a href="#Java-BIO-基本介绍" class="headerlink" title="Java BIO 基本介绍"></a>Java BIO 基本介绍</h3><blockquote>
<ul>
<li>Java BIO 就是传统的java io 编程，其相关的类和接口在 java.io </li>
<li>BIO(blocking I&#x2F;O) ：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器)。</li>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解</li>
</ul>
</blockquote>
<h3 id="BIO-应用实例"><a href="#BIO-应用实例" class="headerlink" title="BIO 应用实例"></a>BIO 应用实例</h3><blockquote>
<ol>
<li>服务器端启动一个ServerSocket。</li>
<li>客户端启动 Socket 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯（也可以使用线程池进行改善）。</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。（客户端使用 Telnet 与服务器模拟通信，完成读写操作）</li>
<li>如果有响应，客户端线程会等待请求结束后，再继续执行。</li>
</ol>
</blockquote>
<p>代码示例：（BIO）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟BIOServer，使用telnet测试：</span></span><br><span class="line"><span class="comment"> * 步骤：</span></span><br><span class="line"><span class="comment"> * 1. telnet 127.0.0.1 6666</span></span><br><span class="line"><span class="comment"> * 2. CTRL+]</span></span><br><span class="line"><span class="comment"> * 3. send [info]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Server ready, wait connection...&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            executorService.execute(() -&gt; handleMessage(socket));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;server handle: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭socket就会关闭inputStream</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：使用 Telnet 测试</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. telnet 127.0.0.1 6666</span><br><span class="line">2. CTRL+]</span><br><span class="line">3. send [info]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Java-BIO-问题分析"><a href="#Java-BIO-问题分析" class="headerlink" title="Java BIO 问题分析"></a>Java BIO 问题分析</h3><blockquote>
<ul>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读(客户端没有发送数据)，则线程就阻塞在 Read 操作上，造成线程资源浪费。</li>
</ul>
</blockquote>
<h2 id="Java-NIO编程"><a href="#Java-NIO编程" class="headerlink" title="Java NIO编程"></a>Java NIO编程</h2><h3 id="Java-NIO-基本介绍"><a href="#Java-NIO-基本介绍" class="headerlink" title="Java NIO 基本介绍"></a>Java NIO 基本介绍</h3><blockquote>
<ol>
<li>Java NIO 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输</li>
</ol>
<p>​	出的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的。</p>
<ol start="2">
<li><p>NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。</p>
</li>
<li><p>NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器) 。</p>
</li>
<li><p>NIO是 面向缓冲区 ，或者面向 块 编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，</p>
</li>
</ol>
<p>​		这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</p>
<ol start="5">
<li><p>Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前		没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续		做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程		同时可以去做别的事情。</p>
</li>
<li><p>通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来,根据实际情况，可以分配50		或者100个线程来处理。不像之前的阻塞IO那样，非得分配10000个。</p>
</li>
<li><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个		数量级。</p>
</li>
</ol>
<p>8）NIO Buffer的使用</p>
</blockquote>
<h3 id="NIO-三大核心原理示意图"><a href="#NIO-三大核心原理示意图" class="headerlink" title="NIO 三大核心原理示意图"></a>NIO 三大核心原理示意图</h3><blockquote>
<p>Selector、Channel 和 Buffer 的关系图</p>
<p><img src="/2023/02/28/JavaSE/NIO%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%A4%BA%E6%84%8F%E5%9B%BE%E7%AE%80%E5%8D%95%E7%89%88.png" alt="NIO三大核心示意图简单版.png"></p>
<p>关系图的说明：</p>
<ol>
<li><p>每个channel 都会对应一个Buffer。</p>
</li>
<li><p>Selector 对应一个线程，一个线程对应多个channel(连接)。</p>
</li>
<li><p>该图反应了有三个channel 注册到 该selector 。</p>
</li>
<li><p>程序切换到哪个channel 是由事件决定的, Event 就是一个重要的概念。</p>
</li>
<li><p>Selector 会根据不同的事件，在各个通道上切换。</p>
</li>
<li><p>Buffer 就是一个内存块，底层是有一个数组。</p>
</li>
<li><p>数据的读取写入是通过Buffer, 这个和BIO , BIO 中要么是输入流，或者是输出流, 不能双向，但是NIO的Buffer 是		可以读也可以写, 需要 flip 方法切换。</p>
</li>
<li><p>channel 是双向的, 可以返回底层操作系统的情况, 比如Linux，底层的操作系统通道就是双向的。</p>
</li>
</ol>
</blockquote>
<h3 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote>
<p>缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。</p>
</blockquote>
<h4 id="Buffer-类及其子类"><a href="#Buffer-类及其子类" class="headerlink" title="Buffer 类及其子类"></a>Buffer 类及其子类</h4><blockquote>
<ul>
<li><p>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类：</p>
<ul>
<li>ByteBuffer，存储字节数据到缓冲区</li>
<li>ShortBuffer，存储字符串数据到缓冲区</li>
<li>CharBuffer，存储字符数据到缓冲区</li>
<li>IntBuffer，存储整数数据到缓冲区</li>
<li>LongBuffer，存储长整型数据到缓冲区</li>
<li>DoubleBuffer，存储小数到缓冲区</li>
<li>FloatBuffer，存储小数到缓冲区</li>
</ul>
</li>
<li><p>Buffer类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息。</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SPLITERATOR_CHARACTERISTICS</span> <span class="operator">=</span></span><br><span class="line">        Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED;</span><br><span class="line">    <span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  属性说明：</p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Capacity</td>
<td>容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变</td>
</tr>
<tr>
<td>Limit</td>
<td>表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作。且极限是可以修改的</td>
</tr>
<tr>
<td>Position</td>
<td>位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变改值，为下次读写作准备</td>
</tr>
<tr>
<td>Mark</td>
<td>标记</td>
</tr>
</tbody></table>
<ul>
<li><p>Buffer类相关方法</p>
<ul>
<li>public abstract class <strong>Buffer</strong> {      &#x2F;&#x2F;JDK1.4时，引入的api</li>
<li>public final int capacity( )&#x2F;&#x2F;返回此缓冲区的容量</li>
<li>public final int position( )&#x2F;&#x2F;返回此缓冲区的位置</li>
<li>public final Buffer position (int newPositio)&#x2F;&#x2F;设置此缓冲区的位置</li>
<li>public final int limit( )&#x2F;&#x2F;返回此缓冲区的限制</li>
<li>public final Buffer limit (int newLimit)&#x2F;&#x2F;设置此缓冲区的限制</li>
<li>public final Buffer mark( )&#x2F;&#x2F;在此缓冲区的位置设置标记</li>
<li>public final Buffer reset( )&#x2F;&#x2F;将此缓冲区的位置重置为以前标记的位置</li>
<li>public final Buffer clear( )&#x2F;&#x2F;清除此缓冲区, 即将各个标记恢复到初始状态，但是数据并没有真正擦除, 后面操作会覆盖</li>
<li>public final Buffer flip( )&#x2F;&#x2F;反转此缓冲区</li>
<li>public final Buffer rewind( )&#x2F;&#x2F;重绕此缓冲区</li>
<li>public final int remaining( )&#x2F;&#x2F;返回当前位置与限制之间的元素数</li>
<li>public final boolean hasRemaining( )&#x2F;&#x2F;告知在当前位置和限制之间是否有元素</li>
<li>public abstract boolean isReadOnly(  );&#x2F;&#x2F;告知此缓冲区是否为只读缓冲区      &#x2F;&#x2F;JDK1.6时引入的api</li>
<li>public abstract boolean hasArray();&#x2F;&#x2F;告知此缓冲区是否具有可访问的底层实现数组</li>
<li>public abstract Object array();&#x2F;&#x2F;返回此缓冲区的底层实现数组</li>
<li>public abstract int arrayOffset();&#x2F;&#x2F;返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量</li>
<li>public abstract boolean isDirect();&#x2F;&#x2F;告知此缓冲区是否为直接缓冲区</li>
</ul>
</li>
<li><p>filp() 和 clear() 的区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h4 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h4><blockquote>
<p>从前面可以看出对于 Java 中的基本数据类型(boolean除外)，都有一个 Buffer 类型与之相对应，最常用的自然是ByteBuffer 类（二进制数据），该类的主要方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ByteBuffer</span> &#123;</span><br><span class="line">    <span class="comment">//缓冲区创建相关api</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span><span class="comment">//创建直接缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span><span class="comment">//设置缓冲区的初始容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">byte</span>[] array)</span><span class="comment">//把一个数组放到缓冲区中使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造初始化位置offset和上界length的缓冲区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">byte</span>[] array, <span class="type">int</span> offset, <span class="type">int</span> length)</span><span class="comment">//缓存区存取相关API</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span><span class="params">()</span>;<span class="comment">//从当前位置position上get，get之后，position会自动+1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;<span class="comment">//从绝对位置get</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span> b)</span>;<span class="comment">//从当前位置上添加，put之后，position会自动+1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> index, <span class="type">byte</span> b)</span>;<span class="comment">//从绝对位置上put   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote>
<ol>
<li>NIO的通道类似于流，但有些区别如下：</li>
</ol>
<p>通道可以同时进行读写，而流只能读或者只能写。</p>
<p>通道可以实现异步读写数据。</p>
<p>通道可以从缓冲读数据，也可以写数据到缓冲。</p>
<ol start="2">
<li><p>BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)是双向的，可以读操作，也可以写操作。</p>
</li>
<li><p>Channel在NIO中是一个接口：public interface Channel extends Closeable{} </p>
</li>
<li><p>常用的Channel 类有： FileChannel、DatagramChannel、ServerSocketChannel 和 SocketChannel。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</p>
</li>
<li><p>FileChannel 用于文件的数据读写，DatagramChannel 用于 UDP 的数据读</p>
</li>
</ol>
<p>写，ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写。</p>
</blockquote>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在运行期。借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>
<p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</p>
<p><strong>动态语言&#x2F;静态语言</strong></p>
<p><strong>动态语言</strong></p>
<p>​		是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p>
<p>主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。</p>
<p><strong>静态语言</strong></p>
<p>​		与动态语言相对应的，运行时结构不可变的语言就是静态语言。如 Java、C、 C++。</p>
<p>Java 不是动态语言，但 Java 可以称之为 “准动态语言”。即 Java 有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。</p>
<p><strong>反射相关的主要API</strong></p>
<ol>
<li><p><strong>java.lang.Class：代表一个类。</strong></p>
</li>
<li><p><strong>java.lang.reflect.Method：代表类的方法。</strong></p>
</li>
<li><p><strong>java.lang.reflect.Field：代表类的成员变量。</strong></p>
</li>
<li><p><strong>java.lang.reflect.Constructor：代表类的构造器。</strong></p>
</li>
</ol>
</blockquote>
<h2 id="Java反射的作用"><a href="#Java反射的作用" class="headerlink" title="Java反射的作用"></a>Java反射的作用</h2><blockquote>
<ul>
<li><p>在运行时判断任意一个对象所属的类</p>
</li>
<li><p>在运行时构造任意一个类的对象</p>
</li>
<li><p>在运行时判断任意一个类所具有的成员变量和方法</p>
</li>
<li><p>在运行时获取泛型信息</p>
</li>
<li><p>在运行时调用任意一个对象的成员变量和方法</p>
</li>
<li><p>在运行时处理注解</p>
</li>
<li><p>生成动态代理</p>
</li>
</ul>
</blockquote>
<h2 id="Class-类及其实例"><a href="#Class-类及其实例" class="headerlink" title="Class 类及其实例"></a>Class 类及其实例</h2><blockquote>
<p>在 Object 类中定义了以下的方法，此方法将被所有子类继承：public final Class getClass()</p>
<p>该方法返回值的类型是一个 Class 类，此类是 Java 反射的源头，实际上所谓反射从程序的运行结果来看即：通过对象反射求出类的名称。</p>
</blockquote>
<h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><blockquote>
<p>对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构**(class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F;primitive type&#x2F;void&#x2F;[ ])**的有关信息。</p>
<ol>
<li><p>Class本身也是一个类。</p>
</li>
<li><p>Class 对象只能由系统建立对象。</p>
</li>
<li><p>一个加载的类在 JVM 中只会有一个Class实例。</p>
</li>
<li><p>一个Class对象对应的是一个加载到JVM中的一个.class文件。</p>
</li>
<li><p>每个类的实例都会记得自己是由哪个 Class 实例所生成。</p>
</li>
<li><p>通过 Class 可以完整地得到一个类中的所有被加载的结构。</p>
</li>
<li><p>Class 类是 Reflection 的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 Class 对象。</p>
</li>
</ol>
</blockquote>
<h3 id="Class-类的常用方法"><a href="#Class-类的常用方法" class="headerlink" title="Class 类的常用方法"></a>Class 类的常用方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>static  class  forName(String  name)</td>
<td>返回类名为 name 的 Class 对象</td>
</tr>
<tr>
<td>Object  newINstance( )</td>
<td>调用缺省构造函数，返回该 Class 对象的一个实例</td>
</tr>
<tr>
<td>getName( )</td>
<td>返回该 Class 对象所表示的实体（类、接口、数组、接本类型、数组、void）名称</td>
</tr>
<tr>
<td>Class  getSuperClass( )</td>
<td>返回当前 Class 对象的父类的 Class 对象</td>
</tr>
<tr>
<td>Class[ ]  getInterfaces( )</td>
<td>返回当前 Class 对象的接口</td>
</tr>
<tr>
<td>ClassLoader  getClassLoader( )</td>
<td>返回该类的类加载器</td>
</tr>
<tr>
<td>Constructor[ ]  getConstructors( )</td>
<td>返回一个包含某些 Constructor 对象的数组</td>
</tr>
<tr>
<td>Field[ ]  getDeclaredFields( )</td>
<td>返回 Field 对象数组</td>
</tr>
<tr>
<td>Method getMethod(String name, Class … paramTypes)</td>
<td>返回一个Method 对象，此对象的形参类型为 paramType</td>
</tr>
</tbody></table>
<h3 id="获取-Class-类的实例（四种方法）"><a href="#获取-Class-类的实例（四种方法）" class="headerlink" title="获取 Class 类的实例（四种方法）"></a>获取 Class 类的实例（四种方法）</h3><blockquote>
<ul>
<li><p>前提：若已知具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高。</p>
<ul>
<li><strong>实例：Class clazz &#x3D; String.class;</strong></li>
</ul>
</li>
<li><p>前提：已知某个类的实例，调用该实例的 getClass( ) 方法获取 Class 对象。</p>
<ul>
<li><strong>实例：Class clazz &#x3D; “hello”.getClass();</strong></li>
</ul>
</li>
<li><p>前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出<strong>ClassNotFoundException</strong>。</p>
<ul>
<li><strong>实例：Class clazz &#x3D; Class.forName(“java.lang.String”);</strong></li>
</ul>
</li>
<li><p>其他方式</p>
<ul>
<li><strong>ClassLoader cl &#x3D; this.getClass().getClassLoader();</strong></li>
<li><strong>Class clazz4 &#x3D; cl.loadClass(“classFullName”);</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="哪些类型可以有Class对象"><a href="#哪些类型可以有Class对象" class="headerlink" title="哪些类型可以有Class对象"></a>哪些类型可以有Class对象</h3><blockquote>
<ul>
<li>class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>[ ]：数组</li>
<li>enum：枚举</li>
<li>annotation：注解@interface</li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class实例可以是那些结构</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testClassConstruct</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Object.class;</span><br><span class="line">   <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Comparable.class;</span><br><span class="line">   <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> String[].class;</span><br><span class="line">   <span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="type">int</span>[][].class;</span><br><span class="line">   <span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> ElementType.class; <span class="comment">//枚举</span></span><br><span class="line">   <span class="comment">//注解</span></span><br><span class="line">   <span class="type">Class</span> <span class="variable">c6</span> <span class="operator">=</span> Override.class;</span><br><span class="line">   Class c7= <span class="type">int</span>.class;</span><br><span class="line">   <span class="type">Class</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="keyword">void</span>.class;</span><br><span class="line">   <span class="type">Class</span> <span class="variable">c9</span> <span class="operator">=</span> Class.class;</span><br><span class="line">   </span><br><span class="line">   <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">   <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">   <span class="type">Class</span> <span class="variable">c10</span> <span class="operator">=</span> a.getClass();</span><br><span class="line">   <span class="type">Class</span> <span class="variable">c11</span> <span class="operator">=</span> b.getClass();</span><br><span class="line">   <span class="comment">//只要数组的元素类型和维度相同，就是同一个Class</span></span><br><span class="line">   System.out.println(c10 == c11); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="反射的基本使用"><a href="#反射的基本使用" class="headerlink" title="反射的基本使用"></a>反射的基本使用</h3><p>代码示例：（反射的基本使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供简单的测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    String hobby;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*public Person() throws IOException &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Person Constrructor &quot;);</span></span><br><span class="line"><span class="comment">        throw new IOException();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// newInstance() public 和 默认不会抛出异常,私有的会抛出 InstantiationException</span></span><br><span class="line">    Person()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;person print....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">showNation</span><span class="params">(String nation)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name: &quot;</span> + name + <span class="string">&quot;, nation: &quot;</span> + nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    反射之后可以进行的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPerson02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        通过构造器实例化对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Constructor&lt;Person&gt; cons = clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// Person [name=Tom, age=10]</span></span><br><span class="line">    System.out.println(p1.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;**************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        反射调用指定的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">age1</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age1.set(p1, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">//Person [name=Tom, age=12]</span></span><br><span class="line">    System.out.println(p1.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">print</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;print&quot;</span>);</span><br><span class="line">    <span class="comment">//person print....</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> print.invoke(p1);</span><br><span class="line">    System.out.println(<span class="string">&quot;**************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        反射调用私有的结构：私有的构造方法、属性、普通方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//调用私有的构造器</span></span><br><span class="line">    Constructor&lt;Person&gt; con1 = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    con1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> con1.newInstance(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    <span class="comment">//Person [name=Jerry, age=0]</span></span><br><span class="line">    System.out.println(p2.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name1</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    name1.set(p2, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">    <span class="comment">//Person [name=Rose, age=0]</span></span><br><span class="line">    System.out.println(p2.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有的方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class);</span><br><span class="line">    m2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//name: Rose, nation: china</span></span><br><span class="line">    m2.invoke(p2, <span class="string">&quot;china&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) m2.invoke(p2, <span class="string">&quot;china&quot;</span>);</span><br><span class="line">    <span class="comment">//china</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="comment">//Person [name=Rose, age=0]</span></span><br><span class="line">    System.out.println(p2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（获取 Class 对象的 4 种方式）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取Class的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testClass</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IOException &#123;</span><br><span class="line">    <span class="comment">//1. 调用运行时类的属性：class</span></span><br><span class="line">    Class&lt;Person&gt; c1 = Person.class;</span><br><span class="line">    System.out.println(c1); <span class="comment">// class com.example.reflect.Person</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.通过运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line">    System.out.println(c2); <span class="comment">// class com.example.reflect.Person</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用Class的静态方法：Class.forName(String classpath)</span></span><br><span class="line">    <span class="comment">//常用：更好体现动态性</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c3 = Class.forName(<span class="string">&quot;com.example.reflect.Person&quot;</span>);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.使用类的加载器：ClassLoader</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectTest.class.getClassLoader();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.example.reflect.Person&quot;</span>);</span><br><span class="line">    System.out.println(c4);</span><br><span class="line"></span><br><span class="line">    System.out.println(c1 == c2);</span><br><span class="line">    System.out.println(c1 == c3);</span><br><span class="line">    System.out.println(c1 == c4);</span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的加载与ClassLoader的理解"><a href="#类的加载与ClassLoader的理解" class="headerlink" title="类的加载与ClassLoader的理解"></a>类的加载与ClassLoader的理解</h2><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><blockquote>
<p><strong>1.</strong>   <strong>加载Load</strong></p>
<p>将 class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。</p>
<p><strong>2.</strong>   <strong>链接Link</strong></p>
<p>将Java类的二进制代码合并到JVM的运行状态之中的过程。</p>
<ol>
<li><p>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题。</p>
</li>
<li><p>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</p>
</li>
<li><p>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</p>
</li>
</ol>
<p><strong>3.</strong>   <strong>初始化Initialize</strong></p>
<ol>
<li><p>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</clinit></clinit></p>
</li>
<li><p>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</p>
</li>
<li><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</clinit></p>
</li>
</ol>
</blockquote>
<h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><p><strong>类的主动引用（一定会发生类的初始化）</strong></p>
<blockquote>
<ul>
<li><p>当虚拟机启动，先初始化 main 方法所在的类。</p>
</li>
<li><p>new 一个类的对象。</p>
</li>
<li><p>调用类的静态成员（除了 final 常量）和静态方法。</p>
</li>
<li><p>使用 java.lang.reflect 包的方法对类进行反射调用。</p>
</li>
<li><p>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类。</p>
</li>
</ul>
</blockquote>
<p><strong>类的被动引用（不会发生类的初始化）</strong></p>
<blockquote>
<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化，当通过子类引用父类的静态变量，不会导致子类初始化。</li>
<li>通过数组定义类引用，不会触发此类的初始化。</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）。</li>
</ul>
</blockquote>
<h3 id="类的初始化步骤"><a href="#类的初始化步骤" class="headerlink" title="类的初始化步骤"></a>类的初始化步骤</h3><blockquote>
<ol>
<li><p>假如类还未被加载和连接，则程序先加载并连接该类。</p>
</li>
<li><p>假如该类的直接父类还未被初始化，则先初始化其直接父类。</p>
</li>
<li><p>假如类中有初始化语句，则系统依次执行这些初始化语句。</p>
</li>
</ol>
<p>注意：在执行第 2 个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3。</p>
</blockquote>
<h3 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h3><blockquote>
<p><strong>类加载器的作用</strong></p>
<p>将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区中类数据的访问入口。</p>
<p><strong>类缓存：</strong>标准的 JavaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过 JVM 垃圾回收机制可以回收这些 Class 对象。</p>
<p>类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器。</p>
<ol>
<li><p><strong>引导类加载器</strong>：用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取。</p>
</li>
<li><p><strong>扩展类加载器</strong>：负责 <strong>jre&#x2F;lib&#x2F;ext</strong> 目录下的 jar 包或 <strong>java.ext.dirs</strong>  指定目录下的 jar 包装入工作库。</p>
</li>
<li><p><strong>系统类加载器</strong>：负责 java classpath 或 java.class.path 所指的目录下的类与 jar 包装入工作 ，是最常用的加载器。</p>
</li>
</ol>
</blockquote>
<h3 id="JVM的类加载机制"><a href="#JVM的类加载机制" class="headerlink" title="JVM的类加载机制"></a>JVM的类加载机制</h3><blockquote>
<ol>
<li><p><strong>全盘负责</strong>：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p>
</li>
<li><p><strong>父类委托</strong>：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。</p>
</li>
<li><p><strong>缓存机制</strong>：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区。</p>
</li>
</ol>
</blockquote>
<h3 id="Java中的内置类加载器"><a href="#Java中的内置类加载器" class="headerlink" title="Java中的内置类加载器"></a>Java中的内置类加载器</h3><blockquote>
<ul>
<li>Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为 null ，并且没有父 null</li>
<li>Platform class loader：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先定义的 Java SE平台 API，其实现类和 JDK 特定的运行时类</li>
<li>System class loader：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常用于定义应用程序类路径，模块路径和 JDK 特定工具上的类</li>
</ul>
<p>类加载器的层级关系：System 的父加载器为 Platform，而 Platform 的父加载器为 Bootstrap。</p>
</blockquote>
<h4 id="ClassLoader-中的两个方法"><a href="#ClassLoader-中的两个方法" class="headerlink" title="ClassLoader 中的两个方法"></a>ClassLoader 中的两个方法</h4><table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static ClassLoader getSystemClassLoader( )</td>
<td>返回用于委派的系统类加载器</td>
</tr>
<tr>
<td>ClassLoader getParent( )</td>
<td>返回父类加载器进行委派</td>
</tr>
</tbody></table>
<p>代码示例：（测试类加载器）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(StaticTest.m); <span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//自定义类的加载由系统类加载器加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        <span class="comment">//jdk.internal.loader.ClassLoaders$AppClassLoader@2077d4de</span></span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        <span class="comment">//通过getParent()获取：扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> classLoader.getParent();</span><br><span class="line">        <span class="comment">//jdk.internal.loader.ClassLoaders$PlatformClassLoader@4926097b</span></span><br><span class="line">        System.out.println(parent);</span><br><span class="line">        <span class="comment">//继续getParent()无法获取引导类加载器（C++写的）</span></span><br><span class="line">        System.out.println(parent.getParent()); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//核心类库：引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader2); <span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一步：加载类</span></span><br><span class="line"><span class="comment"> * 第二步：链接（其中的prepare阶段）结束后，m 赋初始值0</span></span><br><span class="line"><span class="comment"> * 第三步：初始化：m 的值由&lt;clinit&gt;方法决定，&lt;clinit&gt;类构造方法由类变量和静态代码块中的语句按照顺序合并产生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><blockquote>
<p>Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
<p><strong>工作原理</strong></p>
<ol>
<li><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。</p>
</li>
<li><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器。</p>
</li>
<li><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>
</li>
</ol>
<p><img src="/2023/02/28/JavaSE/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt="双亲委派"></p>
</blockquote>
<p>代码测试：（双亲委派）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;java lang String!&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//hello string! static不会执行</span></span><br><span class="line">        java.lang.<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">java</span>.lang.String()；</span><br><span class="line">        System.out.println(<span class="string">&quot;hello string!&quot;</span>)；</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        System.out.println(StringTest.class.getClassLoader())；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序说明：</p>
<p>自定义的 java.lang.String 先由应用类加载器委托扩展类加载器，再由扩展类加载器委托给引导类加载器，引导类加载器只加载包名为 java、 javax、sun 等开头的类。因此真正加载的是 String 类，而不是自定义的 String。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang；</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;java lang String!&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        错误： 在类 java.lang.String 中找不到 main 方法， 请将 main 方法定义为：</span></span><br><span class="line"><span class="comment">        public static void main(String[] args)</span></span><br><span class="line"><span class="comment">        否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 说明：真正加载的是核心String类，类中没有定义main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;java lang String!&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>双亲委派的优势：</strong></p>
<ol>
<li><p>避免类的重复加载（向上可以被加载就不会继续委派，只加载一次）</p>
</li>
<li><p>保护程序安全，防止随意篡改核心API，如Java.lang.String和java.lang.ShkStart。如果引导类加载该类，可能出现</p>
<p>问题造成破坏。</p>
</li>
</ol>
</blockquote>
<h2 id="Class对象的作用"><a href="#Class对象的作用" class="headerlink" title="Class对象的作用"></a>Class对象的作用</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><blockquote>
<p>创建类的对象：调用Class对象的newInstance()方法。</p>
<p>该方法要求： </p>
<ol>
<li><p>类必须有一个无参数的构造器。</p>
</li>
<li><p>类的构造器的访问权限需要足够。</p>
</li>
</ol>
<p>无论有没有无参构造器都可以实例化对象。</p>
<p>步骤如下：</p>
<ol>
<li><p>通过 Class 类的 **getDeclaredConstructor(Class… parameterTypes)**取得本类指定形参类型的构造器。</p>
</li>
<li><p>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</p>
</li>
<li><p>通过 Constructor 实例化对象。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（创建对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过反射创建运行时的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewInstanceTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * class.newInstance: 调用的是运行时类的空参构造器 通常使用.newInstance创建对象</span></span><br><span class="line"><span class="comment">     * 如果Person没有空参构造器，则会抛出异常 InstantiationException</span></span><br><span class="line"><span class="comment">     * 如果Person的空参构造是private的，那么抛出异常 IllegalAccessException，</span></span><br><span class="line"><span class="comment">     * public 和 default 等（与包的修饰符相同）的可以</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在JavaBean中要求提供一个public的空参构造器</span></span><br><span class="line"><span class="comment">     * 两个原因：</span></span><br><span class="line"><span class="comment">     *    1. 便于通过反射，创建运行时类的对象</span></span><br><span class="line"><span class="comment">     *    2. 便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="comment">//Person [name=null, age=0]</span></span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class.newInstance() since9 废弃 改用Constructor.newInstance(Object ...initargs)</span></span><br><span class="line"><span class="comment">     * 原因：构造函数引发的异常，绕过了编译期的异常检查。</span></span><br><span class="line"><span class="comment">     * Constructor 的 newInstance(Object ... initargs) 将异常封装在了 InvocationTargetException中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用Class.newInstance() since9 废弃</span></span><br><span class="line">        Class&lt;Person&gt; p1 = Person.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1.newInstance();</span><br><span class="line">            <span class="comment">// 此处在编译器未能检查到IOException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改用Constructor 的 newInstance(Object ... initargs)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 构造函数引发的异常，包装在了 InvocationTargetException</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> p1.getDeclaredConstructor().newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException</span><br><span class="line">                 | NoSuchMethodException | SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        反射的动态性举例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">classpath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">switch</span> (num) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                classpath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">// java.sql.Date 没有空参构造</span></span><br><span class="line">                <span class="comment">/*public Date(long date) &#123;</span></span><br><span class="line"><span class="comment">                       // If the millisecond date value contains time info, mask it out.</span></span><br><span class="line"><span class="comment">                       super(date);</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">                   &#125;*/</span></span><br><span class="line">                classpath = <span class="string">&quot;java.sql.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                classpath = <span class="string">&quot;com.example.reflect.Person&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> getInstance(classpath);</span><br><span class="line">            System.out.println(instance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(String classpath)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123;</span><br><span class="line">        Class&lt;?&gt; forName = Class.forName(classpath);</span><br><span class="line">        <span class="keyword">return</span> forName.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="comment">// return forName.newInstance();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h3><blockquote>
<p><strong>主要包括：Field、Method、Constructor、Superclass、Interface、Annotation。</strong></p>
<p>即：实现的全部接口、所继承的父类、全部的构造器、全部的方法、全部的Field。</p>
<p>使用反射可以获得：</p>
<ul>
<li><p>实现的全部接口</p>
<ul>
<li><strong>public Class[] getInterfaces()</strong> 确定此对象所表示的类或接口实现的接口。</li>
</ul>
</li>
<li><p>所继承的父类</p>
<ul>
<li><strong>public Class getSuperclass()</strong> 返回表示此Class所表示的实体（类、接口、基本类型）的父类的Class。</li>
</ul>
</li>
<li><p>全部的构造器</p>
<ul>
<li><p><strong>public Constructor[] getConstructors()</strong> 返回此Class对象所表示的类的所有 public构造方法。</p>
</li>
<li><p><strong>public Constructor[] getDeclaredConstructors()</strong> 返回此 Class 对象表示的类声明的所有构造方法。</p>
</li>
<li><p>Constructor类中：</p>
<p>取得修饰符：<strong>public int getModifiers( );</strong> </p>
<p>取得方法名称：<strong>public String getName( );</strong></p>
<p>取得参数的类型：<strong>public Class[] getParameterTypes( );</strong></p>
</li>
</ul>
</li>
<li><p>全部的方法</p>
<ul>
<li><p><strong>public Method[] getDeclaredMethods()</strong> 返回此Class对象所表示的类或接口的全部方法。</p>
</li>
<li><p><strong>public Method[] getMethods()</strong> 返回此Class对象所表示的当前类或父类或接口的 public 的方法。</p>
</li>
<li><p>Method类中： </p>
<p><strong>public Class getReturnType()</strong>     取得全部的返回值。</p>
<p><strong>public Class[] getParameterTypes()</strong>   取得全部的参数 。</p>
<p><strong>public int getModifiers()</strong>     取得修饰符。</p>
<p><strong>public Class[] getExceptionTypes()</strong> 取得异常信息。</p>
</li>
</ul>
</li>
<li><p>全部的Field</p>
<ul>
<li><p><strong>public Field[] getFields()</strong> 返回此Class对象所表示的类或接口的public的Field。</p>
</li>
<li><p><strong>public Field[] getDeclaredFields()</strong> 返回此Class对象所表示的类或接口的全部Field。</p>
</li>
<li><p>Field方法中：</p>
<p><strong>public int getModifiers()</strong> 以整数形式返回此Field的修饰符。</p>
<p><strong>public Class getType()</strong> 得到Field的属性类型。</p>
<p><strong>public String getName()</strong> 返回Field的名称。</p>
</li>
</ul>
</li>
<li><p>Annotation相关 </p>
<ul>
<li><strong>get Annotation(Class annotationClass)  getDeclaredAnnotations()</strong></li>
</ul>
</li>
<li><p>泛型相关</p>
<ul>
<li>获取父类泛型类型：<strong>Type getGenericSuperclass()</strong> </li>
<li>泛型类型：<strong>ParameterizedType</strong></li>
<li>获取实际的泛型类型参数数组：<strong>getActualTypeArguments()</strong></li>
</ul>
</li>
<li><p>类所在的包</p>
<ul>
<li><strong>Package getPackage()</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p>代码示例：（获取运行时类的完整结构）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取运行时的类属性结构</span></span><br><span class="line"><span class="comment"> * getFields() 获取当前运行类及其父类中【只声明为public】访问权限的的属性</span></span><br><span class="line"><span class="comment"> * getDeclaredFields() 获取当前运行类中所有声明的属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查看Field 的修饰符，数据类型，变量名</span></span><br><span class="line"><span class="comment"> * getModifiers(): 获取权限修饰符,返回的值为int，可参考类Modifier：Modifier.toString()</span></span><br><span class="line"><span class="comment"> *     Modifer:</span></span><br><span class="line"><span class="comment"> *          public static final int PUBLIC = 0x00000001;</span></span><br><span class="line"><span class="comment"> *          public static final int PRIVATE = 0x00000002;</span></span><br><span class="line"><span class="comment"> *          public static final int PROTECTED = 0x00000004;</span></span><br><span class="line"><span class="comment"> * Modifier.toString(i)</span></span><br><span class="line"><span class="comment"> * getType(): 数据类型</span></span><br><span class="line"><span class="comment"> * getName(): 属性名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getFields() 获取当前运行类及其父类中【只声明为public】访问权限的的属性</span></span><br><span class="line"><span class="comment">     * getDeclaredFields() 获取当前运行类中所有声明的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;PersonPlus&gt; person = PersonPlus.class;</span><br><span class="line">        Field[] fields = person.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//    public int com.example.reflect.PersonPlus.id</span></span><br><span class="line">        <span class="comment">//    public double com.example.reflect.Creature.weight</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        Field[] declaredFields = person.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//    private java.lang.Object com.example.reflect.PersonPlus.name</span></span><br><span class="line">        <span class="comment">//    int com.example.reflect.PersonPlus.age</span></span><br><span class="line">        <span class="comment">//    public int com.example.reflect.PersonPlus.id</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看Field 的修饰符，数据类型，变量名</span></span><br><span class="line"><span class="comment">     * getModifiers(): 获取权限修饰符,返回的值为int，可参考类Modifier：Modifier.toString()</span></span><br><span class="line"><span class="comment">     * Modifier:</span></span><br><span class="line"><span class="comment">     *      public static final int PUBLIC = 0x00000001;</span></span><br><span class="line"><span class="comment">     *      public static final int PRIVATE = 0x00000002;</span></span><br><span class="line"><span class="comment">     *      public static final int PROTECTED = 0x00000004;</span></span><br><span class="line"><span class="comment">     * getType(): 数据类型</span></span><br><span class="line"><span class="comment">     * getName(): 属性名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;PersonPlus&gt; person = PersonPlus.class;</span><br><span class="line">        Field[] declaredFields = person.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">            <span class="comment">//获取权限修饰符,返回的值为int，可参考类Modifier</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> field.getModifiers();</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>+ Modifier.toString(i)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="comment">//数据类型</span></span><br><span class="line">            Class&lt;?&gt; type = field.getType();</span><br><span class="line">            System.out.print(type.getName()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="comment">//变量名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> field.getName();</span><br><span class="line">            System.out.print(name);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">// output:</span></span><br><span class="line">            <span class="comment">//       2 private  java.lang.Object   name</span></span><br><span class="line">            <span class="comment">//       0        int                age</span></span><br><span class="line">            <span class="comment">//       1 public   int    id</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（方法结构）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行时方法结构</span></span><br><span class="line"><span class="comment"> * getMethods(): 获取【当前类及其父类】中声明为 public 的权限的方法，不包含构造方法</span></span><br><span class="line"><span class="comment"> * getDeclaredMethods()获取【当前类】中所有声明的方法（不包括父类），不包含构造方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注解、权限修饰符、方法签名</span></span><br><span class="line"><span class="comment"> *        注解如果标注为 Source(编译器) 则获取不到</span></span><br><span class="line"><span class="comment"> * getModifiers(): 权限修饰符：int: Modifier.toString()</span></span><br><span class="line"><span class="comment"> * getReturnType(): 返回值类型</span></span><br><span class="line"><span class="comment"> * getName(): 方法名</span></span><br><span class="line"><span class="comment"> * getParameterTypes(): 方法的参数</span></span><br><span class="line"><span class="comment"> * getExceptionTypes(): 方法异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * getConstructors() 获取当前类中声明为public 的构造器</span></span><br><span class="line"><span class="comment"> * getDeclaredConstructors() 获取当前类中所有的构造器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取带泛型的父类的泛型 Type类</span></span><br><span class="line"><span class="comment"> * getGenericSuperclass 获取带泛型的父类，造型为ParameterizedType</span></span><br><span class="line"><span class="comment"> * (ParameterizedType) genericSuperclass</span></span><br><span class="line"><span class="comment"> * parameterizedType.getActualTypeArguments();</span></span><br><span class="line"><span class="comment"> * public interface ParameterizedType extends Type</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * getInterfaces(): 获取接口</span></span><br><span class="line"><span class="comment"> * getSuperclass(): 获取父类</span></span><br><span class="line"><span class="comment"> * getPackage()：包</span></span><br><span class="line"><span class="comment"> * getAnnotations()：注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getMethods(): 获取【当前类及其父类】中声明为 public 的权限的方法，不包含构造方法</span></span><br><span class="line"><span class="comment">     * getDeclaredMethods()获取【当前类】中所有声明的方法（不包括父类），不包含构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">person</span> <span class="operator">=</span> PersonPlus.class;</span><br><span class="line">        Method[] methods = person.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// output:</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * public java.lang.String com.example.reflect.PersonPlus.display(java.lang.String)</span></span><br><span class="line"><span class="comment">         public int com.example.reflect.PersonPlus.compareTo(java.lang.Object)</span></span><br><span class="line"><span class="comment">         public int com.example.reflect.PersonPlus.compareTo(java.lang.String)</span></span><br><span class="line"><span class="comment">         public void com.example.reflect.PersonPlus.info()</span></span><br><span class="line"><span class="comment">         public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">         public final void java.lang.Object.wait() throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">         public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">         public boolean java.lang.Object.equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">         public java.lang.String java.lang.Object.toString()</span></span><br><span class="line"><span class="comment">         public native int java.lang.Object.hashCode()</span></span><br><span class="line"><span class="comment">         public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">         public final native void java.lang.Object.notify()</span></span><br><span class="line"><span class="comment">         public final native void java.lang.Object.notifyAll()</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        Method[] declaredMethods = person.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : declaredMethods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// output:</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * public java.lang.String com.example.reflect.PersonPlus.display(java.lang.String)</span></span><br><span class="line"><span class="comment">         public int com.example.reflect.PersonPlus.compareTo(java.lang.Object)</span></span><br><span class="line"><span class="comment">         public int com.example.reflect.PersonPlus.compareTo(java.lang.String)</span></span><br><span class="line"><span class="comment">         public void com.example.reflect.PersonPlus.info()</span></span><br><span class="line"><span class="comment">         private java.lang.String com.example.reflect.PersonPlus.show(java.lang.String)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解、权限修饰符、方法签名</span></span><br><span class="line"><span class="comment">     *        注解如果标注为 Source 则获取不到</span></span><br><span class="line"><span class="comment">     * getAnnotations(): 获取注解</span></span><br><span class="line"><span class="comment">     * getModifiers(): 权限修饰符：int: Modifier.toString()</span></span><br><span class="line"><span class="comment">     * getReturnType(): 返回值类型</span></span><br><span class="line"><span class="comment">     * getName(): 方法名</span></span><br><span class="line"><span class="comment">     * getParameterTypes(): 方法的参数</span></span><br><span class="line"><span class="comment">     * getExceptionTypes(): 方法异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//注解如果标注为 Source 则获取不到</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">person</span> <span class="operator">=</span> PersonPlus.class;</span><br><span class="line">        Method[] declaredMethods = person.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : declaredMethods) &#123;</span><br><span class="line">            <span class="comment">//1. 获取注解</span></span><br><span class="line">            Annotation[] annotations = method.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (Annotation a : annotations) &#123;</span><br><span class="line">                System.out.print(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 权限修饰符</span></span><br><span class="line">            System.out.print(Modifier.toString(method.getModifiers()) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">// 返回值类型</span></span><br><span class="line">            System.out.print(method.getReturnType() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="comment">// 方法名</span></span><br><span class="line">            System.out.print(method.getName());</span><br><span class="line">            <span class="comment">// 方法参数</span></span><br><span class="line">            System.out.print(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (parameterTypes != <span class="literal">null</span> &amp;&amp; parameterTypes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == parameterTypes.length - <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.print(parameterTypes[i].getName() + <span class="string">&quot; args_&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(parameterTypes[i].getName() + <span class="string">&quot; args_&quot;</span> + i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="comment">// 抛出的异常</span></span><br><span class="line">            Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();</span><br><span class="line">            <span class="keyword">if</span> (exceptionTypes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; throws &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; exceptionTypes.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == exceptionTypes.length - <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.print(exceptionTypes[i].getName());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(exceptionTypes[i].getName() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getConstructors() 获取当前类中声明为public 的构造器</span></span><br><span class="line"><span class="comment">     * getDeclaredConstructors() 获取当前类中所有的构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> PersonPlus.class;</span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取带泛型的父类的泛型 Type类</span></span><br><span class="line"><span class="comment">     * getGenericSuperclass 获取父类，造型为ParameterizedType</span></span><br><span class="line"><span class="comment">     * (ParameterizedType) genericSuperclass</span></span><br><span class="line"><span class="comment">     * parameterizedType.getActualTypeArguments();</span></span><br><span class="line"><span class="comment">     * public interface ParameterizedType extends Type </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">person</span> <span class="operator">=</span> PersonPlus.class;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> person.getGenericSuperclass();</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">        <span class="comment">//com.example.reflect.Creature&lt;String&gt;</span></span><br><span class="line">        System.out.println(genericSuperclass);</span><br><span class="line">        <span class="comment">// Class实现了Type类</span></span><br><span class="line">        System.out.println(actualTypeArguments[<span class="number">0</span>].getTypeName()); <span class="comment">// String</span></span><br><span class="line"><span class="comment">//    System.out.println(((Class)actualTypeArguments[0]).getName());// java.lang.ClassCastException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getInterfaces(): 获取接口</span></span><br><span class="line"><span class="comment">     * getSuperclass(): 获取父类</span></span><br><span class="line"><span class="comment">     * getPackage()：包</span></span><br><span class="line"><span class="comment">     * getAnnotations()：注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">person</span> <span class="operator">=</span> PersonPlus.class;</span><br><span class="line">        Class[] interfaces = person.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class class1 : interfaces) &#123;</span><br><span class="line">            System.out.println(class1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> person.getSuperclass();</span><br><span class="line">        <span class="keyword">for</span> (Class class2 : superclass.getInterfaces()) &#123;</span><br><span class="line">            System.out.println(class2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Package</span> <span class="variable">package1</span> <span class="operator">=</span> person.getPackage();</span><br><span class="line">        System.out.println(package1);</span><br><span class="line">        Annotation[] annotations = person.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// output:</span></span><br><span class="line"><span class="comment">//    interface com.example.reflect.MyInterface</span></span><br><span class="line"><span class="comment">//    interface java.lang.Comparable</span></span><br><span class="line"><span class="comment">//    interface java.io.Serializable</span></span><br><span class="line"><span class="comment">//    package com.example.reflect</span></span><br><span class="line"><span class="comment">//    @com.example.reflect.MyAnnotation(value=hello)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用运行时类的指定结构"><a href="#调用运行时类的指定结构" class="headerlink" title="调用运行时类的指定结构"></a>调用运行时类的指定结构</h3><blockquote>
<p><strong>调用指定方法</strong></p>
<p>通过反射，调用类中的方法，通过 Method 类完成。</p>
<p>步骤：</p>
<ol>
<li><p>通过Class类的  <strong>getMethod(String name, Class… parameterTypes)</strong> 方法取得一个 Method 对象，并设置此方法操作时所需要的参数类型。</p>
</li>
<li><p>使用 <strong>Object invoke(Object obj, Object[ ] args)</strong> 进行调用，并向方法中传递要设置的 obj 对象的参数信息。</p>
</li>
</ol>
<p>Object invoke(Object obj, Object… args) 说明：</p>
<ul>
<li>Object 对应原方法的返回值，若原方法无返回值，此时返回null。</li>
<li>若原方法若为静态方法，此时形参 Object obj 可为 null。</li>
<li>若原方法形参列表为空，则 Object[] args 为 null。</li>
<li>若原方法声明为 private，则需要在调用此 invoke( ) 方法前，显式调用方法对象的 setAccessible(true) 方法，将可访问 private 的方法。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>调用指定属性</strong></p>
<p>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。</p>
<ul>
<li><strong>public Field getField(String name)</strong> 返回此Class对象表示的类或接口的指定的 public的Field。</li>
<li>**public Field getDeclaredField(String name)**返回此Class对象表示的类或接口的指定的Field。</li>
</ul>
<p>在Field中： </p>
<ul>
<li><strong>public Object get(Object obj)</strong> 取得指定对象obj上此Field的属性内容。</li>
<li><strong>public void set(Object obj,Object value)</strong> 设置指定对象obj上此Field的属性内容。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>setAccessible方法的使用</strong></p>
<ol>
<li>Method和Field、Constructor对象都有setAccessible()方法。</li>
<li>setAccessible 启动和禁用访问安全检查的开关。</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。</li>
</ol>
<p>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为 true。</p>
<p>使得原本无法访问的私有成员也可以访问。</p>
<p>参数值为 false 则指示反射的对象应该实施 Java 语言访问检查。</p>
</blockquote>
<p>代码示例：（反射调用指定结构）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用方法和给属性赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldMethodInvokeTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试获取指定的属性和方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LiuFei</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">person</span> <span class="operator">=</span> PersonPlus.class;</span><br><span class="line">        <span class="type">PersonPlus</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonPlus</span>();</span><br><span class="line">        <span class="comment">///要求运行类中的值声明为public，通常不用此方法,而用getDeclaredField()</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">id</span> <span class="operator">=</span> person.getField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="comment">//给id赋值：需创建对象</span></span><br><span class="line">        id.set(p, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前属性的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> (<span class="type">int</span>) id.get(p);</span><br><span class="line">        System.out.println(pid); <span class="comment">//12</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> person.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(p, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(name.get(p)); <span class="comment">//Tom</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">person</span> <span class="operator">=</span> PersonPlus.class;</span><br><span class="line">        <span class="type">PersonPlus</span> <span class="variable">p</span> <span class="operator">=</span> (PersonPlus) person.newInstance();</span><br><span class="line">        <span class="comment">//说明：这里有个问题：好像带泛型的类传的参数只能是Object.class</span></span><br><span class="line">        <span class="comment">//原因：因为将String作为泛型参数了</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> person.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, Object.class);</span><br><span class="line">        m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(m.invoke(p, <span class="string">&quot;China&quot;</span>));</span><br><span class="line">        Method[] declaredMethods = person.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : declaredMethods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用静态方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchFieldException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">person</span> <span class="operator">=</span> PersonPlus.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> person.getDeclaredMethod(<span class="string">&quot;testStatic&quot;</span>);</span><br><span class="line"><span class="comment">//    method.setAccessible(true);</span></span><br><span class="line">        <span class="comment">//返回值为void，仍然可以使用引用接受，返回为null</span></span><br><span class="line"><span class="comment">//    Object invoke = method.invoke(PersonPlus.class);</span></span><br><span class="line"><span class="comment">//    public Object invoke(Object obj, Object... args)</span></span><br><span class="line">        <span class="comment">// 传入null: 静态方法属于类，可以直接使用类名，不需要传入参数（类.class）就可以</span></span><br><span class="line"><span class="comment">//    Object invoke = method.invoke(null); //必须有一个Object</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(PersonPlus.class); <span class="comment">//必须有一个Object</span></span><br><span class="line">        System.out.println(invoke); <span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用构造方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">person</span> <span class="operator">=</span> PersonPlus.class;</span><br><span class="line"><span class="comment">//    Constructor con = person.getDeclaredConstructor(String.class);//String泛型</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> person.getDeclaredConstructor(Object.class);</span><br><span class="line">        con.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        PersonPlus&lt;String&gt; newInstance = (PersonPlus&lt;String&gt;) con.newInstance(<span class="string">&quot;Kitty&quot;</span>);</span><br><span class="line">        System.out.println(newInstance.toString()); <span class="comment">//PersonPlus [name=Kitty, age=0, id=0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加载外部配置文件"><a href="#加载外部配置文件" class="headerlink" title="加载外部配置文件"></a>加载外部配置文件</h3><p>代码示例：（Classloader的使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件的加载路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilePositionTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * io流的方式</span></span><br><span class="line"><span class="comment">     * new FileInputStream()/new FileReader()等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//    第一种方式加载文件：默认文件的位置在工程/模块下</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;filePosition.properties&quot;</span>);</span><br><span class="line">        p.load(fis);</span><br><span class="line">        System.out.println(p.getProperty(<span class="string">&quot;value&quot;</span>)); <span class="comment">// ProjectValue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        也可以使用src\\加载src下的文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/filePosition.properties&quot;</span>);</span><br><span class="line">        p.load(fis2);</span><br><span class="line">        System.out.println(p.getProperty(<span class="string">&quot;value&quot;</span>)); <span class="comment">// SrcValue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * java.util.ResourceBundle加载 properties文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 也可以加载流的方式</span></span><br><span class="line"><span class="comment">//        ResourceBundle resource = new PropertyResourceBundle(inputStream);</span></span><br><span class="line">        <span class="comment">// 注意：不需要加 properties后缀名</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;filePosition&quot;</span>);</span><br><span class="line">        System.out.println(bundle.getString(<span class="string">&quot;value&quot;</span>)); <span class="comment">//resourcesValue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ClassLoader的方式：所有路径不加 /</span></span><br><span class="line"><span class="comment">     * XXX.class.getResourceAsStream()：类所在包下加载</span></span><br><span class="line"><span class="comment">     * XXX.class.getClassLoader().getResourceStream(): 类路径</span></span><br><span class="line"><span class="comment">     * Thread.currentThread().getContextClassLoader().getResourceAsStream(): 类路径</span></span><br><span class="line"><span class="comment">     * 注意：resources下的资源路径即为类路径，即src。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//第二种方式：使用ClassLoader加载，文件路径默认在src下</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> ReflectTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;filePosition.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//报错，需要放在src下</span></span><br><span class="line">        p.load(in);</span><br><span class="line">        System.out.println(p.getProperty(<span class="string">&quot;value&quot;</span>)); <span class="comment">// SrcValue</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in2</span> <span class="operator">=</span> ReflectTest.class.getResourceAsStream(<span class="string">&quot;filePosition.properties&quot;</span>);</span><br><span class="line">        p.load(in2);</span><br><span class="line">        System.out.println(p.getProperty(<span class="string">&quot;value&quot;</span>)); <span class="comment">// CurrentClassValue</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//src目录下</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in3</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">&quot;filePosition.properties&quot;</span>);</span><br><span class="line">        p.load(in3);</span><br><span class="line">        System.out.println(p.getProperty(<span class="string">&quot;value&quot;</span>)); <span class="comment">// SrcValue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射的应用：动态代理"><a href="#反射的应用：动态代理" class="headerlink" title="反射的应用：动态代理"></a>反射的应用：动态代理</h2><blockquote>
<p><strong>代理设计模式的原理：</strong></p>
<p>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p>
<p>对于静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。</p>
<p>同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能。</p>
<p><strong>动态代理</strong>是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</p>
<p>动态代理使用场合：调试远程方法调用。</p>
<p>动态代理相比于静态代理的优点：抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样可以更加灵活和统一的处理众多的方法。</p>
</blockquote>
<blockquote>
<p><strong>Java动态代理相关API：</strong></p>
<p><strong>Proxy：</strong>专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。 提供用于创建动态代理类和动态代理对象的静态方法：</p>
<p><strong>1.</strong>   <strong>static Class getProxyClass(ClassLoader loader, Class… interfaces)</strong> </p>
<p>创建一个动态代理类所对应的<strong>Class对象</strong>。</p>
<p><strong>2.</strong>   <strong>static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</strong> </p>
<p>直接创建一个动态<strong>代理对象</strong>。</p>
<p><strong>动态代理步骤</strong></p>
<p>创建一个实现接口InvocationHandler的类，它必须实现invoke方法，以完成代理的具体操作。</p>
</blockquote>
<p><strong>静态代理：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ProxyClothFactory</span>(<span class="keyword">new</span> <span class="title class_">BrandClothFactory</span>()).produceCloth();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Some before... Origin.... Some After...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ClothFactory</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ClothFactory clothFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyClothFactory</span><span class="params">(ClothFactory clothFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clothFactory = clothFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Some before...&quot;</span>);</span><br><span class="line">        clothFactory.produceCloth();</span><br><span class="line">        System.out.println(<span class="string">&quot;Some After...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrandClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Origin....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态代理：</strong></p>
<p>代码示例：（动态代理）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象(被代理对象)</span></span><br><span class="line">        <span class="type">TeacherDao</span> <span class="variable">teacherDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();</span><br><span class="line">        <span class="comment">//创建代理对象, 同时将被代理对象传递给代理对象</span></span><br><span class="line">        <span class="type">ITeacherDao</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (ITeacherDao) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(teacherDao).getProxyInstance();</span><br><span class="line">        <span class="comment">//通过代理对象，调用到被代理对象的方法</span></span><br><span class="line">        <span class="comment">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法</span></span><br><span class="line">        System.out.println(proxyInstance.teach());</span><br><span class="line">        proxyInstance.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITeacherDao</span> &#123;</span><br><span class="line">    String <span class="title function_">teach</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;teaching...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;teacher teaching...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;teacher say...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象 生成一个代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">         Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">         InvocationHandler h)</span></span><br><span class="line"><span class="comment">         //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class="line"><span class="comment">         //2. Class&lt;?&gt;[] interfaces： 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">         //3. InvocationHandler h ： 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                (InvocationHandler) <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="comment">// proxy：代理类</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;JDK代理开始~~&quot;</span>);</span><br><span class="line">                        <span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;JDK代理提交&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Human</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Human) ProxyFactory2.getProxyInstance(<span class="keyword">new</span> <span class="title class_">SuperMan</span>());</span><br><span class="line">        System.out.println(proxyInstance.getBelife());</span><br><span class="line"><span class="comment">//    proxyInstance.getBelife();</span></span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;何以居&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    String <span class="title function_">getBelife</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBelife</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println( <span class="string">&quot;getBelife...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe fly&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现动态代理需要解决的问题：</span></span><br><span class="line"><span class="comment">     * 问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</span></span><br><span class="line"><span class="comment">     * 问题二：当通过调用代理类的对象的方法时，如何动态的调用被代理类的同名方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperMan: &quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory2</span> &#123;</span><br><span class="line">    <span class="comment">// obj 为被代理的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">myInvocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>();</span><br><span class="line">        myInvocationHandler.bind(obj);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),</span><br><span class="line">                myInvocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当代理类的对象调用方法时，就会自动调用invoke()方法。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JDK代理开始&quot;</span>);</span><br><span class="line">        <span class="comment">// 代理类对象调用的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">invokeVal</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;JDK代理提交&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invokeVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

























<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型的设计背景"><a href="#泛型的设计背景" class="headerlink" title="泛型的设计背景"></a>泛型的设计背景</h2><blockquote>
<p>集合容器类在设计阶段&#x2F;声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection<E>，List<E>，ArrayList<E> 这个<E>就是类型参数，即泛型。</E></E></E></E></p>
</blockquote>
<h2 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h2><blockquote>
<p>所谓泛型，就是<strong>允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。</strong>这个类型参数将在使用时（例如继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。</p>
<p>从JDK1.5以后，Java引入了”参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List<String>，这表明该List只能保存字符串类型的对象。JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。</String></p>
</blockquote>
<h2 id="为什么要有泛型（Generic）"><a href="#为什么要有泛型（Generic）" class="headerlink" title="为什么要有泛型（Generic）"></a>为什么要有泛型（Generic）</h2><blockquote>
<p>那么为什么要有泛型呢，直接Object不是也可以存储数据吗？</p>
<ol>
<li><p>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。</p>
</li>
<li><p>解决获取数据元素时，需要类型强制转换的问题。</p>
</li>
<li><p>使用泛型的主要优点是<strong>能够在编译时而不是在运行时检测错误。</strong></p>
</li>
</ol>
<p>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。<strong>使用泛型的主要优点是能够在编译时而不是在运行时检测错误。</strong></p>
</blockquote>
<h2 id="自定义泛型结构"><a href="#自定义泛型结构" class="headerlink" title="自定义泛型结构"></a>自定义泛型结构</h2><blockquote>
<ul>
<li><p>泛型的声明</p>
<ul>
<li>interface List<T> 和 class GenTest&lt;K,V&gt;</T></li>
<li>其中，T，K，V不代表值，而是表示类型。这里使用任意字母都可以。常用 T 表示，Type的缩写。</li>
</ul>
</li>
<li><p>泛型的实例化</p>
<ul>
<li>一定要在类名后面指定类型参数的值（类型）。</li>
<li>T 只能是类，不能用基本数据类型填充，但可以使用包装类填充把一个集合中的内容限制为一个特定的数据类型，这就是 generics 背后的核心思想。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="泛型类、泛型接口"><a href="#泛型类、泛型接口" class="headerlink" title="泛型类、泛型接口"></a>泛型类、泛型接口</h2><blockquote>
<p>\1. 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：**&lt;E1,E2,E3&gt;。**</p>
<p>\2. 泛型类的构造器如下：<strong>public GenericClass(){ }。</strong>而下面是错误的：public GenericClass<E>(){ }。</E></p>
<p>\3. 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</p>
<p>\4. 泛型不同的引用不能相互赋值。</p>
<p>尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。</Integer></String></p>
<p>\1.   泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。经验：泛型要使用一路都用。要不用，一路都不要用。</p>
<p>\6. 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。</p>
<p>\7. jdk1.7，泛型的简化操作：ArrayList<Fruit> flist &#x3D; new ArrayList&lt;&gt;();</Fruit></p>
<p>\8. 泛型的指定中不能使用基本数据类型，可以使用包装类替换。</p>
<p>\9. 在类&#x2F;接口上声明的泛型，在本类或本接口中即代表某种类型<strong>，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。可以使用方法的泛型。</strong></p>
<p><strong>10. 异常类不能是泛型的。</strong></p>
<p>\11. 不能使用new E[]。但是可以：<strong>E[] elements &#x3D; (E[])new Object[capacity];</strong></p>
<p>参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</p>
<p>\1.   父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：</p>
<p>子类不保留父类的泛型：按需实现。</p>
<p>子类保留父类的泛型：泛型子类。</p>
<p>结论：子类除了指定或保留父类的泛型，还可以增加自己的泛型。</p>
</blockquote>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><blockquote>
<p>方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时参数的类型就是传入数据的类型。</p>
<p>格式：**[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常。**</p>
<p>泛型方法声明泛型时也可以指定上限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">genericGenericMethodTest01</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        必须加 &lt;E&gt; ，否则会把 E 当做 Class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; E <span class="title function_">method</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>代码示例：（泛型方法使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试泛型方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">genericGenericMethodTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fromArrayToCollection</span><span class="params">(T[] array, Collection&lt;T&gt; collection)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (T t : array) &#123;</span><br><span class="line">            collection.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Object[] ao = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        Collection&lt;Object&gt; co = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        fromArrayToCollection(ao, co);</span><br><span class="line"></span><br><span class="line">        String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">20</span>];</span><br><span class="line">        Collection&lt;String&gt; cs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        fromArrayToCollection(s, cs);</span><br><span class="line"></span><br><span class="line">        Collection&lt;Double&gt; cd = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 下面代码中T是Double类，但sa是String类型，编译错误</span></span><br><span class="line">        <span class="comment">// fromArrayToCollection(s,cd);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（测试泛型 extends ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 extends </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethod03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Generic Method...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">        test(<span class="keyword">new</span> <span class="title class_">Man</span>());</span><br><span class="line">        <span class="comment">// 编译错误：no instance(s) of type variable(s) exist so that Creature conforms to Person</span></span><br><span class="line">        <span class="comment">// test(new Creature());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGenericExtends</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Person[] person = new Man[1];</span></span><br><span class="line">        Person[] person = <span class="literal">null</span>;</span><br><span class="line">        Man[] man = <span class="literal">null</span>;</span><br><span class="line">        person = man;</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; lp = <span class="literal">null</span>;</span><br><span class="line">        List&lt;Man&gt; lm = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// lp = lm; //编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型在继承上的体现"><a href="#泛型在继承上的体现" class="headerlink" title="泛型在继承上的体现"></a>泛型在继承上的体现</h2><blockquote>
<p>如果 B 是 A 的一个子类型（子类或者子接口），而 G 是具有泛型声明的类或接口，G<B> 并不是 G<A> 的子类型。比如：String 是 Object 的子类，但是 List<String> 并不是 List<Object> 的子类。</Object></String></A></B></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGenericExtends</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Person[] person = new Man[1];</span></span><br><span class="line">    Person[] person = <span class="literal">null</span>;</span><br><span class="line">    Man[] man = <span class="literal">null</span>;</span><br><span class="line">    person = man;</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; lp = <span class="literal">null</span>;</span><br><span class="line">    List&lt;Man&gt; lm = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// lp = lm; //编译报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="枚举类的使用场景"><a href="#枚举类的使用场景" class="headerlink" title="枚举类的使用场景"></a>枚举类的使用场景</h2><blockquote>
<p>类的对象只有有限个，确定的。如星期、性别、季节等。</p>
<p><strong>当需要定义一组常量时，强烈建议使用枚举类。</strong></p>
<p><strong>枚举类是类的一种，其中的数量就是类的实例数量。</strong></p>
</blockquote>
<h2 id="枚举类的实现"><a href="#枚举类的实现" class="headerlink" title="枚举类的实现"></a>枚举类的实现</h2><blockquote>
<ul>
<li>JDK1.5之前需要自定义枚举类。</li>
<li>JDK 1.5 新增的 enum 关键字用于定义枚举类。</li>
</ul>
<p>若枚举只有一个对象，则可以作为一种单例模式的实现方式。</p>
</blockquote>
<h2 id="枚举类的属性"><a href="#枚举类的属性" class="headerlink" title="枚举类的属性"></a>枚举类的属性</h2><blockquote>
<ol>
<li><p>枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰。</p>
</li>
<li><p>private final 修饰的属性应该在构造器中为其赋值。</p>
</li>
<li><p>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数。</p>
</li>
</ol>
</blockquote>
<h2 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h2><blockquote>
<ol>
<li><p>私有化类的构造器，保证不能在类的外部创建其对象</p>
</li>
<li><p>在类的内部创建枚举类的实例。声明为：public static final</p>
</li>
<li><p>对象如果有实例变量，应该声明为private final，并在构造器中初始化</p>
</li>
</ol>
</blockquote>
<p>代码示例：（自定义枚举）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义枚举类</span></span><br><span class="line"><span class="comment"> * 1. 私有化类的构造器，保证不能在类的外部创建其对象</span></span><br><span class="line"><span class="comment"> * 2. 在类的内部创建枚举类的实例。声明为：public static final</span></span><br><span class="line"><span class="comment"> * 3. 对象如果有实例变量，应该声明为private final，并在构造器中初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomEnumSeason</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASON_NAME;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASON_DESC;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CustomEnumSeason</span><span class="params">(String seasonname, String seasondesc)</span> &#123;</span><br><span class="line">        SEASON_NAME = seasonname;</span><br><span class="line">        SEASON_DESC = seasondesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CustomEnumSeason</span> <span class="variable">SPRING</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CustomEnumSeason</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CustomEnumSeason</span> <span class="variable">SUMMER</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CustomEnumSeason</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CustomEnumSeason</span> <span class="variable">AUTUMN</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CustomEnumSeason</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CustomEnumSeason</span> <span class="variable">WINTER</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CustomEnumSeason</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="enum定义枚举类"><a href="#enum定义枚举类" class="headerlink" title="enum定义枚举类"></a>enum定义枚举类</h2><blockquote>
<p><strong>使用说明</strong></p>
<ol>
<li><p>使用 enum 定义的枚举类默认继承了 <strong>java.lang.Enum</strong>类，因此不能继承其他类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Color.class.getSuperclass()); <span class="comment">// class java.lang.Enum</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举类的构造器只能使用 private 权限修饰符。</p>
</li>
<li><p>枚举类的所有实例必须在枚举类中显式列出( <strong>,</strong> 分隔 <strong>;</strong> 结尾)。</p>
</li>
<li><p>列出的实例系统会自动添加 public static final 修饰。</p>
</li>
<li><p>必须在枚举类的第一行声明枚举类对象。</p>
</li>
<li><p>JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式，case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（enum定义枚举）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用enum定义枚举类:</span></span><br><span class="line"><span class="comment"> * 1. 属性必须用private final修饰</span></span><br><span class="line"><span class="comment"> * 2. 枚举类不能继承其他类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSeason</span> &#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EnumSeason</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EnumSeason&#123;&quot;</span> + <span class="string">&quot;seasonName= &quot;</span> + seasonName + <span class="string">&quot;, seasonDesc= &quot;</span> + seasonDesc + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Enum类的主要方法"><a href="#Enum类的主要方法" class="headerlink" title="Enum类的主要方法"></a>Enum类的主要方法</h2><table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>valueOf()</strong></td>
<td>传递枚举类型的Class对象和枚举常量名称给静态方法valueOf()，会得到参数匹配的枚举常量</td>
</tr>
<tr>
<td><strong>toString()</strong></td>
<td>得到当前枚举常量的名称，可以重写</td>
</tr>
<tr>
<td><strong>equals()</strong></td>
<td>在枚举类型中直接使用 &#x3D;&#x3D; 来比较两个枚举常量是否相等，equals是不可变的</td>
</tr>
<tr>
<td><strong>hasCode()</strong></td>
<td>Enum的hasCode()和equals一致，不可变</td>
</tr>
<tr>
<td><strong>getDeclaringClass()</strong></td>
<td>得到枚举常量所属枚举类型的Class对象，可以判断两个枚举常量是否属于同一个枚举类型</td>
</tr>
<tr>
<td><strong>name()</strong></td>
<td>得到当前枚举常量的名称</td>
</tr>
<tr>
<td><strong>ordinal()</strong></td>
<td>下标，次序</td>
</tr>
<tr>
<td><strong>compareTo()</strong></td>
<td>实现了Comparable接口，可以比较两个常量的大小</td>
</tr>
<tr>
<td><strong>clone()</strong></td>
<td>枚举类型不能被clone，不变clone</td>
</tr>
<tr>
<td><strong>values()</strong></td>
<td>返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</td>
</tr>
<tr>
<td><strong>toString()</strong></td>
<td>返回当前枚举类对象常量的名称</td>
</tr>
<tr>
<td><strong>valueOf(String str)</strong></td>
<td>可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的”名字”。如不是，会有运行时异常：<strong>llegalArgumentException</strong>。</td>
</tr>
</tbody></table>
<h2 id="实现接口的枚举类"><a href="#实现接口的枚举类" class="headerlink" title="实现接口的枚举类"></a>实现接口的枚举类</h2><blockquote>
<ol>
<li><p>和普通 Java 类一样，枚举类可以实现一个或多个接口。</p>
</li>
<li><p>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则要统一实现该方法即可。</p>
</li>
<li><p>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法。</p>
</li>
</ol>
</blockquote>
<p>代码示例：（枚举实现接口）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum关键字定义的枚举类实现接口的情况</span></span><br><span class="line"><span class="comment"> * 情况一：实现接口，在enum类中实现抽象方法</span></span><br><span class="line"><span class="comment"> * 情况二：让枚举类的对象分别实现接口中的抽象方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">DrawColor</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在内部类中使用枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Color</span> <span class="keyword">implements</span> <span class="title class_">DrawColor</span> &#123;</span><br><span class="line">        RED(<span class="string">&quot;red&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;draw: red!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, GREEN(<span class="string">&quot;green&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;draw: green!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, BLUE(<span class="string">&quot;blue&quot;</span>), YELLOW(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Color</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.desc = desc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;draw other!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Color</span> <span class="variable">c1</span> <span class="operator">=</span> Color.RED;</span><br><span class="line">        System.out.println(c1.toString()); <span class="comment">// RED</span></span><br><span class="line">        System.out.println(Color.class.getSuperclass()); <span class="comment">// class java.lang.Enum</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            遍历枚举,下标从0开始</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Color c : Color.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;value: &quot;</span> + c + <span class="string">&quot;\t index: &quot;</span> +c.ordinal());</span><br><span class="line">            <span class="comment">//value: RED	 index: 0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            线程状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Thread.State[] states = Thread.State.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; states.length; i++) &#123;</span><br><span class="line">            System.out.println(states[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// NEW</span></span><br><span class="line">        <span class="comment">// RUNNABLE</span></span><br><span class="line">        <span class="comment">// BLOCKED</span></span><br><span class="line">        <span class="comment">// WAITING</span></span><br><span class="line">        <span class="comment">// TIMED_WAITING</span></span><br><span class="line">        <span class="comment">// TERMINATED</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            valueOf(String objName)：返回枚举类中对象名是objName的对象。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Color</span> <span class="variable">c</span> <span class="operator">=</span> Color.valueOf(<span class="string">&quot;RED&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果没有objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Color c2 = Color.valueOf(&quot;RED2&quot;);</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line">        c.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="Annotation-概述"><a href="#Annotation-概述" class="headerlink" title="Annotation 概述"></a>Annotation 概述</h2><blockquote>
<p>从 JDK 5.0 开始, Java 增加了对元数据（MetaData） 的支持, 也就是 Annotation（注解）。</p>
<p>Annotation 其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p>
<p>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容。当然它也支持自定义 Java 标注。</p>
<p>Annotation 可以像修饰符一样被使用，可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在 Annotation的 “name&#x3D;value” 对中。</p>
<p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。</p>
<p>注解是一种趋势，一定程度上可以说：框架 &#x3D; 注解 + 反射 + 设计模式。</p>
</blockquote>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote>
<ol>
<li><p>编写文档</p>
<p>javadoc 命令：javadoc demo.java 生成类似于API的文档</p>
</li>
<li><p>代码分析</p>
<p>通过代码的注解标识，对代码进行分析（使用反射）</p>
</li>
<li><p>编译检查</p>
<p>通过代码的注解标识，对代码进行检查（Override）</p>
</li>
</ol>
</blockquote>
<h2 id="常见的Annotation示例"><a href="#常见的Annotation示例" class="headerlink" title="常见的Annotation示例"></a>常见的Annotation示例</h2><h3 id="示例一：生成文档相关的注解"><a href="#示例一：生成文档相关的注解" class="headerlink" title="示例一：生成文档相关的注解"></a>示例一：生成文档相关的注解</h3><blockquote>
<p>@author 标明开发该类模块的作者，多个作者之间使用 , 分割</p>
<p>@version 标明该类模块的版本</p>
<p>@see 参考转向，也就是相关主题</p>
<p>@since 从哪个版本开始增加的</p>
<p>@param 对方法中某参数的说明，如果没有参数就不能写</p>
<p>@return 对方法返回值的说明，如果方法的返回值类型是void就不能写</p>
<p>@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写</p>
<p>其中</p>
<p>@param @return 和 @exception 这三个标记都是只用于方法的。</p>
<p>@param的格式要求：@param 形参名 形参类型 形参说明</p>
<p>@return 的格式要求：@return 返回值类型 返回值说明</p>
<p>@exception的格式要求：@exception 异常类型 异常说明</p>
<p>@param和@exception可以并列多个</p>
</blockquote>
<p>代码示例：（文档注解）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用javadoc编译</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavadocTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 程序的主方法，程序的入口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args String[] 命令行参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求圆面积</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> radius double 半径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> double 圆的面积</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getCircleArea</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例二：在编译时进行格式检查（JDK内置的三个基本注解）"><a href="#示例二：在编译时进行格式检查（JDK内置的三个基本注解）" class="headerlink" title="示例二：在编译时进行格式检查（JDK内置的三个基本注解）"></a>示例二：在编译时进行格式检查（JDK内置的三个基本注解）</h3><blockquote>
<p><strong>@Override</strong>：限定重写父类方法, 该注解只能用于方法。</p>
<p><strong>@Deprecated</strong>：用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择。</p>
<p><strong>@SuppressWarnings</strong>：抑制编译器警告。</p>
</blockquote>
<p>代码示例：（在编译时进行格式检查）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java内置的三个注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuiltInAnnotationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过时的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;重写的toString方法()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例三：跟踪代码依赖性，实现替代配置文件功能"><a href="#示例三：跟踪代码依赖性，实现替代配置文件功能" class="headerlink" title="示例三：跟踪代码依赖性，实现替代配置文件功能"></a>示例三：跟踪代码依赖性，实现替代配置文件功能</h3><p>Servlet3.0 提供了注解（annotation），使得不再需要在 web.xml 文件中进行 Servlet 的部署。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span></span><br><span class="line">            ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span></span><br><span class="line">            ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK内置注解"><a href="#JDK内置注解" class="headerlink" title="JDK内置注解"></a>JDK内置注解</h2><blockquote>
<p><strong>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</strong></p>
<p><strong>内置注解（3个）</strong></p>
<p>@Override：检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</p>
<p>@Deprecated：标记过时方法。如果使用该方法，会报编译警告。</p>
<p>@SuppressWarnings：指示编译器去忽略注解中声明的警告。</p>
</blockquote>
<h2 id="元注解（用于修饰其他-Annotation）"><a href="#元注解（用于修饰其他-Annotation）" class="headerlink" title="元注解（用于修饰其他 Annotation）"></a>元注解（用于修饰其他 Annotation）</h2><blockquote>
<p><strong>元注解：用于修饰其他 Annotation。</strong></p>
<p>JDK5.0提供了4个标准的meta-annotation类型，分别是：</p>
<ol>
<li>@Retention：标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>
</ol>
<p>只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, @Rentention 包含一个 <strong>RetentionPolicy</strong> 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值。</p>
<p><strong>RetentionPolicy.SOURCE</strong>：在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释。</p>
<p><strong>RetentionPolicy.CLASS</strong>：在class文件中有效（即class保留），当运行 Java 程序时, JVM不会保留注解。<strong>这是默认值。</strong></p>
<p><strong>RetentionPolicy.RUNTIME</strong>：在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。</p>
<p><strong>2.</strong>   @Documented：标记这些注解是否包含在用户文档中。用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc工具提取成文档。<strong>默认情况下，javadoc是不包括注解的</strong>。<strong>定义为Documented的注解必须设置Retention值为RUNTIME。</strong></p>
<ol start="3">
<li>@Target：标记这个注解应该是哪种 Java 成员。用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。@Target 也包含一个名为 value 的成员变量。</li>
</ol>
<table>
<thead>
<tr>
<th>取值（ElementType）</th>
<th></th>
<th>取值（ElementType）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>CONSTRUCTOR</td>
<td>用于描述构造器</td>
<td>PACKAGE</td>
<td>包</td>
</tr>
<tr>
<td>FIELD</td>
<td>域</td>
<td>PARAMETER</td>
<td>参数</td>
</tr>
<tr>
<td>LOCAL_VARIABLE</td>
<td>局部变量</td>
<td>TYPE</td>
<td>类、接口、enum、</td>
</tr>
<tr>
<td>METHOD</td>
<td>方法</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="4">
<li>@Inherited：标记这个注解是继承于哪个注解类(默认注解并没有继承于任何子类)。被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解，实际应用中，使用较少。</li>
</ol>
</blockquote>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><blockquote>
<ol>
<li><strong>定义新的 Annotation 类型使用 @interface 关键字。</strong></li>
<li><strong>自定义注解自动继承了 java.lang.annotation.Annotation 接口。</strong></li>
<li><strong>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。</strong></li>
<li><strong>可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字。</strong></li>
<li><strong>如果只有一个参数成员，建议使用参数名为value。</strong></li>
<li><strong>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是 “参数名 &#x3D; 参数值”，如果只有一个参数成员，且名称为value，可以省略”value&#x3D;”。</strong></li>
<li><strong>没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation。</strong></li>
<li><strong>注意：自定义注解必须配上注解的信息处理流程才有意义。</strong></li>
</ol>
</blockquote>
<p>代码示例：（自定义注解）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import java.lang.annotation.ElementType.TYPE;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CustomAnnotation(value = &quot;Hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomAnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;CustomAnnotationTest&gt; clazz = CustomAnnotationTest.class;</span><br><span class="line">        <span class="type">CustomAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(CustomAnnotation.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> annotation.value();</span><br><span class="line">        System.out.println(info); <span class="comment">//Hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TYPE_PARAMETER,TYPE_USE为 java8新增注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, TYPE_PARAMETER, TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> CustomAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Custom&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK7中注解的新特性"><a href="#JDK7中注解的新特性" class="headerlink" title="JDK7中注解的新特性"></a>JDK7中注解的新特性</h2><blockquote>
<p>@SafeVarargs：Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</p>
</blockquote>
<h2 id="JDK8中注解的新特性"><a href="#JDK8中注解的新特性" class="headerlink" title="JDK8中注解的新特性"></a>JDK8中注解的新特性</h2><blockquote>
<p>@FunctionalInterface：Java 8 开始支持，标识一个匿名函数或函数式接口。</p>
<p>@Repeatable：Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</p>
<p> <strong>类型注解</strong></p>
<p>JDK1.8之后，关于元注解 @Target 的参数类型 ElementType枚举值多了两个：<strong>TYPE_PARAMETER，TYPE_USE。</strong></p>
<p>在 Java 8 之前，注解只能是在声明的地方所使用，Java8 开始，注解可以应用在任何地方。</p>
<ul>
<li><strong>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。</strong></li>
<li><strong>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</strong></li>
</ul>
<p>代码示例：（ElementType.TYPE_PARAMETER）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE_PARAMETER)</span></span><br><span class="line"><span class="meta">@interface</span> TypeDefineAnnotation &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeDefineAnnotationTest</span>&lt;<span class="meta">@TypeDefineAnnotation()</span> U&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> U u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;<span class="meta">@TypeDefineAnnotation()</span> T&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：（ElementType.TYPE_USE）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_USE)</span></span><br><span class="line"><span class="meta">@interface</span> TypeUseAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TypeUseAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeUseAnnotationTest</span>&lt;U&gt; &#123;</span><br><span class="line">    <span class="meta">@TypeUseAnnotation</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TypeUseAnnotationTest&lt;<span class="meta">@TypeUseAnnotation</span> String&gt; t = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="meta">@TypeUseAnnotation</span> <span class="type">int</span>) <span class="number">2L</span>;</span><br><span class="line">        <span class="meta">@TypeUseAnnotation</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;<span class="meta">@TypeUseAnnotation</span> T&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="meta">@TypeUseAnnotation</span> String args)</span> <span class="keyword">throws</span> <span class="meta">@TypeUseAnnotation</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>代码示例：（Java8重复注解）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8AnnotationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.walk();</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAnnotation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; annotations.length; i++) &#123;</span><br><span class="line">            System.out.println(annotations[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//@com.example.annotation.MyAnnotations(value=[@com.example.annotation.MyAnnotation(value=hello), @com.example.annotation.MyAnnotation(value=world)])</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java8新增：</span></span><br><span class="line"><span class="comment"> * 1. TYPE_PARAMETER,TYPE_USE为 java8新增类型注解</span></span><br><span class="line"><span class="comment"> * 2. <span class="doctag">@Repeatable</span>(MyAnnotations.class) 标识某注解可以在同一个声明上使用多次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, TYPE_PARAMETER, TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">// 需要导入 import static java.lang.annotation.ElementType.*;</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java8之前写法</span></span><br><span class="line"><span class="comment">//@MyAnnotations(value = &#123;@MyAnnotation(value = &quot;hello&quot;),@MyAnnotation(value = &quot;world&quot;)&#125;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;hello&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;world&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;walk...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generic</span>&lt;<span class="meta">@MyAnnotation</span> T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> <span class="keyword">throws</span> <span class="meta">@MyAnnotation</span> RuntimeException &#123;</span><br><span class="line">        ArrayList&lt;<span class="meta">@MyAnnotation</span> String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="meta">@MyAnnotation</span> <span class="type">int</span>) <span class="number">10L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="利用反射获取注解信息"><a href="#利用反射获取注解信息" class="headerlink" title="利用反射获取注解信息"></a>利用反射获取注解信息</h2><blockquote>
<p>JDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口，该接口代表程序中可以接受注解的程序元素，当一</p>
<p>个 Annotation 类型被定义为运行时Annotation 后，该注解才是运行时可见，当 class 文件被载入时保存在 class 文</p>
<p>件中的 Annotation 才会被虚拟机读取，程序可以调用 AnnotatedElement 对象的如下方法来访问 Annotation 信</p>
<p>息。</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;T extends Annotation&gt;T</code></td>
<td><code>getAnnotation(类&lt;T&gt; annotationClass)</code>  返回该元素的，如果这样的注释 <em>，</em>否则返回null指定类型的注释。</td>
</tr>
<tr>
<td><code>Annotation[]</code></td>
<td><code>getAnnotations()</code>  返回此元素上 <em>存在的</em>注释。</td>
</tr>
<tr>
<td><code>default &lt;T extends Annotation&gt;T[]</code></td>
<td><code>getAnnotationsByType(类&lt;T&gt; annotationClass)</code>  返回与此元素相关 <em>联的注释</em> 。</td>
</tr>
<tr>
<td><code>default &lt;T extends Annotation&gt;T</code></td>
<td><code>getDeclaredAnnotation(类&lt;T&gt; annotationClass)</code>  如果这样的注释 <em>直接存在</em> ，则返回指定类型的元素注释，否则返回null。</td>
</tr>
<tr>
<td><code>Annotation[]</code></td>
<td><code>getDeclaredAnnotations()</code>  返回 <em>直接存在</em>于此元素上的注释。</td>
</tr>
<tr>
<td><code>default &lt;T extends Annotation&gt;T[]</code></td>
<td><code>getDeclaredAnnotationsByType(类&lt;T&gt; annotationClass)</code>  如果此类注释 <em>直接存在</em>或 <em>间接存在，</em>则返回该元素的注释（指定类型）。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>isAnnotationPresent(类&lt;?  extends Annotation&gt; annotationClass)</code>  如果此元素上 <em>存在</em>指定类型的注释，则返回true，否则返回false。</td>
</tr>
</tbody></table>
</blockquote>
<h1 id="版本特性"><a href="#版本特性" class="headerlink" title="版本特性"></a>版本特性</h1><h2 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h2><h3 id="新特性简介"><a href="#新特性简介" class="headerlink" title="新特性简介"></a>新特性简介</h3><p>函数式接口</p>
<p>Lambda表达式</p>
<p>方法构造、引用构造</p>
<p>StreamAPI</p>
<p>Optional类</p>
<p>日期时间API</p>
<p>注解：重复注解、类型注解、目标类型推断</p>
<p>JDK：String（join方法）Files、Arrays、Reflection获取形参等</p>
<p>JVM中MetaSpace取代Permgen</p>
<p>改进特点：</p>
<ol>
<li><p>速度更快</p>
</li>
<li><p>代码更少(增加了新的语法：Lambda 表达式)</p>
</li>
<li><p>强大的 Stream API</p>
</li>
<li><p>便于并行</p>
</li>
<li><p>最大化减少空指针异常：Optional</p>
</li>
<li><p>Nashorn引擎，允许在JVM上运行JS应用</p>
</li>
</ol>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><blockquote>
<ol>
<li><p>Lambda 是一个匿名函数，可以把 Lambda 表达式理解为是一段可以传递的代码。</p>
</li>
<li><p>使用它可以写出更简洁、更灵活的代码，使Java的语言表达能力得到了提升。</p>
</li>
<li><p>在Java 8 语言中引入的一种新的语法元素和操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或箭头操作符。它将 Lambda 分为两个部分：</p>
<p>​	左侧：指定了 Lambda 表达式需要的参数列表</p>
<p>​	右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功能。</p>
</li>
</ol>
</blockquote>
<h4 id="Lambda语法示例"><a href="#Lambda语法示例" class="headerlink" title="Lambda语法示例"></a>Lambda语法示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.versionfeature.java8.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lambda语法示例</span></span><br><span class="line"><span class="comment"> * 操作符：-&gt;</span></span><br><span class="line"><span class="comment"> * 格式：参数列表 -&gt; 方法实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest01</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lambda使用示例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;runnable...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 使用lambda表达式替换匿名内部类</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> ()-&gt; System.out.println(<span class="string">&quot;runnable...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;String&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        TreeSet&lt;String&gt; treeSet2 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((o1,o2)-&gt;o1.compareTo(o2));</span><br><span class="line">        <span class="comment">// TreeSet&lt;String&gt; treeSet3 = new TreeSet&lt;&gt;(String::compareTo);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lambda语法示例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//语法格式一：无参，无返回值</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;runnable....&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//语法格式二：Lambda 需要一个参数，但是没有返回值</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = (String str) -&gt; System.out.println(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为&quot;类型推断&quot;</span></span><br><span class="line">        Consumer&lt;String&gt; con1 = (str) -&gt; System.out.println(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class="line">        Consumer&lt;String&gt; con2 = str -&gt; System.out.println(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class="line">        Comparator&lt;Integer&gt; con3 = (x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;comparator....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(x, y);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</span></span><br><span class="line">        Comparator&lt;Integer&gt; con4 = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">        Comparator&lt;Integer&gt; con5 = Integer::compare;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类型推断：Lambda表达式中无需指定类型，程序依然可以编译，javac推断出了参数的类型</span></span><br><span class="line">        List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// int[] arr = &#123;1,2,3&#125;;也是类型推断。</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数式（Functional）接口"><a href="#函数式（Functional）接口" class="headerlink" title="函数式（Functional）接口"></a>函数式（Functional）接口</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​		在Java中，随着新兴语言的挑战，Java还应该支持面向函数编程，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型，即函数式接口。Lambda表达式就是一个函数式接口的实例。</p>
<blockquote>
<p>定义：</p>
<ol>
<li><p>只包含一个抽象方法的接口，称为函数式接口。</p>
</li>
<li><p>函数式接口可以有默认方法。</p>
</li>
<li><p>可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</p>
</li>
<li><p>可以在一个接口上使用 <strong>@FunctionalInterface 注解</strong>，可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p>
</li>
<li><p>在<strong>java.util.function</strong>包下定义了Java 8 的丰富的函数式接口。</p>
</li>
<li><p><strong>Lambda 表达式作为参数传递</strong>，接收Lambda表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。</p>
</li>
<li><p>函数式接口示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h4 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h4><blockquote>
<ol>
<li><p>只有一个抽象方法，可以有多个默认方法</p>
</li>
<li><p>使用@FunctionalInterface标注</p>
</li>
<li><p>自定义函数式接口示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义函数式接口：</span></span><br><span class="line"><span class="comment"> * 1.只有一个【抽象方法】，可以有多个默认方法</span></span><br><span class="line"><span class="comment"> * 2.使用 <span class="doctag">@FunctionalInterface</span> 注解标注</span></span><br><span class="line"><span class="comment"> * 3.只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FunctionalInterfaceCustom</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getValue</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Lambda表达式作为参数传递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lambda 表达式作为参数传递</span></span><br><span class="line"><span class="comment"> * 1. 传递的是一个函数型接口的实现类</span></span><br><span class="line"><span class="comment"> * 2. 接收Lambda表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionalInterfaceCustomTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">changeString</span><span class="params">(</span></span><br><span class="line"><span class="params">            String source,</span></span><br><span class="line"><span class="params">            FunctionalInterfaceCustom&lt;String&gt; functionalInterface)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> functionalInterface.getValue(source);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dest</span> <span class="operator">=</span> changeString(<span class="string">&quot;HelloWorld&quot;</span>, str -&gt; str.toUpperCase(Locale.ROOT));</span><br><span class="line">        System.out.println(<span class="string">&quot;dest: &quot;</span>+dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h4 id="Java-内置四大核心函数式接口"><a href="#Java-内置四大核心函数式接口" class="headerlink" title="Java 内置四大核心函数式接口"></a>Java 内置四大核心函数式接口</h4><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T></T></td>
<td>T</td>
<td>void</td>
<td>消费型接口：void accept(T t) 对类型为 T 的对象进行操作</td>
</tr>
<tr>
<td>Supplier<T></T></td>
<td>无</td>
<td>T</td>
<td>供给型接口：T get() 返回类型为 T 的接口</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>T</td>
<td>R</td>
<td>函数型接口：R apply(T t) 对类型为 T 的对象操作，返回 R 类型</td>
</tr>
<tr>
<td>Predicate<T></T></td>
<td>T</td>
<td>Boolean</td>
<td>断言型接口：boolean test(T t) 断言类型为 T 的对象是否满足约束&#x2F;条件</td>
</tr>
</tbody></table>
<p>其他接口：</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>T,U</td>
<td>R</td>
<td>R apply(T t,U u) 对参数 T，U操作，返回 R</td>
</tr>
<tr>
<td>UnaryOperator<T></T></td>
<td>T</td>
<td>T</td>
<td>T apply(T t) 对类型为 T 的对象进行一元运算，返回 T 类型</td>
</tr>
<tr>
<td>BinaryOperator<T></T></td>
<td>T</td>
<td>T</td>
<td>T apply(T t1,T t2) 对类型为 T 的对象进行二元运算，返回 T 类型</td>
</tr>
<tr>
<td>BiConsumer&lt;T,U&gt;</td>
<td>T,U</td>
<td>void</td>
<td>void accept(T t,U u) 对类型为 T,U 的参数进行操作</td>
</tr>
<tr>
<td>BiPredicate&lt;T,U&gt;</td>
<td>T,U</td>
<td>boolean</td>
<td>对类型为T,U的参数进行断言</td>
</tr>
<tr>
<td>ToIntFunction<T><br>ToLongFunction<T><br>ToDoubleFunction<T></T></T></T></td>
<td>T</td>
<td>int&#x2F;long&#x2F;double</td>
<td>分别计算 int&#x2F;long&#x2F;double 类型的函数</td>
</tr>
<tr>
<td>IntFunction<T><br>LongFunction<T><br>DoubleFunction<T></T></T></T></td>
<td>int&#x2F;long&#x2F;double</td>
<td>R</td>
<td>参数分别为int&#x2F;long&#x2F;double 的函数</td>
</tr>
</tbody></table>
<h4 id="函数式接口示例"><a href="#函数式接口示例" class="headerlink" title="函数式接口示例"></a>函数式接口示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.versionfeature.java8.functional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java内置核心函数式接口测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionInterfaceTest02</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费型接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * public interface Consumer&lt;T&gt; 表示接受单个输入参数并且不返回结果的操作</span></span><br><span class="line"><span class="comment">     * 方法：</span></span><br><span class="line"><span class="comment">     *      void accept(T t) 对给定的参数执行此操作。</span></span><br><span class="line"><span class="comment">     *      default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after)</span></span><br><span class="line"><span class="comment">     *          返回一个组合的 Consumer ，按顺序执行该操作，然后执行after操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toConsume</span><span class="params">(<span class="type">double</span> money, Consumer&lt;Double&gt; consuemr)</span> &#123;</span><br><span class="line">        consuemr.accept(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        toConsume(<span class="number">100</span>, m -&gt; System.out.println(<span class="string">&quot;money = &quot;</span> + m));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断言型接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * public interface Predicate&lt;T&gt; 表示一个参数的谓词（布尔值函数）</span></span><br><span class="line"><span class="comment">     * 方法：</span></span><br><span class="line"><span class="comment">     *      boolean test(T t)</span></span><br><span class="line"><span class="comment">     *          在给定的参数上评估这个谓词</span></span><br><span class="line"><span class="comment">     *      default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other)</span></span><br><span class="line"><span class="comment">     *          返回一个组合的谓词，表示该谓词与另一个谓词的短路逻辑AND</span></span><br><span class="line"><span class="comment">     *      static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef)</span></span><br><span class="line"><span class="comment">     *          返回根据 Objects.equals(Object, Object)测试两个参数是否相等的谓词</span></span><br><span class="line"><span class="comment">     *      default Predicate&lt;T&gt; negate()</span></span><br><span class="line"><span class="comment">     *          返回表示此谓词的逻辑否定的谓词</span></span><br><span class="line"><span class="comment">     *      default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other)</span></span><br><span class="line"><span class="comment">     *          返回一个组合的谓词，表示该谓词与另一个谓词的短路逻辑或</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">filterString</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; predicate)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(s)) &#123;</span><br><span class="line">                result.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = filterString(</span><br><span class="line">                Arrays.asList(<span class="string">&quot;东京&quot;</span>, <span class="string">&quot;西京&quot;</span>, <span class="string">&quot;南京&quot;</span>, <span class="string">&quot;beijing&quot;</span>),</span><br><span class="line">                s -&gt; s.contains(<span class="string">&quot;京&quot;</span>));</span><br><span class="line">        result.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供给型接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * public interface Supplier&lt;T&gt; 代表结果供应商</span></span><br><span class="line"><span class="comment">     *      没有要求每次调用供应商时都会返回新的或不同的结果</span></span><br><span class="line"><span class="comment">     * 方法：</span></span><br><span class="line"><span class="comment">     *      T get() 获得结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">        Supplier&lt;Employee&gt; supplier = () -&gt; Employee.getAllEmployee().get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数型接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * public interface Function&lt;T,R&gt; 表示接受一个参数并产生结果的函数。</span></span><br><span class="line"><span class="comment">     * 方法：</span></span><br><span class="line"><span class="comment">     *      default &lt;V&gt; Function&lt;T,V&gt; andThen(Function&lt;? super R,? extends V&gt; after)</span></span><br><span class="line"><span class="comment">     *          返回一个组合函数，首先将该函数应用于其输入，然后将 after函数应用于结果。</span></span><br><span class="line"><span class="comment">     *      R apply(T t) 将此函数应用于给定的参数。</span></span><br><span class="line"><span class="comment">     *      default &lt;V&gt; Function&lt;V,R&gt; compose(Function&lt;? super V,? extends T&gt; before)</span></span><br><span class="line"><span class="comment">     *          返回一个组合函数，首先将 before函数应用于其输入，然后将此函数应用于结果。</span></span><br><span class="line"><span class="comment">     *      static &lt;T&gt; Function&lt;T,T&gt; identity() 返回一个总是返回其输入参数的函数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">        Function&lt;String, Employee&gt; function = (name) -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(name);</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;John&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BiFunction&lt;T,U,R&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * public interface BiFunction&lt;T,U,R&gt;表示接受两个参数并产生结果的函数。</span></span><br><span class="line"><span class="comment">     * 方法：</span></span><br><span class="line"><span class="comment">     *      default &lt;V&gt; BiFunction&lt;T,U,V&gt; andThen(Function&lt;? super R,? extends V&gt; after)</span></span><br><span class="line"><span class="comment">     *          返回一个组合函数，首先将此函数应用于其输入，然后将 after函数应用于结果。</span></span><br><span class="line"><span class="comment">     *      R apply(T t, U u) 将此函数应用于给定的参数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">        BiFunction&lt;String, Character, Employee&gt; function = (name, sex) -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(name, sex);</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;Jane&quot;</span>, <span class="string">&#x27;W&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.versionfeature.java8.functional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Employee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">24</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&quot;NewYork&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">19</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&quot;ShangHai&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Rose&quot;</span>, <span class="number">24</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&quot;Beijing&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&quot;Xian&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">char</span> sex, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h3><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><blockquote>
<ol>
<li><p>当要传递给 Lambda 体的操作，已经有实现的方法了，不需要自己实现方法，可以使用方法引用。</p>
</li>
<li><p>方法引用可以看做是 Lambda 表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法。</p>
</li>
<li><p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致。</p>
</li>
<li><p>格式：使用操作符 <strong>“::”</strong> 将类(或对象) 与方法名分隔开来</p>
<p>如下三种主要使用情况：</p>
<p>（1）对象 <strong>::</strong> 实例方法名</p>
<p>（2）类 <strong>::</strong> 静态方法名</p>
<p>（3）类 <strong>::</strong> 实例方法名</p>
</li>
</ol>
</blockquote>
<h4 id="方法引用示例"><a href="#方法引用示例" class="headerlink" title="方法引用示例"></a>方法引用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.versionfeature.java8.methodreference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.basic.versionfeature.java8.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiPredicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致。</span></span><br><span class="line"><span class="comment"> * 格式：使用操作符 &quot;::&quot; 将类(或对象) 与方法名分隔开来。</span></span><br><span class="line"><span class="comment"> * 如下三种主要使用情况：</span></span><br><span class="line"><span class="comment"> * 1. 对象 :: 实例方法名</span></span><br><span class="line"><span class="comment"> * 2. 类 :: 静态方法名</span></span><br><span class="line"><span class="comment"> * 3. 类 :: 实例方法名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodReferenceTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 情况一：对象::实例方法</span></span><br><span class="line"><span class="comment">     * Consumer 中的void accept(T t)</span></span><br><span class="line"><span class="comment">     * PrintStream void println(T t)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer = str -&gt; System.out.println(str);</span><br><span class="line">        consumer.accept(<span class="string">&quot;China&quot;</span>);</span><br><span class="line">        Consumer&lt;String&gt; consumer2 = System.out::println;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Supplier T get()</span></span><br><span class="line"><span class="comment">     * Employee String getName()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Tony&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&quot;XinJiang&quot;</span>);</span><br><span class="line">        Supplier&lt;String&gt; sup = () -&gt; employee.getName();</span><br><span class="line">        System.out.println(sup.get());</span><br><span class="line">        Supplier&lt;String&gt; supplier = employee::getName;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 情况二：类::静态方法</span></span><br><span class="line"><span class="comment">     * Comparator 中的 int compare(T t)</span></span><br><span class="line"><span class="comment">     * Integer int compare(T t)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com = (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class="line">        System.out.println(com.compare(<span class="number">10</span>, <span class="number">9</span>));<span class="comment">//1</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator = Integer::compare;</span><br><span class="line">        System.out.println(comparator.compare(<span class="number">1</span>, <span class="number">3</span>));<span class="comment">//-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Function 中的 R apply(T t)</span></span><br><span class="line"><span class="comment">     * Math Long round(Double d)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">        Function&lt;Double, Long&gt; fun = d -&gt; Math.round(d);</span><br><span class="line">        System.out.println(fun.apply(<span class="number">1.2</span>));</span><br><span class="line">        Function&lt;Double, Long&gt; fun2 = Math::round;</span><br><span class="line">        System.out.println(fun2.apply(<span class="number">1.2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 情况三：类：实例方法</span></span><br><span class="line"><span class="comment">     * Comparator中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">     * String 中的 int t1.compareTo(t2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">        Comparator&lt;String&gt; com1 = (s1, s2) -&gt; s1.compareTo(s2);</span><br><span class="line">        System.out.println(com1.compare(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abd&quot;</span>));</span><br><span class="line">        <span class="comment">// 第一个参数相当于调用方：s1调用compareTo</span></span><br><span class="line">        <span class="comment">// String重写了compareTo方法</span></span><br><span class="line">        Comparator&lt;String&gt; com2 = String::compareTo;</span><br><span class="line">        System.out.println(com2.compare(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abe&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BigPredicate中的boolean test(T t2,T t2)</span></span><br><span class="line"><span class="comment">     * String boolean t1.equals(t2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">        BiPredicate&lt;String, String&gt; pre1 = (s1, s2) -&gt; s1.equals(s2);</span><br><span class="line">        System.out.println(pre1.test(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        BiPredicate&lt;String, String&gt; pre2 = String::equals;</span><br><span class="line">        System.out.println(pre2.test(<span class="string">&quot;abd&quot;</span>, <span class="string">&quot;abc&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Function 中的R apply(T t)</span></span><br><span class="line"><span class="comment">     * Employee 中的String getName() 相当于 t.getName()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 没有参数，Supplier&lt;String&gt; s = 对象::getName();</span></span><br><span class="line"><span class="comment">     * 含参：Function&lt;Employee,String&gt; s = 类::getName();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;John&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&quot;YunNan&quot;</span>);</span><br><span class="line">        Function&lt;Employee, String&gt; fun1 = e -&gt; e.getName();</span><br><span class="line">        System.out.println(fun1.apply(emp));</span><br><span class="line">        <span class="comment">// public String getName(Employee employee) &#123;&#125;</span></span><br><span class="line">        <span class="comment">// Function&lt;Employee,String&gt; fun2 = emp::getName;</span></span><br><span class="line">        Function&lt;Employee, String&gt; fun2 = Employee::getName;</span><br><span class="line">        System.out.println(fun2.apply(emp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.versionfeature.java8.methodreference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.basic.versionfeature.java8.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式： ClassName::new</span></span><br><span class="line"><span class="comment"> * 与函数式接口相结合，自动与函数式接口中方法兼容。</span></span><br><span class="line"><span class="comment"> * 可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象</span></span><br><span class="line"><span class="comment"> * 方法的参数列表一致，且方法的返回值即为构造器对应类的对象。</span></span><br><span class="line"><span class="comment"> * 例如</span></span><br><span class="line"><span class="comment"> *      Function&lt;Integer,MyClass&gt; fun = (n)-&gt;new MyClass(n);</span></span><br><span class="line"><span class="comment"> * 等价于</span></span><br><span class="line"><span class="comment"> *      Function&lt;Integer,MyClass&gt; fun1 = MyClass::new;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorReferenceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        Supplier&lt;Employee&gt; employeeSupplier = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Supplier&lt;Employee&gt; employeeSupplier2 = () -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        Supplier&lt;Employee&gt; employeeSupplier3 = Employee::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;employee: &quot;</span> + employeeSupplier3.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        Function&lt;String, Employee&gt; employeeFunction = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Employee&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Employee <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Function&lt;String, Employee&gt; employeeFunction2 = name -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(name);</span><br><span class="line">        Function&lt;String, Employee&gt; employeeFunction3 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">        BiFunction&lt;String, Character, Employee&gt; fun = (t, u) -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(t, u);</span><br><span class="line">        BiFunction&lt;String, Character, Employee&gt; fun1 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.versionfeature.java8.methodreference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组引用</span></span><br><span class="line"><span class="comment"> * 格式： type[] :: new</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayReferenceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        Function&lt;Integer, String[]&gt; arrayFunction = n -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">        Function&lt;Integer, String[]&gt; arrayFunction2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><h4 id="并行流与串行流"><a href="#并行流与串行流" class="headerlink" title="并行流与串行流"></a>并行流与串行流</h4><blockquote>
<ol>
<li><p>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</p>
</li>
<li><p>Java 8 中将并行进行了优化，可以很容易的对数据进行并行操作。Stream API 可以声明性地通过parallel() 与 sequential() 在并行流与顺序流之间进行切换。</p>
</li>
</ol>
</blockquote>
<h4 id="Stream简介"><a href="#Stream简介" class="headerlink" title="Stream简介"></a>Stream简介</h4><blockquote>
<ol>
<li><p>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。</p>
</li>
<li><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的<strong>查找、过滤和映射</strong>数据等操作。 </p>
</li>
<li><p>Stream API 提供了一种高效且易于使用的处理数据的方式，Stream是Java层面的数据处理。</p>
</li>
<li><p>Stream 和 Collection 集合的区别： Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>
</li>
<li><p>Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>
</li>
<li><p>注意：</p>
<p>（1）Stream 自己不会存储元素。</p>
<p>（2）Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p>
<p>（3）Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p>
</li>
<li><p>Stream操作数据的三个步骤：</p>
<p>（1）创建 Stream， 一个数据源（如：集合、数组），获取一个流</p>
<p>（2）中间操作，一个中间操作链，对数据源的数据进行处理</p>
<p>（3） 终止操作，一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用。</p>
</li>
</ol>
</blockquote>
<h4 id="Stream的创建方式"><a href="#Stream的创建方式" class="headerlink" title="Stream的创建方式"></a>Stream的创建方式</h4><h5 id="方式一：通过集合"><a href="#方式一：通过集合" class="headerlink" title="方式一：通过集合"></a>方式一：通过集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> : 返回一个顺序流</span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span> : 返回一个并行流</span><br></pre></td></tr></table></figure>

<h5 id="方式二：通过数组Arrays"><a href="#方式二：通过数组Arrays" class="headerlink" title="方式二：通过数组Arrays"></a>方式二：通过数组Arrays</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(T[] array)</span>: 返回一个流重载形式，能够处理对应基本类型的数组：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title function_">stream</span><span class="params">(<span class="type">int</span>[] array)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LongStream <span class="title function_">stream</span><span class="params">(<span class="type">long</span>[] array)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DoubleStream <span class="title function_">stream</span><span class="params">(<span class="type">double</span>[] array)</span></span><br></pre></td></tr></table></figure>

<h5 id="方式三：通过Stream的of"><a href="#方式三：通过Stream的of" class="headerlink" title="方式三：通过Stream的of()"></a>方式三：通过Stream的of()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以调用Stream类静态方法 of(), 通过显式的创建一个流。它可以接收任意数量的参数。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span> : 返回一个流</span><br></pre></td></tr></table></figure>

<h5 id="方式四：创建无限流"><a href="#方式四：创建无限流" class="headerlink" title="方式四：创建无限流"></a>方式四：创建无限流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以使用静态方法 Stream.iterate() 和 Stream.generate()创建无限流。</span><br><span class="line">迭代：<span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">生成：<span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">generate</span><span class="params">(Supplier&lt;T&gt; s)</span></span><br></pre></td></tr></table></figure>

<h5 id="Stream的创建示例"><a href="#Stream的创建示例" class="headerlink" title="Stream的创建示例"></a>Stream的创建示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.versionfeature.java8.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.basic.versionfeature.java8.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream的创建方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamCreateWayTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stream创建方式一：通过集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; employeeList = Employee.getAllEmployee();</span><br><span class="line">        Stream&lt;Employee&gt; stream = employeeList.stream();</span><br><span class="line">        Stream&lt;Employee&gt; parallelStream = employeeList.parallelStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stream的创建方式二：通过数组Arrays.stream()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">IntStream</span> <span class="variable">intStream</span> <span class="operator">=</span> Arrays.stream(array);</span><br><span class="line">        Employee[] employees = <span class="literal">null</span>;</span><br><span class="line">        Employee.getAllEmployee().toArray(employees);</span><br><span class="line">        Stream&lt;Employee&gt; stream = Arrays.stream(employees);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stream的创建方式三：通过Stream.of</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">        Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stream的创建方式四：创建无限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生成</span></span><br><span class="line">        Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 迭代</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Stream-的中间操作"><a href="#Stream-的中间操作" class="headerlink" title="Stream 的中间操作"></a>Stream 的中间操作</h4><p>​		多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理，而在终止操作时一次性全部处理，称为“惰性求值”。</p>
<h5 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>filter(Predicate p)</td>
<td>接受Lambda，从流中排除某些元素</td>
</tr>
<tr>
<td>distinct()</td>
<td>筛选，根据流中元素的hashCode()和equals()去除重复元素</td>
</tr>
<tr>
<td>limit(long maxSize)</td>
<td>截断流，使元素不超过给定数量</td>
</tr>
<tr>
<td>skip(long n)</td>
<td>跳过指定数量个元素</td>
</tr>
</tbody></table>
<h5 id="映-射"><a href="#映-射" class="headerlink" title="映 射"></a>映 射</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>map(Function f)</td>
<td>接受一个函数作为一个参数，该函数应用到每个元素上，并将其映射成一个新的元素</td>
</tr>
<tr>
<td>flatMap(Function f)</td>
<td>接受一个函数作为一个参数，将流中每一个值都换成另一个流，然后把所有流连接成一个流</td>
</tr>
<tr>
<td>mapToInt(ToIntFunction f)</td>
<td>接受一个函数作为一个参数，该函数应用到每个元素上，并将其映射成一个新的 IntStream</td>
</tr>
<tr>
<td>mapToLong(ToLongFunction f)</td>
<td>接受一个函数作为一个参数，该函数应用到每个元素上，并将其映射成一个新的 LongStream</td>
</tr>
<tr>
<td>mapToDouble(ToDoubleFunction f)</td>
<td>接受一个函数作为一个参数，该函数应用到每个元素上，并将其映射成一个新的 DoubleStream</td>
</tr>
</tbody></table>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sorted()</td>
<td>产生一个新流，按自然顺序排序</td>
</tr>
<tr>
<td>sorted(Comparator c)</td>
<td>产生一个新流，按 Comparator 排序</td>
</tr>
</tbody></table>
<h5 id="流的中间操作示例"><a href="#流的中间操作示例" class="headerlink" title="流的中间操作示例"></a>流的中间操作示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试流的中间操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamMiddleOperateTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试流的筛选与切片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; employeeList = Employee.getAllEmployee();</span><br><span class="line">        employeeList.stream().filter(e -&gt; e.getName().contains(<span class="string">&quot;T&quot;</span>)).forEach(System.out::println);</span><br><span class="line">        employeeList.stream().limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        employeeList.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        employeeList.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&quot;Xian&quot;</span>));</span><br><span class="line">        employeeList.stream().distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试流的映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;DD&quot;</span>);</span><br><span class="line">        list.stream().map(str -&gt; str.toLowerCase(Locale.ROOT)).forEach(System.out::println);</span><br><span class="line">        Employee.getAllEmployee().stream().map(Employee::getName)</span><br><span class="line">                .filter(name -&gt; name.length() &gt; <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">// flatMap(function f) 类似于list.add() list.addAll()</span></span><br><span class="line">        Stream&lt;Stream&lt;Character&gt;&gt; stream = list.stream().map(StreamMiddleOperateTest::fromStringToCharacterStream);</span><br><span class="line">        stream.forEach(s -&gt; &#123;</span><br><span class="line">            s.forEach(System.out::println);</span><br><span class="line">        &#125;);</span><br><span class="line">        Stream&lt;Character&gt; flatMap = list.stream().flatMap(StreamMiddleOperateTest::fromStringToCharacterStream);</span><br><span class="line">        flatMap.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title function_">fromStringToCharacterStream</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(str.length());</span><br><span class="line">        <span class="keyword">for</span> (Character c : str.toCharArray()) &#123;</span><br><span class="line">            list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试流的排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// sort() 自然排序，排序对象需要实现Comparable接口</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">23</span>, <span class="number">24</span>, -<span class="number">12</span>, <span class="number">112</span>, <span class="number">81</span>);</span><br><span class="line">        list.stream().sorted().forEach(System.out::println);</span><br><span class="line">        <span class="comment">// sorted(Comparator com) 定制排序</span></span><br><span class="line">        Employee.getAllEmployee().stream()</span><br><span class="line">                .sorted(Comparator.comparingInt(Employee::getAge))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Stream-的终止操作"><a href="#Stream-的终止操作" class="headerlink" title="Stream 的终止操作"></a>Stream 的终止操作</h4><p>​		终止操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如： List、Integer，甚至是 void 。<strong>流进行了终止操作后，不能再次使用</strong>。</p>
<h5 id="匹配与查找"><a href="#匹配与查找" class="headerlink" title="匹配与查找"></a>匹配与查找</h5><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>allMatch(Predicate p)</td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>anyMatch(Predicate p)</td>
<td>检查是否至少匹配其中一个元素</td>
</tr>
<tr>
<td>nonoMatch(Predicate p)</td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td>findFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>findAny()</td>
<td>返回任意元素</td>
</tr>
<tr>
<td>count()</td>
<td>返回流中任意元素</td>
</tr>
<tr>
<td>max(Comparator c)</td>
<td>返回流中最大值</td>
</tr>
<tr>
<td>min(Comparator c)</td>
<td>返回流中最小值</td>
</tr>
<tr>
<td>forEach(Consumer C)</td>
<td>内部迭代（使用Collection接口需要用户做迭代：外部迭代）</td>
</tr>
</tbody></table>
<h5 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h5><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>reduce(T iden,BinaryOperator b)</td>
<td>将流中的元素反复结合起来，得到一个新值，返回T</td>
</tr>
<tr>
<td>reduce(BinaryOperator b)</td>
<td>将流中的元素反复结合起来，得到一个新值，返回Optional<T></T></td>
</tr>
</tbody></table>
<h5 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h5><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>collect(Collector c)</td>
<td>将流转化为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总</td>
</tr>
</tbody></table>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>toList</td>
<td>List<T></T></td>
<td>将流中元素收集到List</td>
</tr>
<tr>
<td>toSet</td>
<td>Set<T></T></td>
<td>将流中元素收集到Set</td>
</tr>
<tr>
<td>toCollection</td>
<td>Collection<T></T></td>
<td>将流收集到创建的集合</td>
</tr>
<tr>
<td>counting</td>
<td>Long</td>
<td>计算流中的个数</td>
</tr>
<tr>
<td>summingInt</td>
<td>Integer</td>
<td>对流中元素的整数属性求和</td>
</tr>
<tr>
<td>averagingInt</td>
<td>Double</td>
<td>计算流中元素Integer属性的平均值</td>
</tr>
<tr>
<td>summarizingInt</td>
<td>IntSummaryStatics</td>
<td>收集流中Integer属性的统计值</td>
</tr>
<tr>
<td>joining</td>
<td>String</td>
<td>连接流中每个字符串</td>
</tr>
<tr>
<td>maxBy</td>
<td>Optional<T></T></td>
<td>根据比较器选择最大值</td>
</tr>
<tr>
<td>minBy</td>
<td>Optional<T></T></td>
<td>根据比较器选择最小值</td>
</tr>
<tr>
<td>reducing</td>
<td>归约产生的类型</td>
<td>从累加器的初始值开始，利用BinaryOPerator与流中元素逐个结合，从而归约成单个值</td>
</tr>
<tr>
<td>collectingAndThen</td>
<td>转换函数返回的类型</td>
<td>包裹另一个收集器，对其结果转换函数</td>
</tr>
<tr>
<td>groupingBy</td>
<td>Map&lt;K,List<V>&gt;</V></td>
<td>根据某属性值进行分组，属性为K，结果为V</td>
</tr>
<tr>
<td>partitioningBy</td>
<td>Map&lt;Boolean,List<T>&gt;</T></td>
<td>根据true或者false进行分区</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employeeList = list.stream().collect(Collectors.toList());</span><br><span class="line">Set&lt;Employee&gt; employeeSet = list.stream().collect(Collectors.toSet());</span><br><span class="line">Collection&lt;Employee&gt; employees = 		   			list.stream().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().collect(Collectors.counting());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> list.stream().collect(summingInt(Employee::getSalary));</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> list.stream().collect(Collectors.summingInt(Employee::getSalary());</span><br><span class="line"><span class="type">int</span> <span class="variable">summaryStaticsiss</span> <span class="operator">=</span> list.stream().collect(Collectors.summarizingINt(Employee::getSalary());</span><br><span class="line">                                              </span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.stream().map(Employee::getName).collect(Collectors.joining());</span><br><span class="line">Optional&lt;Employee&gt; max =list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</span><br><span class="line">                                              </span><br><span class="line">Optional&lt;Employee&gt; min =list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</span><br><span class="line">                                              </span><br><span class="line"><span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> list.stream().collect(Collectors.reducing(<span class="number">0</span>,Employee::getSalary,Integer::sum));</span><br><span class="line"><span class="type">int</span> <span class="variable">how</span> <span class="operator">=</span> list.stream().collect(Collectors.collectingAndThen(Collectors.toList(),List::size));</span><br><span class="line">Map&lt;Employee.STATUS,List&lt;Employee&gt; list&gt; map = </span><br><span class="line">data.stream().collect(Collectors.groupingBy(Employee::getStatus);</span><br><span class="line">Map&lt;Boolean,List&lt;Employee&gt; list&gt; map = </span><br><span class="line">data.stream().collect(Collectors.partitioningBy(Employee::getManage);</span><br></pre></td></tr></table></figure>

<h5 id="Stream的终止操作示例"><a href="#Stream的终止操作示例" class="headerlink" title="Stream的终止操作示例"></a>Stream的终止操作示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试流的终止操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTerminalOperateTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试流的匹配与查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; allEmployee = Employee.getAllEmployee();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> allEmployee.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;allMatch: &quot;</span> + allMatch);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> allEmployee.stream().anyMatch(e -&gt; e.getAge() &gt; <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;anyMatch: &quot;</span> + anyMatch);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">noneMatch</span> <span class="operator">=</span> allEmployee.stream().noneMatch(e -&gt; e.getName().contains(<span class="string">&quot;L&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;noneMatch: &quot;</span> + noneMatch);</span><br><span class="line">        Optional&lt;Employee&gt; findFirst = allEmployee.stream().findFirst();</span><br><span class="line">        System.out.println(<span class="string">&quot;findFirst: &quot;</span> + findFirst);</span><br><span class="line">        Optional&lt;Employee&gt; findAny = allEmployee.stream().findAny();</span><br><span class="line">        System.out.println(<span class="string">&quot;findAny: &quot;</span> + findAny);</span><br><span class="line">        Optional&lt;Employee&gt; findAny2 = allEmployee.parallelStream().findAny();</span><br><span class="line">        System.out.println(<span class="string">&quot;findAny2: &quot;</span> + findAny2);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> allEmployee.stream().filter(e -&gt; e.getAge() &gt; <span class="number">18</span>).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        Stream&lt;Integer&gt; map = allEmployee.stream().map(e -&gt; e.getAge());</span><br><span class="line">        Optional&lt;Integer&gt; max = map.max(Double::compare);</span><br><span class="line">        System.out.println(<span class="string">&quot;max: &quot;</span> + max.get());</span><br><span class="line">        Stream&lt;Integer&gt; map2 = allEmployee.stream().map(e -&gt; e.getAge());</span><br><span class="line">        Optional&lt;Integer&gt; min = map2.min(Double::compare);</span><br><span class="line">        System.out.println(<span class="string">&quot;min: &quot;</span> + min.get());</span><br><span class="line">        <span class="comment">//内部迭代</span></span><br><span class="line">        allEmployee.stream().forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//外部迭代(使用Collection接口迭代)</span></span><br><span class="line">        allEmployee.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试流的归约</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> list.stream().reduce(<span class="number">1</span>, Integer::sum);</span><br><span class="line">        List&lt;Employee&gt; allEmployee = Employee.getAllEmployee();</span><br><span class="line">        Stream&lt;Integer&gt; map = allEmployee.stream().map(Employee::getAge);</span><br><span class="line">        <span class="comment">// Optional&lt;Integer&gt; reduce2 = map.reduce(Integer::sum);</span></span><br><span class="line">        Optional&lt;Integer&gt; reduce2 = map.reduce((d1, d2) -&gt; d1 + d2);</span><br><span class="line">        System.out.println(reduce2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试流的收集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; result = Employee.getAllEmployee().stream()</span><br><span class="line">                .filter(e -&gt; e.getSex() == <span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><blockquote>
<ol>
<li><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p>
</li>
<li><p>Optional<T> 类（java.util.Optional）是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存 null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</T></p>
</li>
<li><p>Optional 类的 Javadoc 描述如下：这是一个可以为 null 的容器对象。如果值存在则 isPresent() 方法会返回 true，调用 get() 方法会返回该对象。</p>
</li>
</ol>
</blockquote>
<h5 id="创建Optional类对象的方法"><a href="#创建Optional类对象的方法" class="headerlink" title="创建Optional类对象的方法"></a>创建Optional类对象的方法</h5><blockquote>
<p>Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</p>
<p>Optional.empty() : 创建一个空的 Optional 实例</p>
<p>Optional.ofNullable(T t)：t可以为null</p>
</blockquote>
<h5 id="判断Optional容器中是否包含对象"><a href="#判断Optional容器中是否包含对象" class="headerlink" title="判断Optional容器中是否包含对象"></a>判断Optional容器中是否包含对象</h5><blockquote>
<p>boolean isPresent() : 判断是否包含对象</p>
<p>void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</p>
</blockquote>
<h5 id="获取Optional容器的对象"><a href="#获取Optional容器的对象" class="headerlink" title="获取Optional容器的对象"></a>获取Optional容器的对象</h5><blockquote>
<p>T get() : 如果调用对象包含值，返回该值，否则抛异常</p>
<p>T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。</p>
<p>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</p>
<p>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</p>
</blockquote>
<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.basic.versionfeature.java8.optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Optional类：为了在程序中避免出现空指针异常而创建的。</span></span><br><span class="line"><span class="comment"> * 常用的方法：ofNullable(T t)</span></span><br><span class="line"><span class="comment"> *      orElse(T t)</span></span><br><span class="line"><span class="comment"> * 其他方法：</span></span><br><span class="line"><span class="comment"> *      Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</span></span><br><span class="line"><span class="comment"> *      Optional.empty() : 创建一个空的 Optional 实例</span></span><br><span class="line"><span class="comment"> *      Optional.ofNullable(T t)：t可以为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">        girl = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">        Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">        girl = <span class="literal">null</span>;</span><br><span class="line">        Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">tingting</span> <span class="operator">=</span> optionalGirl.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;liutingting&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;girl: &quot;</span> + tingting);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">        boy = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">girlName</span> <span class="operator">=</span> getGirlName3(boy);</span><br><span class="line">        System.out.println(girlName);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getGirlName</span><span class="params">(Boy boy)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boy.getGirl().getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优化以后的getGirlName()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGirlName2</span><span class="params">(Boy boy)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (boy != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> boy.getGirl();</span><br><span class="line">            <span class="keyword">if</span> (girl != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> girl.getName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用optional优化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGirlName3</span><span class="params">(Boy boy)</span> &#123;</span><br><span class="line">        Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">liufei</span> <span class="operator">=</span> boyOptional.orElse(<span class="keyword">new</span> <span class="title class_">Boy</span>());</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> liufei.getGirl();</span><br><span class="line">        Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">liutingting</span> <span class="operator">=</span> girlOptional.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;liutingting&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> liutingting.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> &#123;</span><br><span class="line">    Girl girl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(Girl girl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.girl = girl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Girl <span class="title function_">getGirl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> girl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/28/RabbitMQ/" rel="prev" title="RabbitMQ">
      <i class="fa fa-chevron-left"></i> RabbitMQ
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/28/Spring/" rel="next" title="Spring">
      Spring <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">Java 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">Java发展历程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">Java语言特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%A4%E7%A7%8D%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">Java两种核心机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="nav-number">1.4.</span> <span class="nav-text">字符编码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">Java 基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.1.</span> <span class="nav-text">标识符与关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.</span> <span class="nav-text">数据类型及强制类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.2.1.</span> <span class="nav-text">变量的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">2.2.2.</span> <span class="nav-text">数据类型说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.3.</span> <span class="nav-text">基本数据类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">隐式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">强制转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.3.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.3.1.</span> <span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.2.</span> <span class="nav-text">赋值运算符的一个问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.3.3.</span> <span class="nav-text">逻辑运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">Java 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">类与对象概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A6%82%E8%BF%B0"><span class="nav-number">3.2.</span> <span class="nav-text">内存分配概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%B2%A1%E6%9C%89%E5%88%9D%E5%A7%8B%E5%80%BC%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.3.</span> <span class="nav-text">局部变量没有初始值的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">变量与方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">3.4.1.</span> <span class="nav-text">成员变量与局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.2.</span> <span class="nav-text">成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">3.4.3.</span> <span class="nav-text">方法的重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.4.</span> <span class="nav-text">方法参数的值传递机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.5.</span> <span class="nav-text">可变参数的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.4.6.</span> <span class="nav-text">构造方法及注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-this"><span class="nav-number">3.4.7.</span> <span class="nav-text">关键字 this</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%80%A7%E4%B8%8E%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">3.5.</span> <span class="nav-text">封装性与权限修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%80%A7%E6%A6%82%E8%BF%B0"><span class="nav-number">3.5.1.</span> <span class="nav-text">封装性概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#package"><span class="nav-number">3.5.2.</span> <span class="nav-text">package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import"><span class="nav-number">3.5.3.</span> <span class="nav-text">import</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">3.5.4.</span> <span class="nav-text">四种访问权限修饰符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">3.6.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%A6%82%E8%BF%B0"><span class="nav-number">3.6.1.</span> <span class="nav-text">继承概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">3.6.2.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-number">3.6.3.</span> <span class="nav-text">方法的重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%88%E7%95%A5%EF%BC%89"><span class="nav-number">3.6.4.</span> <span class="nav-text">重写与重载的比较（略）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.5.</span> <span class="nav-text">抽象类与抽象方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.6.6.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E7%89%88%E6%9C%AC%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%94%B9%E5%8A%A8"><span class="nav-number">3.6.7.</span> <span class="nav-text">JDK版本中接口的改动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK7%EF%BC%9A%E5%B8%B8%E9%87%8F%E3%80%81%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.7.1.</span> <span class="nav-text">JDK7：常量、抽象方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK8%EF%BC%9A%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.7.2.</span> <span class="nav-text">JDK8：默认方法、静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK9%EF%BC%9A%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.7.3.</span> <span class="nav-text">JDK9：私有方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">3.6.8.</span> <span class="nav-text">接口与抽象类的对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-static-%E5%92%8C-final"><span class="nav-number">3.7.</span> <span class="nav-text">关键字 static 和 final</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">3.7.1.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.7.2.</span> <span class="nav-text">使用范围及注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="nav-number">3.7.3.</span> <span class="nav-text">类变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.4.</span> <span class="nav-text">类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main%E6%96%B9%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="nav-number">3.7.5.</span> <span class="nav-text">main方法说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-number">3.7.6.</span> <span class="nav-text">final</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.8.</span> <span class="nav-text">代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.8.1.</span> <span class="nav-text">静态代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.8.2.</span> <span class="nav-text">非静态代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.8.3.</span> <span class="nav-text">成员变量的赋值顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.8.4.</span> <span class="nav-text">同步代码块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">3.9.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%A6%82%E8%BF%B0"><span class="nav-number">3.9.1.</span> <span class="nav-text">多态概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.9.2.</span> <span class="nav-text">多态的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="nav-number">3.9.3.</span> <span class="nav-text">几点说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E4%B8%8A%E9%80%A0%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E9%80%A0%E5%9E%8B"><span class="nav-number">3.9.4.</span> <span class="nav-text">向上造型和向下造型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instance-of"><span class="nav-number">3.9.5.</span> <span class="nav-text">instance of</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="nav-number">3.9.6.</span> <span class="nav-text">虚拟方法调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">3.10.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="nav-number">3.10.1.</span> <span class="nav-text">内部类概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E9%9D%99%E6%80%81-x2F-%E9%9D%9E%E9%9D%99%E6%80%81%EF%BC%89"><span class="nav-number">3.10.2.</span> <span class="nav-text">成员内部类（静态&#x2F;非静态）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">3.10.3.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">3.10.4.</span> <span class="nav-text">匿名内部类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">Object类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#equals"><span class="nav-number">4.1.</span> <span class="nav-text">equals()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99equals-%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">4.1.1.</span> <span class="nav-text">重写equals()的原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x3D-x3D-%E4%B8%8Eequals"><span class="nav-number">4.1.2.</span> <span class="nav-text">&#x3D;&#x3D;与equals</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toString-NaN"><span class="nav-number">4.2.</span> <span class="nav-text">toString()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">Java常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK%E4%B8%BB%E8%A6%81%E5%8C%85%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.1.</span> <span class="nav-text">JDK主要包介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">5.2.</span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">5.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="nav-number">5.2.2.</span> <span class="nav-text">装箱和拆箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">5.2.3.</span> <span class="nav-text">包装类的缓存问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String"><span class="nav-number">5.3.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Objects"><span class="nav-number">5.4.</span> <span class="nav-text">Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Objects-requireNonNull-obj"><span class="nav-number">5.4.1.</span> <span class="nav-text">Objects.requireNonNull(obj)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">6.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%A6%82%E8%BF%B0"><span class="nav-number">6.1.</span> <span class="nav-text">异常概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Error%E4%B8%8EException%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.</span> <span class="nav-text">Error与Exception的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-number">6.3.</span> <span class="nav-text">编译时异常和运行时异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">6.4.</span> <span class="nav-text">Java异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%80%EF%BC%9Atry-catch-finally"><span class="nav-number">6.5.</span> <span class="nav-text">异常处理机制一：try-catch-finally</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#try"><span class="nav-number">6.5.1.</span> <span class="nav-text">try</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#catch-Exceptiontype-e"><span class="nav-number">6.5.2.</span> <span class="nav-text">catch(Exceptiontype e)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E7%9A%84%E6%9C%89%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="nav-number">6.5.3.</span> <span class="nav-text">捕获异常的有关信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finally"><span class="nav-number">6.5.4.</span> <span class="nav-text">finally</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finally-x2F-return"><span class="nav-number">6.5.5.</span> <span class="nav-text">finally&#x2F;return</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-with-resources"><span class="nav-number">6.5.6.</span> <span class="nav-text">try-with-resources</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="nav-number">6.5.7.</span> <span class="nav-text">方法重写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%BA%8C%EF%BC%9Athrows"><span class="nav-number">6.6.</span> <span class="nav-text">异常处理机制二：throws</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%8A%9B%E5%87%BA%EF%BC%9Athrows"><span class="nav-number">6.6.1.</span> <span class="nav-text">声明抛出：throws</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%EF%BC%9Athrow"><span class="nav-number">6.6.2.</span> <span class="nav-text">手动抛出：throw</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="nav-number">6.7.</span> <span class="nav-text">自定义异常类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="nav-number">7.1.</span> <span class="nav-text">进程、线程、协程、调度方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-number">7.1.1.</span> <span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.1.2.</span> <span class="nav-text">进程与线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="nav-number">7.1.3.</span> <span class="nav-text">调度策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">7.2.</span> <span class="nav-text">线程的创建和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="nav-number">7.2.1.</span> <span class="nav-text">方式一：继承Thread类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread%E7%9A%84%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.1.1.</span> <span class="nav-text">Thread的常用构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#run-x2F-start"><span class="nav-number">7.2.1.2.</span> <span class="nav-text">run() &#x2F; start()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.2.2.</span> <span class="nav-text">方式二：实现Runnable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.3.</span> <span class="nav-text">两种方式的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread%E7%B1%BB%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="nav-number">7.3.</span> <span class="nav-text">Thread类的相关方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">7.4.</span> <span class="nav-text">线程的优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">7.5.</span> <span class="nav-text">线程的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">7.6.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">7.7.</span> <span class="nav-text">线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%94%AE%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="nav-number">7.7.1.</span> <span class="nav-text">售票问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">7.7.2.</span> <span class="nav-text">数据安全问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">7.8.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C%E5%88%A9%E5%BC%8A"><span class="nav-number">7.8.0.1.</span> <span class="nav-text">同步的范围和利弊</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%94%81%EF%BC%9A-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E9%94%81"><span class="nav-number">7.8.0.2.</span> <span class="nav-text">同步锁： 同步机制中的锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC"><span class="nav-number">7.9.</span> <span class="nav-text">JUC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC%E7%AE%80%E4%BB%8B"><span class="nav-number">7.9.1.</span> <span class="nav-text">JUC简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">7.9.2.</span> <span class="nav-text">volatile关键字：内存可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E4%B8%8ECAS%E7%AE%97%E6%B3%95"><span class="nav-number">7.9.3.</span> <span class="nav-text">原子变量与CAS算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap%E9%94%81%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="nav-number">7.9.4.</span> <span class="nav-text">ConcurrentHashMap锁分段机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="nav-number">7.9.5.</span> <span class="nav-text">辅助类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch%E9%97%AD%E9%94%81"><span class="nav-number">7.9.5.1.</span> <span class="nav-text">CountDownLatch闭锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F"><span class="nav-number">7.9.5.2.</span> <span class="nav-text">CyclicBarrier循环栅栏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore%E4%BF%A1%E5%8F%B7%E7%81%AF"><span class="nav-number">7.9.5.3.</span> <span class="nav-text">Semaphore信号灯</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.9.6.</span> <span class="nav-text">实现Callable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock%E5%90%8C%E6%AD%A5%E9%94%81"><span class="nav-number">7.9.7.</span> <span class="nav-text">Lock同步锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">7.9.8.</span> <span class="nav-text">生产者消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">7.9.9.</span> <span class="nav-text">Condition控制线程通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%AB%E9%94%81"><span class="nav-number">7.9.10.</span> <span class="nav-text">线程八锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%8C%89%E5%BA%8F%E4%BA%A4%E6%9B%BF%E6%89%A7%E8%A1%8C"><span class="nav-number">7.9.11.</span> <span class="nav-text">线程按序交替执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">7.9.12.</span> <span class="nav-text">ReadWriteLock读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%AB%E9%94%81-1"><span class="nav-number">7.9.13.</span> <span class="nav-text">线程八锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D"><span class="nav-number">7.9.13.1.</span> <span class="nav-text">第一种</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D"><span class="nav-number">7.9.13.2.</span> <span class="nav-text">第二种</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D"><span class="nav-number">7.9.13.3.</span> <span class="nav-text">第三种</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%A7%8D"><span class="nav-number">7.9.13.4.</span> <span class="nav-text">第四种</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%A7%8D"><span class="nav-number">7.9.13.5.</span> <span class="nav-text">第五种</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%A7%8D"><span class="nav-number">7.9.13.6.</span> <span class="nav-text">第六种</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%A7%8D"><span class="nav-number">7.9.13.7.</span> <span class="nav-text">第七种</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%A7%8D"><span class="nav-number">7.9.13.8.</span> <span class="nav-text">第八种</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.9.14.</span> <span class="nav-text">Callable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">7.9.15.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">7.9.16.</span> <span class="nav-text">线程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoinPool%E5%88%86%E6%94%AF%E3%80%81%E5%90%88%E5%B9%B6%E6%A1%86%E6%9E%B6"><span class="nav-number">7.9.17.</span> <span class="nav-text">ForkJoinPool分支、合并框架</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IO"><span class="nav-number">8.</span> <span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#File%E7%B1%BB"><span class="nav-number">8.1.</span> <span class="nav-text">File类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81"><span class="nav-number">8.2.</span> <span class="nav-text">String编码解码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%B5%81%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-number">8.3.</span> <span class="nav-text">IO流概述与分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">8.4.</span> <span class="nav-text">字节输出流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">8.5.</span> <span class="nav-text">字节输入流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">8.6.</span> <span class="nav-text">字节缓冲流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">8.7.</span> <span class="nav-text">字符输入&#x2F;输出流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">8.8.</span> <span class="nav-text">字符缓冲流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="nav-number">8.9.</span> <span class="nav-text">打印流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">8.10.</span> <span class="nav-text">数据流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="nav-number">8.11.</span> <span class="nav-text">对象流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RandomAccessFile"><span class="nav-number">8.12.</span> <span class="nav-text">RandomAccessFile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO"><span class="nav-number">8.13.</span> <span class="nav-text">NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">8.13.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Path%E3%80%81Paths%E5%92%8CFiles%E6%A0%B8%E5%BF%83API"><span class="nav-number">8.13.2.</span> <span class="nav-text">Path、Paths和Files核心API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Path%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.13.3.</span> <span class="nav-text">Path接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Files-%E7%B1%BB"><span class="nav-number">8.13.4.</span> <span class="nav-text">Files 类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO-1"><span class="nav-number">9.</span> <span class="nav-text">NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-BIO%E7%BC%96%E7%A8%8B"><span class="nav-number">9.1.</span> <span class="nav-text">Java BIO编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">9.1.1.</span> <span class="nav-text">同步、异步、阻塞、非阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">9.1.2.</span> <span class="nav-text">IO模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO%E3%80%81NIO%E3%80%81AIO%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="nav-number">9.1.3.</span> <span class="nav-text">BIO、NIO、AIO适用场景分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-BIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">9.1.4.</span> <span class="nav-text">Java BIO 基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">9.1.5.</span> <span class="nav-text">BIO 应用实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-BIO-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">9.1.6.</span> <span class="nav-text">Java BIO 问题分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-NIO%E7%BC%96%E7%A8%8B"><span class="nav-number">9.2.</span> <span class="nav-text">Java NIO编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-NIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">9.2.1.</span> <span class="nav-text">Java NIO 基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-number">9.2.2.</span> <span class="nav-text">NIO 三大核心原理示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88Buffer%EF%BC%89"><span class="nav-number">9.2.3.</span> <span class="nav-text">缓冲区（Buffer）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">9.2.3.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Buffer-%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB"><span class="nav-number">9.2.3.2.</span> <span class="nav-text">Buffer 类及其子类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ByteBuffer"><span class="nav-number">9.2.3.3.</span> <span class="nav-text">ByteBuffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%81%93-Channel"><span class="nav-number">9.2.4.</span> <span class="nav-text">通道(Channel)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">9.2.4.1.</span> <span class="nav-text">基本介绍</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">10.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">10.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">10.2.</span> <span class="nav-text">Java反射的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class-%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AE%9E%E4%BE%8B"><span class="nav-number">10.3.</span> <span class="nav-text">Class 类及其实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-%E7%B1%BB"><span class="nav-number">10.3.1.</span> <span class="nav-text">Class 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">10.3.2.</span> <span class="nav-text">Class 类的常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Class-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%88%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-number">10.3.3.</span> <span class="nav-text">获取 Class 类的实例（四种方法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%9C%89Class%E5%AF%B9%E8%B1%A1"><span class="nav-number">10.3.4.</span> <span class="nav-text">哪些类型可以有Class对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">10.3.5.</span> <span class="nav-text">反射的基本使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">10.4.</span> <span class="nav-text">类的加载与ClassLoader的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">10.4.1.</span> <span class="nav-text">类的加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA"><span class="nav-number">10.4.2.</span> <span class="nav-text">类初始化时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="nav-number">10.4.3.</span> <span class="nav-text">类的初始化步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8ClassLoader"><span class="nav-number">10.4.4.</span> <span class="nav-text">类加载器ClassLoader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">10.4.5.</span> <span class="nav-text">JVM的类加载机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">10.4.6.</span> <span class="nav-text">Java中的内置类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ClassLoader-%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">10.4.6.1.</span> <span class="nav-text">ClassLoader 中的两个方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">10.5.</span> <span class="nav-text">双亲委派机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">10.6.</span> <span class="nav-text">Class对象的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">10.6.1.</span> <span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="nav-number">10.6.2.</span> <span class="nav-text">获取运行时类的完整结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="nav-number">10.6.3.</span> <span class="nav-text">调用运行时类的指定结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">10.6.4.</span> <span class="nav-text">加载外部配置文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">10.7.</span> <span class="nav-text">反射的应用：动态代理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">11.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%83%8C%E6%99%AF"><span class="nav-number">11.1.</span> <span class="nav-text">泛型的设计背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">11.2.</span> <span class="nav-text">泛型的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%B3%9B%E5%9E%8B%EF%BC%88Generic%EF%BC%89"><span class="nav-number">11.3.</span> <span class="nav-text">为什么要有泛型（Generic）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="nav-number">11.4.</span> <span class="nav-text">自定义泛型结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">11.5.</span> <span class="nav-text">泛型类、泛型接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">11.6.</span> <span class="nav-text">泛型方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E4%B8%8A%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="nav-number">11.7.</span> <span class="nav-text">泛型在继承上的体现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">12.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">12.1.</span> <span class="nav-text">枚举类的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">12.2.</span> <span class="nav-text">枚举类的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">12.3.</span> <span class="nav-text">枚举类的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">12.4.</span> <span class="nav-text">自定义枚举类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#enum%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">12.5.</span> <span class="nav-text">enum定义枚举类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Enum%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">12.6.</span> <span class="nav-text">Enum类的主要方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">12.7.</span> <span class="nav-text">实现接口的枚举类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">13.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Annotation-%E6%A6%82%E8%BF%B0"><span class="nav-number">13.1.</span> <span class="nav-text">Annotation 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">13.2.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84Annotation%E7%A4%BA%E4%BE%8B"><span class="nav-number">13.3.</span> <span class="nav-text">常见的Annotation示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="nav-number">13.3.1.</span> <span class="nav-text">示例一：生成文档相关的注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5%EF%BC%88JDK%E5%86%85%E7%BD%AE%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3%EF%BC%89"><span class="nav-number">13.3.2.</span> <span class="nav-text">示例二：在编译时进行格式检查（JDK内置的三个基本注解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%89%EF%BC%9A%E8%B7%9F%E8%B8%AA%E4%BB%A3%E7%A0%81%E4%BE%9D%E8%B5%96%E6%80%A7%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9B%BF%E4%BB%A3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD"><span class="nav-number">13.3.3.</span> <span class="nav-text">示例三：跟踪代码依赖性，实现替代配置文件功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3"><span class="nav-number">13.4.</span> <span class="nav-text">JDK内置注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3%EF%BC%88%E7%94%A8%E4%BA%8E%E4%BF%AE%E9%A5%B0%E5%85%B6%E4%BB%96-Annotation%EF%BC%89"><span class="nav-number">13.5.</span> <span class="nav-text">元注解（用于修饰其他 Annotation）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-number">13.6.</span> <span class="nav-text">自定义注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK7%E4%B8%AD%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">13.7.</span> <span class="nav-text">JDK7中注解的新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK8%E4%B8%AD%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">13.8.</span> <span class="nav-text">JDK8中注解的新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E4%BF%A1%E6%81%AF"><span class="nav-number">13.9.</span> <span class="nav-text">利用反射获取注解信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">14.</span> <span class="nav-text">版本特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java8"><span class="nav-number">14.1.</span> <span class="nav-text">Java8</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B"><span class="nav-number">14.1.1.</span> <span class="nav-text">新特性简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">14.1.2.</span> <span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">14.1.2.1.</span> <span class="nav-text">Lambda语法示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%EF%BC%88Functional%EF%BC%89%E6%8E%A5%E5%8F%A3"><span class="nav-number">14.1.3.</span> <span class="nav-text">函数式（Functional）接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">14.1.3.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">14.1.3.2.</span> <span class="nav-text">自定义函数式接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">14.1.3.3.</span> <span class="nav-text">Java 内置四大核心函数式接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B"><span class="nav-number">14.1.3.4.</span> <span class="nav-text">函数式接口示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-number">14.1.4.</span> <span class="nav-text">方法引用与构造器引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">14.1.4.1.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">14.1.4.2.</span> <span class="nav-text">方法引用示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-number">14.1.4.3.</span> <span class="nav-text">构造器引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8"><span class="nav-number">14.1.4.4.</span> <span class="nav-text">数组引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream"><span class="nav-number">14.1.5.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%81%E4%B8%8E%E4%B8%B2%E8%A1%8C%E6%B5%81"><span class="nav-number">14.1.5.1.</span> <span class="nav-text">并行流与串行流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream%E7%AE%80%E4%BB%8B"><span class="nav-number">14.1.5.2.</span> <span class="nav-text">Stream简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">14.1.5.3.</span> <span class="nav-text">Stream的创建方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E9%80%9A%E8%BF%87%E9%9B%86%E5%90%88"><span class="nav-number">14.1.5.3.1.</span> <span class="nav-text">方式一：通过集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84Arrays"><span class="nav-number">14.1.5.3.2.</span> <span class="nav-text">方式二：通过数组Arrays</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E9%80%9A%E8%BF%87Stream%E7%9A%84of"><span class="nav-number">14.1.5.3.3.</span> <span class="nav-text">方式三：通过Stream的of()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E5%9B%9B%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%97%A0%E9%99%90%E6%B5%81"><span class="nav-number">14.1.5.3.4.</span> <span class="nav-text">方式四：创建无限流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Stream%E7%9A%84%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B"><span class="nav-number">14.1.5.3.5.</span> <span class="nav-text">Stream的创建示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream-%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="nav-number">14.1.5.4.</span> <span class="nav-text">Stream 的中间操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%9B%E9%80%89%E4%B8%8E%E5%88%87%E7%89%87"><span class="nav-number">14.1.5.4.1.</span> <span class="nav-text">筛选与切片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%A0-%E5%B0%84"><span class="nav-number">14.1.5.4.2.</span> <span class="nav-text">映 射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">14.1.5.4.3.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B"><span class="nav-number">14.1.5.4.4.</span> <span class="nav-text">流的中间操作示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream-%E7%9A%84%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">14.1.5.5.</span> <span class="nav-text">Stream 的终止操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9F%A5%E6%89%BE"><span class="nav-number">14.1.5.5.1.</span> <span class="nav-text">匹配与查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%92%E7%BA%A6"><span class="nav-number">14.1.5.5.2.</span> <span class="nav-text">归约</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%B6%E9%9B%86"><span class="nav-number">14.1.5.5.3.</span> <span class="nav-text">收集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Stream%E7%9A%84%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B"><span class="nav-number">14.1.5.5.4.</span> <span class="nav-text">Stream的终止操作示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Optional"><span class="nav-number">14.1.5.6.</span> <span class="nav-text">Optional</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">14.1.5.6.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAOptional%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">14.1.5.6.2.</span> <span class="nav-text">创建Optional类对象的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%ADOptional%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%AF%B9%E8%B1%A1"><span class="nav-number">14.1.5.6.3.</span> <span class="nav-text">判断Optional容器中是否包含对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Optional%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">14.1.5.6.4.</span> <span class="nav-text">获取Optional容器的对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">14.1.5.6.5.</span> <span class="nav-text">使用示例</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fei</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
